/*
Author: Romain Madar & Gabriel Facini
Date:   2012-02-16
Email:  romain.madar@cern.ch, gabriel.facini@cern.ch


Description : This code allows the check quality of fit performed in the limit derivation.
              It works on a generic workspace produced by hist2workspace command. It performs
	      a global fit and a fit per subchannel automatically. Various control plots (pull 
	      distribution, correlation matrix, distribution before and after fit, ...) are 
	      stored in a the rootfile FitCrossChecks.root.


Updates:

- 2012-09-20 G. Facini
   * Get Histograms to plot systematic shapes
   * Add plotRelative flag to plot the relative shape difference for a given systematic
   * Add drawPlots flag to make eps files
   * Toys (still in developpement)
   * components post-fit

- 2012-10 R. Madar
   * Post-fit NP versus subchannel
   * Morphing control plots for each syst x process x subchannel
   * Add the stack of different backgrounds in plot after profiling

- 2012-11 R. Madar
   * Add the asymmetric error given by minos for the NPs
   * Add the -2Log(L) versus each NP
   * Add a red color for/summary of suspicious NPs

*/
 

// C++
#include <iostream>
#include <fstream>
#include <sstream>
#include <algorithm>
#include <map>

// Root
#include "TFile.h"
#include "TROOT.h"
#include "TSystem.h"
#include "TStyle.h"
#include "TLatex.h"
#include "TCanvas.h"
#include "TList.h"
#include "TMath.h"
#include "TH1.h"
#include "TH2.h"
#include "TF1.h"
#include "TGaxis.h"
#include "TTree.h"
#include "TLeaf.h"
#include "TMarker.h"
// RooFit
#include "RooWorkspace.h"
#include "RooRealVar.h"
#include "RooPlot.h"
#include "RooAbsData.h"
#include "RooHist.h"
#include "RooSimultaneous.h"
#include "RooCategory.h"
#include "RooFitResult.h"
#include "RooAbsData.h"
#include "RooRealSumPdf.h"
#include "Roo1DTable.h"
#include "RooConstVar.h"
#include "RooProduct.h"
#include "RooRandom.h"
#include "TStopwatch.h"
#include "RooNLLVar.h"
#include "RooMsgService.h"

// RooStat
#include "RooStats/ModelConfig.h"
#include "RooStats/ProfileInspector.h"
#include "RooStats/ProfileLikelihoodCalculator.h"
#include "RooStats/LikelihoodInterval.h"
#include "RooStats/LikelihoodIntervalPlot.h"
#include "RooStats/ProfileLikelihoodTestStat.h"
#include "RooStats/SamplingDistribution.h"
#include "RooStats/SamplingDistPlot.h"
#include "RooStats/ToyMCSampler.h"
#include "RooStats/RooStatsUtils.h"
#include "RooStats/MinNLLTestStat.h"


using namespace std;
using namespace RooFit;
using namespace RooStats;

struct NPContainer{ 
  TString NPname; 
  double  NPvalue; 
  double  NPerrorHi;
  double  NPerrorLo;
  TString WhichFit;
};

namespace LimitCrossCheck{  

  // Global variables;
  // User configuration one
  bool drawPlots(false);                    // create eps & png files and create a webpage
  bool plotRelative(false);                 // plot % shift of systematic
  bool UseMinosError(false);                // compute minos error (if false : use minuit error)
  double PullMaxAcceptable(1.5);            // Threshold to consider a NP[central value] as suspicious
  double ErrorMinAcceptable(0.2);           // Threshold to consider a NP[error] as suspicious
  TString xAxisLabel("Final Distribution"); // set what the x-axis of the distribution is
  
  // not switches
  RooWorkspace *w         ;
  ModelConfig  *mc        ;
  RooAbsData   *data      ;
  TFile        *outputfile; 
  double        LumiRelError;
  TDirectory   *MainDirSyst;
  TDirectory   *MainDirMorphing;
  TDirectory   *MainDirFitEachSubChannel;
  TDirectory   *MainDirFitGlobal;
  TDirectory   *MainDirModelInspector;
  TDirectory   *MainDirStatTest;
  map <string,double> MapNuisanceParamNom;
  vector<NPContainer> AllNPafterEachFit;
  TString OutputDir;
  
  //Global functions
  void     PlotHistosBeforeFit(double nSigmaToVary, double mu);
  void     PlotMorphingControlPlots();
  void     PlotHistosAfterFitEachSubChannel(bool IsConditionnal , double mu);
  void     PlotHistosAfterFitGlobal(bool IsConditionnal , double mu);
  void     PlotsNuisanceParametersVSmu();
  void     PlotsStatisticalTest(double mu_pe, double mu_hyp);
  double   FindMuUpperLimit();
  void     PrintModelObservables();
  void     PrintNuisanceParameters();
  void     PrintAllParametersAndValues(RooArgSet para);
  void     PrintNumberOfEvents(RooAbsPdf *pdf);
  void     PrintSubChannels();
  void     PrintSuspiciousNPs();
  bool     IsSimultaneousPdfOK();
  bool     IsChannelNameOK();
  void     SetAllNuisanceParaToSigma(double Nsigma);
  void     SetAllStatErrorToSigma(double Nsigma);
  void     SetNuisanceParaToSigma(RooRealVar *var, double Nsigma);
  void     GetNominalValueNuisancePara();
  void     SetNominalValueNuisancePara();
  void     SetPOI(double mu);
  void     SetStyle();
  void     LegendStyle(TLegend* l);
  TCanvas* DrawShift(TString channel, TString var, TString comp, double mu, TH1* d, TH1* n, TH1* p1s, TH1* m1s);
  

  //======================================================
  // ================= Main function =====================
  //======================================================
  void PlotFitCrossChecks(const char* infile          =  "WorkspaceForTest1.root",
		 	  const char* outputdir       = "./results/",
			  const char* workspaceName   = "combined",
			  const char* modelConfigName = "ModelConfig",
			  const char* ObsDataName     = "obsData"){
    
    // Cosmetics
    SetStyle();

    // Lumi error hard-coded;
    LumiRelError = 0.032; //should be 0.032
    
    // Container for the plots
    OutputDir = (TString) outputdir;
    gSystem->Exec("mkdir -p " + OutputDir);
    gSystem->Exec("mkdir -p " + OutputDir + "/LatexFileNPs");
    gSystem->Exec("mkdir -p " + OutputDir + "/TextFileFitResult");
    outputfile = new TFile(OutputDir+"/FitCrossChecks.root","RECREATE");
    
    // Load workspace, model and data
    TFile *file = TFile::Open(infile);
    if (!file) {
      cout << "The file " << infile << " is not found/created, will stop here." << endl;
      return;
    }
    if(!(RooWorkspace*) file->Get(workspaceName)){
      cout <<"workspace not found" << endl;
      return;
    }

    w      = (RooWorkspace*) file->Get(workspaceName);
    mc     = (ModelConfig*) w->obj(modelConfigName);
    data   = w->data(ObsDataName);

    if(!data) return;

    w->SetName("w");
    w->SetTitle("w");
    // save snapshot before any fit has been done
    RooSimultaneous* pdf = (RooSimultaneous*) w->pdf("simPdf");

    //maybe this is a combined workspaces?
    if(!pdf) pdf = (RooSimultaneous*) w->pdf("combPdf");

    RooArgSet* params = (RooArgSet*) pdf->getParameters(*data) ;

    if(!w->loadSnapshot("snapshot_paramsVals_initial"))  w->saveSnapshot("snapshot_paramsVals_initial",*params);
    else cout << endl << " Snapshot 'snapshot_paramsVals_initial' already exists in  workspace, will not overwrite it" << endl;
   /* if(!data || !mc){
      w->Print();
      cout << "data or ModelConfig was not found" <<endl;
      return;
    }*/
    if(!data){
      w->Print();
      cout << "data was not found" <<endl;
      return;
    }
    if(!mc){
      w->Print();
      cout << "ModelConfig was not found" <<endl;
      return;
    }

    // Some sanity checks on the workspace
    if ( !IsSimultaneousPdfOK() ) return;
    if (   !IsChannelNameOK()   ) return;
    GetNominalValueNuisancePara();
    AllNPafterEachFit.clear();


    // Print some information
    PrintModelObservables();
    PrintNuisanceParameters();
    PrintSubChannels();
    
    // Prepare the directory structure of the outputfile
    MainDirSyst              = (TDirectory*) outputfile->mkdir("PlotsBeforeFit");
    MainDirMorphing          = (TDirectory*) outputfile->mkdir("PlotsMorphing");
    MainDirFitEachSubChannel = (TDirectory*) outputfile->mkdir("PlotsAfterFitOnSubChannel");
    MainDirFitGlobal         = (TDirectory*) outputfile->mkdir("PlotsAfterGlobalFit");
    MainDirModelInspector    = (TDirectory*) outputfile->mkdir("PlotsNuisanceParamVSmu");
    MainDirStatTest          = (TDirectory*) outputfile->mkdir("PlotsStatisticalTest");
    gROOT->cd();


    // -----------------------------------------------------------------------------------
    // 1 - Plot nominal and +/- Nsigma (for each nuisance paramater) for Data, signal+bkg
    // -----------------------------------------------------------------------------------
    double MuUpperLimit = 10; //FindMuUpperLimit();
    RooRealVar * firstPOI = dynamic_cast<RooRealVar*>(mc->GetParametersOfInterest()->first());
    double mumax = firstPOI->getMax();
    if (MuUpperLimit>mumax) MuUpperLimit=mumax;
     PlotHistosBeforeFit(1.0,0.0); // (nSigma,mu)
    

    // -----------------------------------------------------------------------------------
    // 2 - Control plots for morphing (ie, -1/0/+1 sigma --> continuous NP)
    // -----------------------------------------------------------------------------------    
    //  PlotMorphingControlPlots();


    // ----------------------------------------------------------------------------------
    // 3 - Plot histograms after unconditional fit (theta and mu fitted at the same time)
    // ----------------------------------------------------------------------------------    
    bool IsConditional = true;//fixme false;
    //   PlotHistosAfterFitEachSubChannel(IsConditional,0.0);
    PlotHistosAfterFitGlobal(IsConditional,0.0);
        
    
    // --------------------------------------------------------------------------------------------
    // 4 - Plot the unconditionnal fitted nuisance paramters value (theta fitted while mu is fixed)
    // -------------------------------------------------------------------------------------------
    IsConditional = true;
    //    PlotHistosAfterFitEachSubChannel(IsConditional, 0.0);
    //   PlotHistosAfterFitGlobal(IsConditional,0.0);
    //PlotHistosAfterFitEachSubChannel(IsConditional, 1.0);
    //    PlotHistosAfterFitGlobal(IsConditional,1.0);


    // -------------------------------------------
    // 5 - Plot the nuisance parameters versus mu
    // -------------------------------------------
    //PlotsNuisanceParametersVSmu(); // This can take time



    // -------------------------------------------
    // 6 - Plot the pulls and stat test from toys
    // -------------------------------------------
    //    PlotsStatisticalTest(0,0);

    outputfile->Close();


    PrintSuspiciousNPs();  
    return;
  
  }
  










  // ============================================================
  // ============ Definition of all the functions ===============
  // ============================================================


  void PlotHistosBeforeFit(double nSigmaToVary, double mu){
    int scale_bool = 1;
    cout << endl << "Plotting Histos Before Fit " << endl;
    cout << "\t Plotting relative " << plotRelative << endl;

    RooMsgService::instance().setGlobalKillBelow(ERROR);

    TString MaindirName("MuIsEqualTo_");
    MaindirName += mu;
    if(plotRelative) { MaindirName.Append("_relative"); }
    TDirectory *MainDir = (TDirectory*) MainDirSyst->mkdir(MaindirName);
    gROOT->cd();

    // Get the RooSimultaneous PDF
    RooSimultaneous *simPdf = (RooSimultaneous*)(mc->GetPdf());
    RooRealVar * firstPOI = dynamic_cast<RooRealVar*>(mc->GetParametersOfInterest()->first());
    firstPOI->setVal(mu);

    RooCategory* channelCat = (RooCategory*) (&simPdf->indexCat());
    TIterator* iter = channelCat->typeIterator() ;
    RooCatType* tt = NULL;    
    TString dirName("");
    while((tt=(RooCatType*) iter->Next()) ){
      
      cout << endl;
      cout << endl;
      cout << " -- On category " << tt->GetName() << " " << endl;
      ostringstream SubdirName;
      SubdirName << tt->GetName();
      TDirectory *SubDirChannel = (TDirectory*) MainDir->mkdir(SubdirName.str().c_str());
      gROOT->cd();
    
      // Get pdf associated with state from simpdf
      RooAbsPdf  *pdftmp  = simPdf->getPdf(tt->GetName()) ;
      RooArgSet  *obstmp  = pdftmp->getObservables( *mc->GetObservables() ) ;
      RooAbsData *datatmp = data->reduce(Form("%s==%s::%s",channelCat->GetName(),channelCat->GetName(),tt->GetName()));
      RooRealVar *obs     = ((RooRealVar*) obstmp->first());

      // Get the bin width
      RooRealVar* binWidth = ((RooRealVar*) pdftmp->getVariables()->find(Form("binWidth_obs_x_%s_0",tt->GetName()))) ;

      //check if this might be a combined file...
      if(!binWidth){
	TString bwName = tt->GetName();
	bwName.ReplaceAll("_file","_0_file");
	bwName = "binWidth_obs_x_"+bwName;
	binWidth = ((RooRealVar*) pdftmp->getVariables()->find(bwName));
      }

      //If we still cannot find it, then give up
      if(!binWidth) { cout << "No bin width!" << tt->GetName() << endl; return; }
      cout << "    Bin Width : " << binWidth->getVal() << endl;

      // First be sure that all nuisance parameters are nominal
      SetAllStatErrorToSigma(0.0);
      SetAllNuisanceParaToSigma(0.0);

      // Look at each component
      cout << "    Contains the following components : " << endl;
      TString modelName(tt->GetName());
      modelName.Append("_model");

      RooRealSumPdf *pdfmodel = (RooRealSumPdf*) (pdftmp->getComponents())->find(modelName);
      if(!pdfmodel){
	modelName.ReplaceAll("_fileOne_model", "_model_fileOne");
	modelName.ReplaceAll("_fileTwo_model", "_model_fileTwo");
	modelName.ReplaceAll("_fileThree_model", "_model_fileThree");
	pdfmodel = (RooRealSumPdf*) (pdftmp->getComponents())->find(modelName);
      }
      if(!pdfmodel){ cout << "No pdfmodel: " << modelName << endl; return;}
      RooArgList funcList =  pdfmodel->funcList();
      RooLinkedListIter funcIter = funcList.iterator() ;
      RooProduct* comp = 0;
      float total(0);
      SetPOI(1);	 // want to see signal
      map<TString, TH1*> nominals;
      while( (comp = (RooProduct*) funcIter.Next())) { 
        cout << " Component : " << comp->GetName() << endl;
        cout << "\t" << ( comp->createIntegral(*obs) )->getVal() * binWidth->getVal() << endl;
        total += ( comp->createIntegral(*obs) )->getVal() * binWidth->getVal();
      }
      SetPOI(mu);	
      cout << " Total (mu = 1) : " << total << endl;

      // Loop over nuisance params
      TIterator* it = mc->GetNuisanceParameters()->createIterator();
      RooRealVar* var = NULL;
      bool IsAllStatDone = false; 
      TString chanName(tt->GetName());
      while( (var = (RooRealVar*) it->Next()) ){

        string varname = (string) var->GetName();
        if ( varname.find("gamma_stat")!=string::npos ){
          continue;
        }

        // one sigma not defined for floating parameters 
        // is there a more general way of getting to this fact?
        if ( varname.find("ATLAS_norm")!=string::npos ){
          continue;
        }
        if ( varname.find("ATLAS_sampleNorm")!=string::npos ){
	  continue;
        }

        // user firendly label / name
        TString varName(var->GetName());
        varName.ReplaceAll("alpha_Sys","");
        varName.ReplaceAll("alpha_","");

        dirName = OutputDir+"/"+MainDirSyst->GetName()+"/"+MaindirName+"/"+chanName+"/"+varName;

        // Not consider nuisance parameter being not assocaited to systematics
        if (MapNuisanceParamNom[varname]!=0.0 &&
            MapNuisanceParamNom[varname]!=1.0 ) continue;

        cout << endl;
        cout << "  -- On nuisance parameter : " << var->GetName() << endl; 

        TString histName("");

        // -1 sigma
        SetNuisanceParaToSigma(var,-nSigmaToVary);
        SetPOI(mu);
        histName = chanName+"_"+varName+"_"+TString(plotRelative)+"_m1sigma";
        TH1* hm1sigma = pdftmp->createHistogram(histName,*obs);
	if(scale_bool)hm1sigma->Scale(pdftmp->expectedEvents(*obs)/hm1sigma->Integral());

        // +1 sigma
        SetNuisanceParaToSigma(var,+nSigmaToVary);
        SetPOI(mu);	
        histName.ReplaceAll("m1sigma","p1sigma");
        TH1* hp1sigma = pdftmp->createHistogram(histName,*obs);
	if(scale_bool)hp1sigma->Scale(pdftmp->expectedEvents(*obs)/hp1sigma->Integral());


        // Nominal
        SetNuisanceParaToSigma(var,0.0);
        SetPOI(mu);
        histName.ReplaceAll("p1sigma","nominal");
        TH1* hnominal = pdftmp->createHistogram(histName,*obs);
	if(scale_bool)hnominal->Scale(pdftmp->expectedEvents(*obs)/hnominal->Integral());
	
        // Data
        histName.ReplaceAll("nominal","data");
        TH1* hdata = datatmp->createHistogram(histName,*obs);
	for (int ib=0 ; ib<hdata->GetNbinsX()+1 ; ib++) hdata->SetBinError(ib, sqrt(hdata->GetBinContent(ib)));


        TString expName("AllBkg(#mu=");
        expName += mu;
        expName.Append(")");
        TCanvas* c2 = DrawShift(chanName,(TString)var->GetName(),expName,mu,hdata,hnominal,hp1sigma,hm1sigma);

        SubDirChannel->cd();
        c2->Write();
        if(drawPlots) { 
          system(TString("mkdir -vp "+dirName));
          c2->Print(dirName+"/totalExpected.eps");
          c2->Print(dirName+"/totalExpected.png");
        }
        c2->Close();
        gROOT->cd();

        // reset pointer
        hdata->~TH1();
        hnominal->~TH1();
        hp1sigma->~TH1();
        hm1sigma->~TH1();
        hdata = 0;
        hnominal = 0;
        hp1sigma = 0;
        hm1sigma = 0;

        // Loop over components and make these plots for each one
        funcIter = funcList.iterator();
        while( (comp = (RooProduct*) funcIter.Next()) ) {
          TString compName(comp->GetName());
          compName.ReplaceAll("L_x_","");
          compName.ReplaceAll(chanName,"");
          compName.ReplaceAll("__overallSyst_x_StatUncert","");
          compName.ReplaceAll("__overallSyst_x_HistSyst","");
          compName.ReplaceAll("__overallSyst_x_Exp","");

          // Fisrt be sure that all nuisance parameters are nominal
          SetAllStatErrorToSigma(0.0);
          SetAllNuisanceParaToSigma(0.0);
          SetPOI(1);	// set to one so do not ignore signal

          // -1 sigma
          SetNuisanceParaToSigma(var,-nSigmaToVary);
          SetPOI(1);
          histName = chanName+"_"+varName+"_"+compName+"_"+TString(plotRelative)+"_m1sigma";
          hm1sigma = comp->createHistogram(histName,*obs);
          hm1sigma->Scale( binWidth->getVal() );

          // +1 sigma
          SetNuisanceParaToSigma(var,+nSigmaToVary);
          SetPOI(1);
          histName.ReplaceAll("m1sigma","p1sigma");
          hp1sigma = comp->createHistogram(histName,*obs);
          hp1sigma->Scale( binWidth->getVal() );

          // nominal
          SetNuisanceParaToSigma(var,0.0);
          SetPOI(1);
          histName.ReplaceAll("p1sigma","nominal");
          hnominal = comp->createHistogram(histName,*obs);
          hnominal->Scale( binWidth->getVal() );

          // skip components which are not affected by this nuisance parameter 
          if(hp1sigma->Integral() == 0 || hm1sigma->Integral() == 0) { 
            cout << "Integral 0 " << varName << " on " << compName << " in " << chanName 
              << " ( " << hp1sigma->Integral() << ", " << hm1sigma->Integral() << " ) " << endl;
            continue;
          }

          // skip components which are not affected by this nuisance parameter
          float totUp(0), totDn(0);
          for(int b=1; b<hnominal->GetNbinsX()+1; b++) { // no over/under-flow
            if(hnominal->GetBinContent(b)>0) {
              totUp += pow((hp1sigma->GetBinContent(b)-hnominal->GetBinContent(b))/hnominal->GetBinContent(b),2);
              totUp += pow((hm1sigma->GetBinContent(b)-hnominal->GetBinContent(b))/hnominal->GetBinContent(b),2);
            }
          }
          if( totUp < 0.05 && totDn < 0.05 ) { 
            cout << "No " << varName << " on " << compName << " in " << chanName << " ( " << totUp << ", " << totDn << " ) " << endl;
            continue; 
          }

          c2 = DrawShift(chanName,(TString)var->GetName(),compName,mu,0,hnominal,hp1sigma,hm1sigma);

          SubDirChannel->cd();
          c2->Write();
          if(drawPlots) { 
            //system(TString("mkdir -vp "+dirName));
            c2->Print(dirName+"/"+compName+".eps");
            c2->Print(dirName+"/"+compName+".png");
          }
          c2->Close();
          gROOT->cd();

          // Put everything back to the nominal
          SetAllNuisanceParaToSigma(0.0);
          SetPOI(mu);
          
          //
          hnominal->~TH1();
          hp1sigma->~TH1();
          hm1sigma->~TH1();
          hnominal = 0;
          hp1sigma = 0;
          hm1sigma = 0;
        } // loop over components

        // Put everything back to the nominal
        SetAllNuisanceParaToSigma(0.0);
        SetPOI(mu);

        // Stat uncertainty
        if (!IsAllStatDone){

          // reset pointer
          hdata = 0;
          hnominal = 0;
          hp1sigma = 0;
          hm1sigma = 0;

          // -1 sigma
          SetAllStatErrorToSigma(-nSigmaToVary);
          SetAllNuisanceParaToSigma(0.0);
          SetPOI(mu);
          histName = chanName+"_Stat_"+TString(plotRelative)+"_m1sigma";
          hm1sigma = pdftmp->createHistogram(histName,*obs);
          hm1sigma->Scale(pdftmp->expectedEvents(*obs)/hm1sigma->Integral());

          // +1 sigma
          SetAllStatErrorToSigma(+nSigmaToVary);
          SetAllNuisanceParaToSigma(0.0);
          SetPOI(mu);	
          histName.ReplaceAll("m1sigma","p1sigma");
          hp1sigma = pdftmp->createHistogram(histName,*obs);
          hp1sigma->Scale(pdftmp->expectedEvents(*obs)/hp1sigma->Integral());

          // Nominal
          SetAllStatErrorToSigma(0.0);
          SetNuisanceParaToSigma(var,0.0);
          SetPOI(mu);
          histName.ReplaceAll("p1sigma","nominal");
          hnominal = pdftmp->createHistogram(histName,*obs);
          hnominal->Scale(pdftmp->expectedEvents(*obs)/hnominal->Integral());

          // Data
          histName.ReplaceAll("nominal","data");
          hdata = datatmp->createHistogram(histName,*obs);
	  for (int ib=0 ; ib<hdata->GetNbinsX()+1 ; ib++) hdata->SetBinError(ib, sqrt(hdata->GetBinContent(ib)));

	  cout << endl;
	  cout << " - stat uncertainty : " << endl;
          TCanvas* c4 = DrawShift(chanName,"Stat",expName,mu,hdata,hnominal,hp1sigma,hm1sigma);

          dirName = OutputDir+"/"+MainDirSyst->GetName()+"/"+MaindirName+"/"+chanName+"/Stat";
          SubDirChannel->cd();
          c4->Write();
          if(drawPlots) { 
            system(TString("mkdir -vp "+dirName));
            c4->Print(dirName+"/totalExpected.eps");
            c4->Print(dirName+"/totalExpected.png");
          }
          c4->Close();
          gROOT->cd();

          IsAllStatDone=true;
        }

      }
      
    } 
    
    return;
  }
  

  // create the canvas and put stuff on it 
  // to be used when plotting the +/- 1 sigma shifts
  TCanvas* DrawShift(TString channel, TString var, TString comp, double mu, TH1* d, TH1* n, TH1* p1s, TH1* m1s) {
    cout << " " << comp << endl;
    cout << "N(-sigma) = " << m1s->Integral() << endl;
    cout << "N(+sigma) = " << p1s->Integral() << endl;
    cout << "N(nominal) = " << n->Integral() << endl;
    if(d) { cout << "N(Observed) = " << d->Integral() << endl; }

    var.ReplaceAll("alpha_Sys","");
    var.ReplaceAll("alpha_","");

    TString cname = "can_" + channel + "_" + comp + "_" + var + "_mu";
    cname += mu;
    if(plotRelative) { cname.Append("_relative"); }
    cname.ReplaceAll("#","");
    cname.ReplaceAll("(","");
    cname.ReplaceAll(")","");
    cname.ReplaceAll("=","");
    TCanvas *canvas = new TCanvas(cname,cname,700,550);
    canvas->cd();
    TPad *pad1 = new TPad("pad1","pad1",0,0.25,1,1);
    pad1->SetBottomMargin(0.009);
    pad1->Draw();
    TPad *pad2 = new TPad("pad2","pad2",0,0,1,0.25);
    pad2->SetTopMargin(0.009);
    pad2->SetBottomMargin(0.5);
    pad2->Draw();
    
    // style
    if(d) { 
      d->SetLineColor(1);
      d->SetLineWidth(1); 
      d->SetMarkerColor(1); 
      d->SetMarkerSize(0.9); 
      d->SetMarkerStyle(20); 
    }
    n->SetLineWidth(2);
    p1s->SetLineColor(kRed);
    p1s->SetLineWidth(2);
    p1s->SetLineStyle(2);
    m1s->SetLineColor(kGreen);
    m1s->SetLineWidth(2);
    m1s->SetLineStyle(2);

    float max(0);
    float min(0);

    // put averages on the plot
    float avgUp = ( p1s->Integral() - n->Integral() ) / n->Integral();
    float avgDn = ( m1s->Integral() - n->Integral() ) / n->Integral();

    // Distribution in the upper pad
    pad1->cd();
    n->SetTitle(channel);
    n->GetXaxis()->SetTitle(xAxisLabel);
    max = p1s->GetMaximum();
    if(m1s->GetMaximum() > max) { max = m1s->GetMaximum(); }
    if(n->GetMaximum() > max) { max = n->GetMaximum(); }
    if(d) { if(d->GetMaximum() > max) { max = d->GetMaximum(); } }
    n->SetMaximum( 1.2*max );
    n->Draw("hist");
    if(d) { d->Draw("E1 same"); }
    p1s->Draw("hist same");
    m1s->Draw("hist same");
    
    // Distribution of the ratio in %
    pad2->cd();
    TH1F *p1s_ratio = (TH1F*) p1s->Clone();
    p1s_ratio->Add(n,-1); p1s_ratio->Divide(n); p1s_ratio->Scale(100);
    p1s_ratio->SetLineStyle(1);
    TH1F *m1s_ratio = (TH1F*) m1s->Clone();
    m1s_ratio->Add(n,-1); m1s_ratio->Divide(n); m1s_ratio->Scale(100);
    m1s_ratio->SetLineStyle(1);
    max = p1s_ratio->GetMaximum();
    if(m1s_ratio->GetMaximum() > max) { max = m1s_ratio->GetMaximum(); }
    min = p1s_ratio->GetMinimum();
    if(m1s_ratio->GetMinimum() < min) { min = m1s_ratio->GetMinimum(); }
    p1s_ratio->SetMaximum( 1.5*max );
    p1s_ratio->SetMinimum( min - 0.5*fabs(min) );
    p1s_ratio->GetYaxis()->SetNdivisions(004);
    p1s_ratio->GetXaxis()->SetTitleFont(43);
    p1s_ratio->GetXaxis()->SetTitleSize(16);
    p1s_ratio->GetXaxis()->SetTitleOffset(4);
    p1s_ratio->GetYaxis()->SetTitleOffset(1.1);
    p1s_ratio->GetYaxis()->SetTitleFont(43);
    p1s_ratio->GetYaxis()->SetTitleSize(13);
    p1s_ratio->GetXaxis()->SetLabelFont(43);
    p1s_ratio->GetXaxis()->SetLabelSize(13);
    p1s_ratio->GetYaxis()->SetLabelFont(43);
    p1s_ratio->GetYaxis()->SetLabelSize(13);
    p1s_ratio->SetTitle("");
    p1s_ratio->GetYaxis()->SetTitle("Rel. unc. (%)");
    p1s_ratio->Draw("hist");
    m1s_ratio->Draw("hist same");
    if (d){
      TH1F *d_ratio = (TH1F*) d->Clone();
      d_ratio->Add(n,-1); d_ratio->Divide(n); d_ratio->Scale(100);
      d_ratio->Draw("E1 same");
    }


    // get max and min and draw
    //  -- old way, just keep for book-keeping --
    if(plotRelative) {
      // draw percent error bands
      p1s->Add(n,-1); p1s->Divide(n); p1s->Scale(100);
      m1s->Add(n,-1); m1s->Divide(n); m1s->Scale(100);
      p1s->GetYaxis()->SetTitle("Percent Error");
      p1s->SetTitle(channel);
      p1s->GetXaxis()->SetTitle(xAxisLabel);
      max = p1s->GetMaximum();
      if(m1s->GetMaximum() > max) { max = m1s->GetMaximum(); }
      min = p1s->GetMinimum();
      if(m1s->GetMinimum() < min) { min = m1s->GetMinimum(); }
      p1s->SetMaximum( 1.5*max );
      p1s->SetMinimum( min - 0.5*fabs(min) );
      canvas->cd();
      p1s->Draw("hist");
      m1s->Draw("hist same");
      // draw nominal with a seperate axis on a transparent pad
      TPad *pad = new TPad("pad","pad",0,0,1,1);
      pad->SetFillStyle(4000); //will be transparent
      pad->SetFrameFillStyle(4000);
      pad->SetLeftMargin(canvas->GetLeftMargin());
      pad->SetRightMargin(canvas->GetRightMargin());
      pad->SetTopMargin(canvas->GetTopMargin());
      pad->SetBottomMargin(canvas->GetBottomMargin());
      pad->Draw();
      pad->cd();
      // new axis
      float xloc = n->GetXaxis()->GetBinLowEdge( n->GetNbinsX()+1 );
      TGaxis *axis = new TGaxis(xloc,0,xloc,p1s->GetMaximum(),0,n->GetMaximum(),510,"+L");
      axis->SetTitle(n->GetYaxis()->GetTitle());
      axis->SetTitleColor(kBlue);
      axis->SetLabelColor(kBlue);
      //axis->SetTitleFont(mFont);
      n->SetLineColor(kBlue);
      n->SetLineStyle(kDashed);
      n->GetYaxis()->SetTitle(""); n->SetTitle(""); n->GetXaxis()->SetTitle("");
      //n->Draw("hist ah e");
      n->Draw("hist ah");
      axis->Draw("same");
      pad->Update();
    }
    
    // write average shift on canvas
    if (!plotRelative) pad1->cd();
    TString info(var+" "+comp);
    info.Append(Form(" %5.2f, %5.2f",avgUp*100,avgDn*100));
    info.Append('%'); 
    TLatex *niceinfo = new TLatex(0.12, 0.85, info);
    niceinfo->SetNDC();
    niceinfo->SetTextSize(0.045);
    niceinfo->Draw("same");

    // legend
    TLegend *leg = new TLegend(0.67, 0.64, 0.87, 0.86);
    LegendStyle(leg);
    TString varLegName(var);
    varLegName.ReplaceAll("alpha_Sys","");
    varLegName.ReplaceAll("alpha_","");
    if(!plotRelative && d) { leg->AddEntry( d, "Data", "p" ); }
    leg->AddEntry( n, comp, "l" );
    leg->AddEntry( p1s, "+#sigma", "l" );
    leg->AddEntry( m1s, "-#sigma", "l" );
    leg->Draw();

    return canvas;
  } // DrawShift
  


  
  
  void PlotMorphingControlPlots(){
        
    cout << endl << "Plotting Systematic morphing control plots" << endl;    
    RooMsgService::instance().setGlobalKillBelow(ERROR);
    
    // Get the RooSimultaneous PDF
    RooSimultaneous *simPdf = (RooSimultaneous*)(mc->GetPdf());
    RooRealVar * firstPOI = dynamic_cast<RooRealVar*>(mc->GetParametersOfInterest()->first());
    double mu=0;
    firstPOI->setVal(mu);
    
    RooCategory* channelCat = (RooCategory*) (&simPdf->indexCat());
    TIterator* iter = channelCat->typeIterator() ;
    RooCatType* tt = NULL;    
    TString dirName("");
    while((tt=(RooCatType*) iter->Next()) ){
      
      cout << endl;
      cout << endl;
      cout << " -- On category " << tt->GetName() << " " << endl;
      ostringstream SubdirName;
      SubdirName << tt->GetName();
      TDirectory *SubDirChannel = (TDirectory*) MainDirMorphing->mkdir(SubdirName.str().c_str());
      gROOT->cd();
    
      // Get pdf associated with state from simpdf
      RooAbsPdf  *pdftmp  = simPdf->getPdf(tt->GetName()) ;
      RooArgSet  *obstmp  = pdftmp->getObservables( *mc->GetObservables() ) ;
      RooRealVar *obs     = ((RooRealVar*) obstmp->first());

      // First be sure that all nuisance parameters are nominal
      SetAllStatErrorToSigma(0.0);
      SetAllNuisanceParaToSigma(0.0);

      // Loop over nuisance params
      TIterator* it = mc->GetNuisanceParameters()->createIterator();
      RooRealVar* var = NULL;
      TString chanName(tt->GetName());
      while( (var = (RooRealVar*) it->Next()) ){

        string varname = (string) var->GetName();
        if ( varname.find("gamma_stat")!=string::npos ){
          continue;
        }

        if ( varname.find("ATLAS_norm")!=string::npos ){
          continue;
        }
        if ( varname.find("ATLAS_sampleNorm")!=string::npos ){
          continue;
        }

        // user friendly label / name
        TString varName(var->GetName());
        varName.ReplaceAll("alpha_Sys","");
        varName.ReplaceAll("alpha_","");

        // Not consider nuisance parameter being not assocaited to systematics
        if (MapNuisanceParamNom[varname]!=0.0 &&
            MapNuisanceParamNom[varname]!=1.0 ) continue;

	cout << endl;
        cout << "  -- On nuisance parameter : " << var->GetName() << endl; 
	TDirectory *SubDirNP = (TDirectory*) SubDirChannel->mkdir(varName);
	gROOT->cd();
       
        TString cname = "can_" + (TString)tt->GetName() + "_" + varName;
	TCanvas* c2 = new TCanvas( cname );
	c2->cd();
	TH1* hh = pdftmp->createHistogram("hh_"+cname,*obs,YVar(*var,Binning(60)) ) ;
	hh->SetLineColor(kBlue) ;
	hh->GetZaxis()->SetTitleOffset(2.5) ; hh->Draw("surf") ;

	SubDirNP->cd();
        c2->Write();
        c2->Close();
        gROOT->cd();

        // Loop over components and make these plots for each one
	TString modelName(tt->GetName());
	modelName.Append("_model");
	RooRealSumPdf *pdfmodel = (RooRealSumPdf*) (pdftmp->getComponents())->find(modelName);

	if(!pdfmodel){
	  modelName.ReplaceAll("_fileOne_model", "_model_fileOne");
	  modelName.ReplaceAll("_fileTwo_model", "_model_fileTwo");
	  modelName.ReplaceAll("_fileThree_model", "_model_fileThree");
	  pdfmodel = (RooRealSumPdf*) (pdftmp->getComponents())->find(modelName);
	}
	if(!pdfmodel){ cout << "No pdfmodel: " << modelName << endl; return;}
	RooArgList funcList =  pdfmodel->funcList();
	RooLinkedListIter funcIter = funcList.iterator() ;
	RooProduct* comp = 0;
        while( (comp = (RooProduct*) funcIter.Next()) ) {
          TString compName(comp->GetName());
          compName.ReplaceAll("L_x_","");
          compName.ReplaceAll(chanName,"");
          compName.ReplaceAll("__overallSyst_x_StatUncert","");
          compName.ReplaceAll("__overallSyst_x_HistSyst","");
          compName.ReplaceAll("__overallSyst_x_Exp","");

	  // Fisrt be sure that all nuisance parameters are nominal
          SetAllStatErrorToSigma(0.0);
          SetAllNuisanceParaToSigma(0.0);
          SetPOI(1);	// set to one so do not ignore signal
	  
	  cname = "can_" + (TString)tt->GetName() + "_" + compName + "_" + varName;
	  TCanvas* c3 = new TCanvas( cname );
	  c2->cd();
	  
	  hh = comp->createHistogram("hh_"+cname,*obs,YVar(*var,Binning(60)) ) ;
	  hh->SetLineColor(kBlue) ;
	  hh->GetZaxis()->SetTitleOffset(2.5) ; hh->Draw("surf") ;
	  
	  SubDirNP->cd();
	  c3->Write();
	  c3->Close();
	  gROOT->cd();
	  
          // Put everything back to the nominal
          SetAllNuisanceParaToSigma(0.0);
          SetPOI(mu);

        } // loop over components
	
	
        // Put everything back to the nominal
        SetAllNuisanceParaToSigma(0.0);
        SetPOI(mu);
  
      }
    }
    
    return;
  }
  


  void PlotHistosAfterFitEachSubChannel(bool IsConditionnal, double mu){
    cout << endl << "Plotting Histos After Fit in Each Subchannel" << endl;
    
    // Prepare NP_i[after fit] vs category histogram
    map < TString,vector<NPContainer> > MapChannelNPs;

    // Conditionnal or unconditional fit
    TString TS_IsConditionnal;
    if (IsConditionnal) TS_IsConditionnal="conditionnal";
    else                TS_IsConditionnal="unconditionnal";
    RooRealVar * firstPOI = dynamic_cast<RooRealVar*>(mc->GetParametersOfInterest()->first());
    firstPOI->setVal(mu);

    ostringstream MaindirName;
    if (IsConditionnal) MaindirName << TS_IsConditionnal << "_MuIsEqualTo_" << mu;
    else                MaindirName << TS_IsConditionnal;
    TDirectory *MainDir =  (TDirectory*) MainDirFitEachSubChannel->mkdir(MaindirName.str().c_str());
    gROOT->cd();
    
    // Get the RooSimultaneous PDF
    RooSimultaneous *simPdf = (RooSimultaneous*)(mc->GetPdf());
    
    RooCategory* channelCat = (RooCategory*) (&simPdf->indexCat());
    TIterator *iter = channelCat->typeIterator() ;
    RooCatType *tt  = NULL;

    //    TH1D* h_status = new TH1D("Fit Status", "Fit Status",

    while((tt=(RooCatType*) iter->Next()) ){
     
      cout << endl;
      cout << endl;
      cout << " -- On category " << tt->GetName() << " " << endl;
      ostringstream SubdirName;
      SubdirName << tt->GetName();
      TDirectory *SubDirChannel = (TDirectory*) MainDir->mkdir(SubdirName.str().c_str());
      gROOT->cd();
         
      // Get pdf and datset associated to the studied channel
      RooAbsPdf  *pdftmp  = simPdf->getPdf( tt->GetName() );
      RooArgSet  *obstmp  = pdftmp->getObservables( *mc->GetObservables() ) ;
      RooAbsData *datatmp = data->reduce(Form("%s==%s::%s",channelCat->GetName(),channelCat->GetName(),tt->GetName()));
      RooRealVar *obs = ((RooRealVar*) obstmp->first());
      
      // Fit 
      if (IsConditionnal) firstPOI->setConstant();
      ROOT::Math::MinimizerOptions::SetDefaultStrategy(2);
      RooFitResult *fitres = pdftmp->fitTo( *datatmp , Save() , Minos(UseMinosError) );
      cout << endl;
      cout << endl;
      if (IsConditionnal) cout << "Conditionnal fit : mu is fixed at " << mu << endl;
      else                cout << "Unconditionnal fit : mu is fitted" << endl;
      double muhat = firstPOI->getVal();
      firstPOI->setConstant(kFALSE);
  
      // Plotting the nuisance paramaters correlations during the fit
      TString cname = "can_NuisPara_" + (TString)tt->GetName() + "_" + TS_IsConditionnal + "_mu";
      cname += mu;
      TCanvas* c1 = new TCanvas( cname, cname, 1260, 500);
      c1->Divide(2,1);
      TH2D *h2DcorrelationOrig = (TH2D*) fitres->correlationHist(cname);
      
      //remove MC stats entries
      int nKeep=0;
      for(int nx=1; nx<=h2DcorrelationOrig->GetNbinsY(); nx++){
	TString vname(h2DcorrelationOrig->GetXaxis()->GetBinLabel(nx));
	if(vname.Contains("gamma_")) continue;
	nKeep++;
      }

      TH2D* h2Dcorrelation = new TH2D("CovMatrix",h2DcorrelationOrig->GetTitle(),nKeep,0,1,nKeep,0,1);
      int ix=0;
      int iy=0;
      for(int nx=1; nx<=h2DcorrelationOrig->GetNbinsY(); nx++){
	TString vnamex(h2DcorrelationOrig->GetXaxis()->GetBinLabel(nx));
	if(vnamex.Contains("gamma_")) continue;

	ix++;
	for(int ny=1; ny<=h2DcorrelationOrig->GetNbinsY(); ny++){
	  TString vnamey(h2DcorrelationOrig->GetYaxis()->GetBinLabel(ny));
	  if(vnamey.Contains("gamma_")) continue;
	  iy++;
	  h2Dcorrelation->SetBinContent(ix,iy,h2DcorrelationOrig->GetBinContent(nx,ny));
	  h2Dcorrelation->GetXaxis()->SetBinLabel(ix,h2DcorrelationOrig->GetXaxis()->GetBinLabel(nx));
	  h2Dcorrelation->GetYaxis()->SetBinLabel(iy,h2DcorrelationOrig->GetYaxis()->GetBinLabel(ny));
	}
	iy=0;
      }

      TString hname = "Corr_NuisPara_"+ (TString)tt->GetName() + "_"  + TS_IsConditionnal + "_mu";
      h2Dcorrelation->SetName(hname);
      
      for(int nx=1; nx<=h2Dcorrelation->GetNbinsY(); nx++){
	TString vname(h2Dcorrelation->GetXaxis()->GetBinLabel(nx));
	vname.ReplaceAll("alpha_","");
	vname.ReplaceAll("gamma_","");
	//	vname.ReplaceAll("Lumi","Luminosity");
	vname.ReplaceAll("_","\\_");
	h2Dcorrelation->GetXaxis()->SetBinLabel(nx,vname);
      }

      for(int ny=1; ny<=h2Dcorrelation->GetNbinsY(); ny++){
	TString vname(h2Dcorrelation->GetYaxis()->GetBinLabel(ny));
	vname.ReplaceAll("alpha_","");
	vname.ReplaceAll("gamma_","");
	//	vname.ReplaceAll("Lumi","Luminosity");
	vname.ReplaceAll("_","\\_");
	h2Dcorrelation->GetYaxis()->SetBinLabel(ny,vname);
      }
      h2Dcorrelation->GetZaxis()->SetRangeUser(-1.0,1.0);
      h2Dcorrelation->SetMaximum(1.0);
      h2Dcorrelation->SetMinimum(-1.0);
      c1->cd(1); h2Dcorrelation->Draw("colz");

      // Plotting the nuisance paramaters after fit
      TString h1name = "h_NuisParaPull_" + (TString)tt->GetName() + "_" + TS_IsConditionnal + "_mu";
      h1name += mu;
      TIterator* it1 = mc->GetNuisanceParameters()->createIterator();
      RooRealVar* var = NULL;
      int Npar=0;
      int NparNotStat=0;
      while( (var = (RooRealVar*) it1->Next()) ) {
	Npar++;
	string varname = (string) var->GetName();      
	if (varname.find("gamma_stat")==string::npos) NparNotStat++;
      }
      NparNotStat=NparNotStat;
      TH1F * h1Dpull_axis = new TH1F(h1name,h1name,NparNotStat,0,NparNotStat);

      TGraphAsymmErrors *h1Dpull = new TGraphAsymmErrors(NparNotStat);
      h1Dpull->SetLineWidth(2);
      h1Dpull->SetLineColor(1);
      h1Dpull->SetMarkerColor(1);
      h1Dpull->SetMarkerStyle(21);
      h1Dpull->SetMarkerSize(1.2);      
      h1Dpull_axis->GetYaxis()->SetRangeUser(-5.5,5.5);
      h1Dpull_axis->GetXaxis()->SetTitle("#theta");
      h1Dpull_axis->GetYaxis()->SetTitle("(#theta_{fit} - #theta_{0}) / #Delta#theta");

      // Create a latex table of NPs after fit
      vector <NPContainer> MyNPContainerVector; MyNPContainerVector.clear();
      TString fname = OutputDir + "/LatexFileNPs/Fit"+(TString)tt->GetName()+"_nuisPar_"+TS_IsConditionnal+"_mu";
      fname += mu;
      fname += ".tex";
      ofstream fnuisPar(fname.Data());
      TString fnuiscorr = OutputDir + "/TextFileFitResult/Fit"+(TString)tt->GetName()+"_fitres_"+TS_IsConditionnal+"_mu";
      fnuiscorr += mu;
      fnuiscorr += ".txt";
      ofstream fnuisParAndCorr(fnuiscorr.Data());
      fnuisParAndCorr << "NUISANCE_PARAMETERS" << endl;
      
      fnuisPar << endl;
      fnuisPar << "\\begin{tabular}{|l|c|}" << endl;
      fnuisPar << "\\hline" << endl;
      fnuisPar << "Nuisance parameter & postfit value (in $\\sigma$ unit) \\\\\\hline" << endl;

      if(!IsConditionnal){
	fnuisPar.precision(3);
	fnuisPar << "$\\mu$ & $" << firstPOI->getVal() << "^{+" << firstPOI->getErrorHi() << "}_{-" << fabs(firstPOI->getErrorLo()) << "}$ \\\\" << endl;
	
	NPContainer MyNPTemp;
	MyNPTemp.NPname  = "#mu";
	MyNPTemp.NPvalue = firstPOI->getVal();
	MyNPTemp.NPerrorLo = firstPOI->getErrorLo();
	MyNPTemp.NPerrorHi = firstPOI->getErrorHi();
	MyNPContainerVector.push_back(MyNPTemp);
      }
      

      vector<TGraphAsymmErrors*> vec_MyGraph;
      vec_MyGraph.clear();
      int ib=0;
      TIterator* it2 = mc->GetNuisanceParameters()->createIterator();
      while( (var = (RooRealVar*) it2->Next()) ){

	// Not consider nuisance parameter being not associated to syst
	string varname = (string) var->GetName();
	if ( (varname.find("gamma_stat")!=string::npos) ) continue;
	
	double pull  = var->getVal() / 1.0 ; // GetValue() return value in unit of sigma
	double errorHi = var->getErrorHi() / 1.0; 
	double errorLo = var->getErrorLo() / 1.0; 
	
	if(strcmp(var->GetName(),"Lumi")==0){
	  pull  = (var->getVal() - w->var("nominalLumi")->getVal() ) / (w->var("nominalLumi")->getVal() * LumiRelError );
	  errorHi = var->getErrorHi() / (w->var("nominalLumi")->getVal() * LumiRelError);
	  errorLo = var->getErrorLo() / (w->var("nominalLumi")->getVal() * LumiRelError); 
	}
	
	TString vname=var->GetName();
	vname.ReplaceAll("alpha_","");
	vname.ReplaceAll("gamma_","");
	//	vname.ReplaceAll("Lumi","Luminosity");
	vname.ReplaceAll("_","\\_");
	fnuisPar.precision(3);
	fnuisPar << vname << " & $" << pull << "^{+" << fabs(errorHi) << "}_{-" << fabs(errorLo)  << "}$ \\\\" << endl;
	fnuisParAndCorr << vname << " & $" << pull << "^{+ " << fabs(errorHi) << "}_{-" << fabs(errorLo)  << "}$ \\\\" << endl;
	
	NPContainer MyNPsTemp;
	MyNPsTemp.NPname  = vname;
	MyNPsTemp.NPvalue = pull;
	MyNPsTemp.NPerrorHi = errorHi;
	MyNPsTemp.NPerrorLo = errorLo;
	MyNPContainerVector.push_back(MyNPsTemp);

	MyNPsTemp.WhichFit = TS_IsConditionnal+"_FitOnChannel_"+(TString)tt->GetName()+"_Mu";
	MyNPsTemp.WhichFit += mu;
	AllNPafterEachFit.push_back(MyNPsTemp);

	ib++;
	double xc = h1Dpull_axis->GetBinCenter(ib);
	TString vname2=var->GetName();
	vname2.ReplaceAll("alpha_","");
	vname2.ReplaceAll("gamma_","");
	vname2.ReplaceAll("ATLAS_","");
	h1Dpull_axis->GetXaxis()->SetBinLabel(ib,vname2);

	h1Dpull->SetPoint(ib-1,xc,pull);
	h1Dpull->SetPointEXlow(ib-1 ,h1Dpull_axis->GetBinWidth(ib)/3.0);
	h1Dpull->SetPointEXhigh(ib-1,h1Dpull_axis->GetBinWidth(ib)/3.0);
	h1Dpull->SetPointEYlow(ib-1 ,fabs(errorLo));
	h1Dpull->SetPointEYhigh(ib-1,fabs(errorHi));
	
	
	// Put in red NP with pull>1.5 OR Err<0.2, in black otherwise
	bool IsTooPulled = fabs(pull)>PullMaxAcceptable;
	bool IsOverConst = (fabs(errorLo)+fabs(errorHi))/2.0<ErrorMinAcceptable;
	bool IsOnesided  = UseMinosError && (errorHi==0 || errorLo==0);
	if (IsTooPulled || IsOverConst || IsOnesided){
	  TGraphAsymmErrors *myGraph = new TGraphAsymmErrors(1);
	  myGraph->SetLineWidth(2);
	  myGraph->SetLineColor(kRed+1);
	  myGraph->SetMarkerColor(kRed+1);
	  myGraph->SetMarkerStyle(21);
	  myGraph->SetMarkerSize(1.2); 
	  myGraph->SetPoint(0,xc,pull);
	  myGraph->SetPointEXlow(0 ,h1Dpull_axis->GetBinWidth(ib)/3.0);
	  myGraph->SetPointEXhigh(0,h1Dpull_axis->GetBinWidth(ib)/3.0);
	  myGraph->SetPointEYlow(0 ,fabs(errorLo));
	  myGraph->SetPointEYhigh(0,fabs(errorHi));
	  vec_MyGraph.push_back(myGraph);	
	}
      }

      MapChannelNPs[(TString)tt->GetName()] = MyNPContainerVector;

      fnuisPar << "\\hline" << endl;
      fnuisPar << "\\end{tabular}" << endl;
      fnuisPar.close();
      
      fnuisParAndCorr << endl << endl << "CORRELATION_MATRIX" << endl;
      fnuisParAndCorr << h2Dcorrelation->GetNbinsX() << "   " << h2Dcorrelation->GetNbinsY() << endl;
      for(int kk=1; kk < h2Dcorrelation->GetNbinsX()+1; kk++) {
	for(int ll=1; ll < h2Dcorrelation->GetNbinsY()+1; ll++) {
	  fnuisParAndCorr << h2Dcorrelation->GetBinContent(kk,ll) << "   ";
	}
	fnuisParAndCorr << endl;
      }
      fnuisParAndCorr << endl;
      fnuisParAndCorr.close();
      
      
      double _1SigmaValue[1000];
      double _2SigmaValue[1000];
      double NuisParamValue[1000];
      for (int i=0 ; i<NparNotStat+1 ; i++){
	_1SigmaValue[i] = 1.0;
	_1SigmaValue[2*NparNotStat-i] = -1;
	_2SigmaValue[i] = 2;
	_2SigmaValue[2*NparNotStat-i] = -2;
	NuisParamValue[i] = i;
	NuisParamValue[2*NparNotStat-1-i] = i;
      }

      TGraph *_1sigma = new TGraph(2*NparNotStat,NuisParamValue,_1SigmaValue);
      TGraph *_2sigma = new TGraph(2*NparNotStat,NuisParamValue,_2SigmaValue);
      c1->cd(2); 
      _2sigma->SetFillColor(5);
      _2sigma->SetLineColor(5);
      _2sigma->SetMarkerColor(5);
      _1sigma->SetFillColor(3);
      _1sigma->SetLineColor(3);
      _1sigma->SetMarkerColor(3);
      h1Dpull_axis->Draw("hist");
      _2sigma->Draw("F"); 
      _1sigma->Draw("F"); 
      gPad->RedrawAxis("y");
      h1Dpull->Draw("P");
      for (unsigned i=0 ; i<vec_MyGraph.size() ; i++) vec_MyGraph[i]->Draw("P");
      h1Dpull_axis->GetYaxis()->DrawClone();
      

      TLatex text;
      text.SetNDC();
      text.SetTextSize( 0.054);
      text.SetTextAlign(31);
      TString WritDownMuValue;
      if(!IsConditionnal) WritDownMuValue = "#mu_{best} = ";
      else                WritDownMuValue = "#mu_{fixed} = ";
      WritDownMuValue += Form("%2.2f",firstPOI->getVal());
      c1->cd(2); 
      text.DrawLatex( 0.87,0.81, WritDownMuValue );

      
      // Plotting the likelihood projection in each NP direction
      TDirectory *NLLprojection = (TDirectory*) SubDirChannel->mkdir("AllNNLProjections");
      gROOT->cd();
      RooAbsReal* nll = pdftmp->createNLL(*datatmp);
      if (!IsConditionnal){
	var = (RooRealVar*) firstPOI;
	TString vname=var->GetName();
	vname.ReplaceAll("alpha_","");
	vname.ReplaceAll("gamma_","");
	vname.ReplaceAll("ATLAS_","");
	RooPlot* frame2 = var->frame(Title("-log(L) vs "+vname));
	nll->plotOn(frame2,LineColor(kRed),ShiftToZero()) ;
	frame2->GetYaxis()->SetRangeUser(0.0,5.0);
	frame2->GetYaxis()->SetTitle("#Delta [-2Log(L)]");
	TCanvas *can2 = new TCanvas( "NLLscan_"+vname );
	can2->cd();
	frame2->Draw();
	NLLprojection->cd();
	can2->Write();
	gROOT->cd();
      }
      TIterator* it3 = mc->GetNuisanceParameters()->createIterator();
      while( (var = (RooRealVar*) it3->Next()) ){
	TString vname=var->GetName();
	if (vname.Contains("gamma_stat")) continue;
	vname.ReplaceAll("alpha_","");
	vname.ReplaceAll("gamma_","");
	vname.ReplaceAll("ATLAS_","");
	RooPlot* frame2 = var->frame(Title("-log(L) vs "+vname)) ;
	nll->plotOn(frame2,LineColor(kRed),ShiftToZero()) ;
	frame2->GetYaxis()->SetRangeUser(0.0,5.0);
	frame2->GetYaxis()->SetTitle("#Delta [-2Log(L)]");
	TCanvas *can2 = new TCanvas( "NLLscan_"+vname );
	can2->cd();
	frame2->Draw();
	NLLprojection->cd();
	can2->Write();
	gROOT->cd();
      }
      
      
      // Bin Width
      RooRealVar* binWidth = ((RooRealVar*) pdftmp->getVariables()->find(Form("binWidth_obs_x_%s_0",tt->GetName()))) ;

      //check if this might be a combined file...
      if(!binWidth){
	TString bwName = tt->GetName();
	bwName.ReplaceAll("_file","_0_file");
	bwName = "binWidth_obs_x_"+bwName;
	binWidth = ((RooRealVar*) pdftmp->getVariables()->find(bwName));
      }

      if(!binWidth) { cout << "No bin width " << tt->GetName() << endl; }
      cout << "    Bin Width : " << binWidth->getVal() << endl;     

      // Plotting the distributions
      cname = "can_DistriAfterFit_" + (TString)tt->GetName() + "_" + TS_IsConditionnal + "_mu";
      cname += mu;
      TCanvas* c2 = new TCanvas( cname );
      RooPlot* frame = obs->frame();
      TString FrameName = "Plot_" + (TString)tt->GetName() + "_FitIsconditional" + (TString) IsConditionnal;
      frame->SetName( FrameName );
      frame->SetYTitle("EVENTS");
      float postFitIntegral = pdftmp->expectedEvents(*obs);
      datatmp->plotOn(frame,MarkerSize(1),Name("Data"),DataError(RooAbsData::Poisson) );
      pdftmp->plotOn(frame,FillColor(kOrange),LineWidth(2),LineColor(kBlue),VisualizeError(*fitres,1),
		     Normalization(postFitIntegral,RooAbsReal::NumEvent),Name("FitError_NotAppears"));
      pdftmp->plotOn(frame,LineWidth(2),Normalization(postFitIntegral,RooAbsReal::NumEvent),Name("CentralFit_NotAppears"));
      double chi2 = frame->chiSquare();
      if(std::isnan(chi2)) chi2 = -1;

      // miniloop over componant to make a bkg stack
      TString modelName1(tt->GetName());
      modelName1.Append("_model");

      RooRealSumPdf *pdfmodel1 = (RooRealSumPdf*) (pdftmp->getComponents())->find(modelName1);
      if(!pdfmodel1){
	modelName1.ReplaceAll("_fileOne_model", "_model_fileOne");
	modelName1.ReplaceAll("_fileTwo_model", "_model_fileTwo");
	modelName1.ReplaceAll("_fileThree_model", "_model_fileThree");
	pdfmodel1 = (RooRealSumPdf*) (pdftmp->getComponents())->find(modelName1);
      }

      if(!pdfmodel1){ cout << "No pdfmodel: " << modelName1 << endl; return;}
      RooArgList funcList1 =  pdfmodel1->funcList();
      RooLinkedListIter funcIter1 = funcList1.iterator() ;
      RooProduct* comp1 = 0;
      firstPOI->setVal(0.);
      int ibkg=0;
      int icolor=0;
      TString previous="";
      while( (comp1 = (RooProduct*) funcIter1.Next()) ) {
	ibkg++;

	int color= kGray;

	TString compname(comp1->GetName());
	compname.ReplaceAll("L_x_","");
        compname.ReplaceAll(tt->GetName(),"");
        compname.ReplaceAll("_overallSyst_x_StatUncert","");
        compname.ReplaceAll("_overallSyst_x_HistSyst","");
        compname.ReplaceAll("_overallSyst_x_Exp","");
	compname.ReplaceAll("_","");
	double Ntemp = (comp1->createIntegral(*obs))->getVal() * binWidth->getVal();
	if (Ntemp!=0){
	  icolor++;
	  if(icolor==1) { color = kOrange - 3; }
	  else if(icolor==2) { color = kCyan + 1; }
	  else if(icolor==3) { color = kGreen - 9; }
	  else if(icolor==4) { color = kAzure - 9; }
	  else if(icolor==5) { color = kOrange + 10;}
	  else if(icolor==6) { color = kGreen - 6; }
	  else if(icolor==7) { color = kAzure - 4; }
	  else if(icolor==8) { color = kOrange + 6; }
	  else if(icolor==9) { color = kGreen + 1; }
	  else if(icolor==10) { color = kAzure + 2; }
	  else if(icolor==11) { color = kOrange; }
	  else if(icolor==12) { color = kGreen + 3; }
	  else if(icolor==13) { color = kAzure - 4; }
	  else if(icolor==14) { color = kOrange; }
	  else if(icolor==15) { color = kGreen + 1; }
	  else if(icolor==16) { color = kOrange - 7; }
	  else if(icolor==17) { color = kPink + 1; }
	  else   color=icolor;

	  // Get the signal x 1 in white (for further purposes)
	  if (IsConditionnal) firstPOI->setVal(1.0);
	  Ntemp=(comp1->createIntegral(*obs))->getVal() * binWidth->getVal();
	  pdfmodel1->plotOn(frame,LineWidth(0),Components(*comp1),LineColor(0), LineStyle(3), Normalization(Ntemp,RooAbsReal::NumEvent),Name("NoStacked_"+compname));
	  if (IsConditionnal) firstPOI->setVal(mu);

	  // Get the stack of background
	  Ntemp=(comp1->createIntegral(*obs))->getVal() * binWidth->getVal();
	  pdfmodel1->plotOn(frame,LineWidth(0),Components(*comp1),LineColor(0), Normalization(Ntemp,RooAbsReal::NumEvent),Name("NoStacked"+compname));
	  if (ibkg==0) pdfmodel1->plotOn(frame,LineWidth(2),Components(*comp1),LineColor(color), Normalization(Ntemp,RooAbsReal::NumEvent),Name("Stacked_"+compname));
	  else         pdfmodel1->plotOn(frame,LineWidth(2),Components(*comp1),LineColor(color), Normalization(Ntemp,RooAbsReal::NumEvent),Name("Stacked_"+compname),AddTo(previous));
	  previous="Stacked_"+compname;
	}
      }
      firstPOI->setVal(muhat);
      pdftmp->plotOn(frame,FillColor(kOrange),LineWidth(2),LineColor(kBlue),VisualizeError(*fitres,1),
		     Normalization(postFitIntegral,RooAbsReal::NumEvent),Name("FitError_AfterFit"));
      pdftmp->plotOn(frame,LineWidth(2),Normalization(postFitIntegral,RooAbsReal::NumEvent),Name("FitCentral2_NotAppears"));
      datatmp->plotOn(frame,MarkerSize(1),Name("Dat_NotAppears"),DataError(RooAbsData::Poisson));

      // Putting nuisance parameter at the central value and draw the nominal distri
      SetAllStatErrorToSigma(0.0);
      SetAllNuisanceParaToSigma(0.0);
      if (!IsConditionnal) SetPOI(0.0);
      else                 SetPOI(mu);
      TString muValueBeforeFitLegend = Form("Before fit (#mu=%2.2f)",firstPOI->getVal());
      pdftmp->plotOn(frame,LineWidth(2),Name("BeforeFit"),LineStyle(kDashed),Normalization(pdftmp->expectedEvents(*obs),RooAbsReal::NumEvent));      

      TString modelName2(tt->GetName());
      modelName2.Append("_model");

      RooRealSumPdf *pdfmodel2 = (RooRealSumPdf*) (pdftmp->getComponents())->find(modelName2);
      if(!pdfmodel2){
	modelName2.ReplaceAll("_fileOne_model", "_model_fileOne");
	modelName2.ReplaceAll("_fileTwo_model", "_model_fileTwo");
	modelName2.ReplaceAll("_fileThree_model", "_model_fileThree");
	pdfmodel2 = (RooRealSumPdf*) (pdftmp->getComponents())->find(modelName2);
      }
      if(!pdfmodel2){ cout << "No pdfmodel: " << modelName2 << endl; return;}
      RooArgList funcList2 =  pdfmodel2->funcList();
      RooLinkedListIter funcIter2 = funcList2.iterator() ;
      RooProduct* comp2 = 0;
      if (!IsConditionnal) firstPOI->setVal(muhat);
      else                 firstPOI->setVal(mu);
      ibkg=0;
      icolor=0;
      while( (comp2 = (RooProduct*) funcIter2.Next()) ) {
	ibkg++;
	int color=kGray;
	TString compname(comp2->GetName());
	compname.ReplaceAll("L_x_","");
        compname.ReplaceAll(tt->GetName(),"");
        compname.ReplaceAll("_overallSyst_x_StatUncert","");
        compname.ReplaceAll("_overallSyst_x_HistSyst","");
        compname.ReplaceAll("_overallSyst_x_Exp","");
	compname.ReplaceAll("_","");
	double Ntemp = (comp2->createIntegral(*obs))->getVal() * binWidth->getVal();
	if (Ntemp!=0){
	  icolor++;
	  if(icolor==1) { color = kOrange - 3; }
	  else if(icolor==2) { color = kCyan + 1; }
	  else if(icolor==3) { color = kGreen - 9; }
	  else if(icolor==4) { color = kAzure - 9; }
	  else if(icolor==5) { color = kOrange + 10;}
	  else if(icolor==6) { color = kGreen - 6; }
	  else if(icolor==7) { color = kAzure - 4; }
	  else if(icolor==8) { color = kOrange + 6; }
	  else if(icolor==9) { color = kGreen + 1; }
	  else if(icolor==10) { color = kAzure + 2; }
	  else if(icolor==11) { color = kOrange; }
	  else if(icolor==12) { color = kGreen + 3; }
	  else if(icolor==13) { color = kAzure - 4; }
	  else if(icolor==14) { color = kOrange; }
	  else if(icolor==15) { color = kGreen + 1; }
	  else if(icolor==16) { color = kOrange - 7; }
	  else if(icolor==17) { color = kPink + 1; }
	  else   color=icolor;
	  pdfmodel2->plotOn(frame,LineWidth(0),Components(*comp2),LineColor(0), LineStyle(3), Normalization(Ntemp,RooAbsReal::NumEvent),Name("NoStacked_BkgBeforeFit_"+compname));
	}
      }
      if (!IsConditionnal) firstPOI->setVal(muhat);
      else                 firstPOI->setVal(mu);

      c2->cd();
      frame->Draw();
      text.DrawLatex( 0.84,0.81, WritDownMuValue );
      TString ts_chi2 = Form("#chi^{2}=%1.1f",chi2);
      text.DrawLatex( 0.22, 0.83, ts_chi2 );
                  
      TLegend *leg = new TLegend(0.54,0.40,0.77,0.76);
      leg->SetBorderSize(0);
      leg->SetFillColor(0);
      leg->SetTextFont(62);
      leg->SetTextSize(0.050);
      for (int i=0; i<frame->numItems(); i++) {
	TString obj_name=frame->nameOf(i); 
        if (obj_name=="" || obj_name.Contains("NotAppears") || obj_name.Contains("NoStacked") ) continue;
        TObject *obj = frame->findObject(obj_name.Data());
        if (((string)obj_name).find("Data")   !=string::npos) { leg->AddEntry( obj , "Data" , "p"); continue; }
	TString legname;
	if (!IsConditionnal) legname = "After fit (#mu[best] S+B)";
	else                 legname = "After fit (#mu[fixed] S+B)";
        if (((string)obj_name).find("AfterFit")!=string::npos){ leg->AddEntry( obj , legname , "lf"); continue; }
	legname = muValueBeforeFitLegend;
	if (((string)obj_name).find("BeforeFit")!=string::npos){leg->AddEntry( obj ,legname , "l"); continue;}
	
	obj_name.ReplaceAll("Stacked_","");
	leg->AddEntry(obj,obj_name,"l");
      }	  
      leg->Draw();
            

      // Save plots in outputfile
      SubDirChannel->cd();
      c1->Write();
      c2->Write();
      c1->Close();
      c2->Close();
      gROOT->cd();          
    }


    // Plots of each NP[posfit] vs subchannel
    int Nchannel=0;
    int Nsyst;
    vector<NPContainer> NPvecForName;
    TIterator *iter1 = channelCat->typeIterator() ;
    RooCatType *tt1  = NULL;
    while((tt1=(RooCatType*) iter1->Next()) ){
      Nchannel++;
      if (Nchannel==1) NPvecForName = MapChannelNPs[(TString)tt1->GetName()];
    }
    Nsyst = NPvecForName.size();
    for (int isys=0 ; isys<Nsyst ; isys++){
      TString hname = NPvecForName[isys].NPname;
      hname.ReplaceAll("\\_","_");

      TH1F * hsys_axis = new TH1F(hname,hname,Nchannel,0,Nchannel);
      TGraphAsymmErrors *hsys = new TGraphAsymmErrors(Nchannel);
      hsys_axis->GetYaxis()->SetRangeUser(-5.5,5.5);
      hsys_axis->GetXaxis()->SetTitle("#theta");
      hsys_axis->GetYaxis()->SetTitle("(#theta_{fit} - #theta_{0}) / #Delta#theta");

      TString cname = "can_"+ hname;
      cname.ReplaceAll("#","");
      cname.ReplaceAll("(","");
      cname.ReplaceAll(")","");
      cname.ReplaceAll("=","");
      TCanvas* can = new TCanvas( cname, cname , 600, 500);

      TIterator *iter2 = channelCat->typeIterator() ;
      RooCatType *tt2  = NULL;
      int ich=0;
      while((tt2=(RooCatType*) iter2->Next()) ){
	ich++;
	vector<NPContainer> NPvec = MapChannelNPs[(TString)tt2->GetName()];
	double NPval   = NPvec[isys].NPvalue;
	double NPerrHi = NPvec[isys].NPerrorHi;
	double NPerrLo = NPvec[isys].NPerrorLo;

	double xc = hsys_axis->GetBinCenter(ich);
	hsys->SetPoint(ich-1,xc,NPval);
	hsys->SetPointEXlow(ich-1,hsys_axis->GetBinWidth(ich)/3.0);
	hsys->SetPointEXhigh(ich-1,hsys_axis->GetBinWidth(ich)/3.0);
	hsys->SetPointEYlow(ich-1,fabs(NPerrLo));
	hsys->SetPointEYhigh(ich-1,fabs(NPerrHi));
	hsys_axis->GetXaxis()->SetBinLabel(ich,tt2->GetName());	
      }

      double _1SigmaValue[1000];
      double _2SigmaValue[1000];
      double NuisParamValue[1000];
      for (int i=0 ; i<Nchannel+1 ; i++){
	_1SigmaValue[i] = 1.0;
	_1SigmaValue[2*Nchannel-i] = -1;
	_2SigmaValue[i] = 2;
	_2SigmaValue[2*Nchannel-i] = -2;
	NuisParamValue[i] = i;
	NuisParamValue[2*Nchannel-1-i] = i;
      }
      
      TGraph *_1sigma = new TGraph(2*Nchannel,NuisParamValue,_1SigmaValue);
      TGraph *_2sigma = new TGraph(2*Nchannel,NuisParamValue,_2SigmaValue);
      can->cd(); 
      hsys->SetLineWidth(2);
      hsys->SetLineColor(1);
      hsys->SetMarkerColor(1);
      hsys->SetMarkerStyle(21);
      hsys->SetMarkerSize(1.2);      
      _2sigma->SetFillColor(5);
      _2sigma->SetLineColor(5);
      _2sigma->SetMarkerColor(5);
      _1sigma->SetFillColor(3);
      _1sigma->SetLineColor(3);
      _1sigma->SetMarkerColor(3);
      hsys_axis->GetYaxis()->SetRangeUser(-5.0,5.0);
      hsys_axis->Draw("hist");
      if (NPvecForName[isys].NPname != "#mu"){
	_2sigma->Draw("F"); 
	_1sigma->Draw("F"); 
      }
      gPad->RedrawAxis("y");
      hsys->Draw("P");
      MainDir->cd();
      can->Write();
      can->Close();
      gROOT->cd();           
    }
       
    return;
  }


  void PlotHistosAfterFitGlobal(bool IsConditionnal, double mu){
    
    // Conditionnal or unconditional fit
    TString TS_IsConditionnal;
    if (IsConditionnal) TS_IsConditionnal="conditionnal";
    else                TS_IsConditionnal="unconditionnal";

    RooRealVar * firstPOI = dynamic_cast<RooRealVar*>(mc->GetParametersOfInterest()->first());
    firstPOI->setVal(mu);
    
    ostringstream MaindirName;
    if (IsConditionnal) MaindirName << TS_IsConditionnal << "_MuIsEqualTo_" << mu;
    else                MaindirName << TS_IsConditionnal;
    TDirectory *MainDir =  (TDirectory*) MainDirFitGlobal->mkdir(MaindirName.str().c_str());
    gROOT->cd();

    // Get the RooSimultaneous PDF
    RooSimultaneous *simPdf = (RooSimultaneous*)(mc->GetPdf());

    // Fit 
    if (IsConditionnal) firstPOI->setConstant();
    ROOT::Math::MinimizerOptions::SetDefaultStrategy(2);
    RooFitResult    *fitresGlobal  = simPdf->fitTo( *data , Save() , Hesse(kTRUE),Minos(UseMinosError) );    
    const RooArgSet *ParaGlobalFit = mc->GetNuisanceParameters();
    w->saveSnapshot("snapshot_paramsVals_GlobalFit",*ParaGlobalFit);
    double muhat = firstPOI->getVal();
    firstPOI->setConstant(kFALSE);

    
    if (IsConditionnal) cout << "Conditionnal fit : mu is fixed at " << mu << endl;
    else                cout << "Unconditionnal fit : mu is fitted" << endl;
    fitresGlobal->Print("v");


    TCanvas* cc = new TCanvas("can_NuisPara_GlobalFit_FitStatus", "can_NuisPara_GlobalFit_FitStatus", 500, 500);
    TH1D* h_status = new TH1D("Fit Status","Fit Status",2,0,1);
    h_status->Fill(1,fitresGlobal->status());
    h_status->Fill(2,fitresGlobal->covQual());
    h_status->GetXaxis()->SetBinLabel(1,"Fit Status");
    h_status->GetXaxis()->SetBinLabel(2,"Cov Quality");
    h_status->Draw();

    MainDir->cd();
    cc->Write();
    gROOT->cd();

    // PLotting the nuisance paramaters correlations during the fit
    TString cname = "can_NuisPara_GlobalFit_" + TS_IsConditionnal + "_mu";
    cname += mu;

    TString cname_meh = "meh_can_NuisPara_GlobalFit_" + TS_IsConditionnal + "_mu";
    cname_meh += mu;
    cout << "==========================   " << cname << endl;

    TCanvas* c1 = new TCanvas( cname, cname, 6500, 6000);
    TCanvas* c_meh = new TCanvas( cname_meh, cname_meh, 5000, 3000);
    c_meh->SetBottomMargin(0.5);
    c1->SetLeftMargin(0.23);
    c1->SetRightMargin(0.95);
    c1->SetBottomMargin(0.33);
    //c1->Divide(2,1);

    TH2D *h2DcorrelationOrig = (TH2D*) fitresGlobal->correlationHist();
    
    //remove MC stats entries
    int nKeep=0;
    for(int nx=1; nx<=h2DcorrelationOrig->GetNbinsY(); nx++){
      TString vname(h2DcorrelationOrig->GetXaxis()->GetBinLabel(nx));
      if(vname.Contains("gamma_")) continue;
      nKeep++;
    }
    
    TH2D* h2Dcorrelation = new TH2D("CovMatrix",h2DcorrelationOrig->GetTitle(),nKeep,0,1,nKeep,0,1);
    int ix=0;
    int iy=0;
    for(int nx=1; nx<=h2DcorrelationOrig->GetNbinsY(); nx++){
      TString vnamex(h2DcorrelationOrig->GetXaxis()->GetBinLabel(nx));
      if(vnamex.Contains("gamma_")) continue;
      
      ix++;
      for(int ny=1; ny<=h2DcorrelationOrig->GetNbinsY(); ny++){
	TString vnamey(h2DcorrelationOrig->GetYaxis()->GetBinLabel(ny));
	if(vnamey.Contains("gamma_")) continue;
	iy++;
	h2Dcorrelation->SetBinContent(ix,iy,h2DcorrelationOrig->GetBinContent(nx,ny));
	h2Dcorrelation->GetXaxis()->SetBinLabel(ix,h2DcorrelationOrig->GetXaxis()->GetBinLabel(nx));
	h2Dcorrelation->GetYaxis()->SetBinLabel(iy,h2DcorrelationOrig->GetYaxis()->GetBinLabel(ny));
      }
      iy=0;
    }
    
    TString hname = "Corr_NuisPara_GlobalFit_" + TS_IsConditionnal + "_mu";
    h2Dcorrelation->SetName(hname);

    for(int nx=1; nx<=h2Dcorrelation->GetNbinsY(); nx++){
      TString vname(h2Dcorrelation->GetXaxis()->GetBinLabel(nx));
      vname.ReplaceAll("alpha_","");
      vname.ReplaceAll("gamma_","");
      //      vname.ReplaceAll("Lumi","Luminosity");
      vname.ReplaceAll("_","\\_");
      h2Dcorrelation->GetXaxis()->SetBinLabel(nx,vname);
    }
    
    for(int ny=1; ny<=h2Dcorrelation->GetNbinsY(); ny++){
      TString vname(h2Dcorrelation->GetYaxis()->GetBinLabel(ny));
      vname.ReplaceAll("alpha_","");
      vname.ReplaceAll("gamma_","");
      //      vname.ReplaceAll("Lumi","Luminosity");
      vname.ReplaceAll("_","\\_");
      h2Dcorrelation->GetYaxis()->SetBinLabel(ny,vname);
    }
    //c1->cd(1); h2Dcorrelation->Draw("colz");
    h2Dcorrelation->GetXaxis()->SetLabelSize(0.02);
    h2Dcorrelation->GetYaxis()->SetLabelSize(0.02);
    h2Dcorrelation->SetMaximum(1.0);
    h2Dcorrelation->SetMinimum(-1.0);
    c1->cd(); h2Dcorrelation->Draw("colz");
    // PLotting the nuisance paramaters correlations during the fit
    TString h1name = "h_NuisParaPull_GlobalFit_" + TS_IsConditionnal + "_mu";
    h1name += mu;
    TIterator* it1 = mc->GetNuisanceParameters()->createIterator();
    RooRealVar* var = NULL;
    int Npar=0;
    int NparNotStat=0;
    while( (var = (RooRealVar*) it1->Next()) ) {
      Npar++;
      string varname = (string) var->GetName();      
      if (varname.find("gamma_stat")==string::npos) NparNotStat++;
    }

    TH1F * h1Dpull_axis = new TH1F(h1name,h1name,NparNotStat,0,NparNotStat);
    TGraphAsymmErrors *h1Dpull = new TGraphAsymmErrors(NparNotStat);
    h1Dpull_axis->GetYaxis()->SetRangeUser(-5.5,5.5);
    h1Dpull_axis->GetXaxis()->SetTitle("#theta");
    h1Dpull_axis->GetYaxis()->SetTitle("(#theta_{fit} - #theta_{0}) / #Delta#theta");
    
    
    // Create a latex table of NPs after fit
    TString fname = OutputDir + "/LatexFileNPs/GlobalFit_nuisPar_"+TS_IsConditionnal+"_mu";
    fname += mu;
    fname += ".tex";
    ofstream fnuisPar(fname.Data());
    TString fnuiscorr = OutputDir + "/TextFileFitResult/GlobalFit_fitres_"+TS_IsConditionnal+"_mu";
    fnuiscorr += mu;
    fnuiscorr += ".txt";
    ofstream fnuisParAndCorr(fnuiscorr.Data());
    fnuisParAndCorr << "NUISANCE_PARAMETERS" << endl;

    fnuisPar << endl;
    fnuisPar << "\\begin{tabular}{|l|c|}" << endl;
    fnuisPar << "\\hline" << endl;
    fnuisPar << "Nuisance parameter & postfit value (in $\\sigma$ unit) \\\\\\hline" << endl;

    if(!IsConditionnal){
      fnuisPar.precision(3);
      fnuisPar << "$\\mu$ & $" << firstPOI->getVal() << "^{+" << firstPOI->getErrorHi() << "}_{-" << fabs(firstPOI->getErrorLo()) << "}$ \\\\" << endl;
    }
    
    vector<TGraphAsymmErrors*> vec_MyGraph;
    vec_MyGraph.clear();
    int ib=0;
    TIterator* it2 = mc->GetNuisanceParameters()->createIterator();
    while( (var = (RooRealVar*) it2->Next()) ){
      
      // Not consider nuisance parameter being not associated to syst
      string varname = (string) var->GetName();
      if ((varname.find("gamma_stat")!=string::npos)) continue;
      
      double pull  = var->getVal() / 1.0 ; // GetValue() return value in unit of sigma
      double errorHi = var->getErrorHi() / 1.0; 
      double errorLo = var->getErrorLo() / 1.0; 
      
     if(strcmp(var->GetName(),"Lumi")==0){
	pull  = (var->getVal() - w->var("nominalLumi")->getVal() ) / (w->var("nominalLumi")->getVal() * LumiRelError );
	errorHi = var->getErrorHi() / (w->var("nominalLumi")->getVal() * LumiRelError);
	errorLo = var->getErrorLo() / (w->var("nominalLumi")->getVal() * LumiRelError); 
      }
      
      TString vname=var->GetName();
      vname.ReplaceAll("alpha_","");
      //      vname.ReplaceAll("Lumi","Luminosity");
      vname.ReplaceAll("_","\\_");
      fnuisPar.precision(3);
      fnuisPar << vname << " & $" << pull << "^{+" << fabs(errorHi) << "}_{-" << fabs(errorLo)  << "}$ \\\\" << endl;
      fnuisParAndCorr << vname << " & $" << pull << "^{+ " << fabs(errorHi) << "}_{-" << fabs(errorLo)  << "}$ \\\\" << endl;

      NPContainer MyNPsTemp;
      MyNPsTemp.NPname  = vname;
      MyNPsTemp.NPvalue = pull;
      MyNPsTemp.NPerrorHi = errorHi;
      MyNPsTemp.NPerrorLo = errorLo;
      MyNPsTemp.WhichFit = TS_IsConditionnal+"_FitGlobal_Mu";
      MyNPsTemp.WhichFit += mu;
      AllNPafterEachFit.push_back(MyNPsTemp);

      ib++;
      double xc = h1Dpull_axis->GetBinCenter(ib);
      TString vname2=var->GetName();
      vname2.ReplaceAll("alpha_","");
      vname2.ReplaceAll("gamma_","");
      vname2.ReplaceAll("ATLAS_","");
      h1Dpull_axis->GetXaxis()->SetBinLabel(ib,vname2);
      h1Dpull->SetPoint(ib-1,xc,pull);
      h1Dpull->SetPointEXlow(ib-1,h1Dpull_axis->GetBinWidth(ib)/3.0);
      h1Dpull->SetPointEXhigh(ib-1,h1Dpull_axis->GetBinWidth(ib)/3.0);
      h1Dpull->SetPointEYlow(ib-1,fabs(errorLo));
      h1Dpull->SetPointEYhigh(ib-1,fabs(errorHi));
            
      // Put in red NP with pull>1.5 OR Err<0.2, in black otherwise
      bool IsTooPulled = fabs(pull)>PullMaxAcceptable;
      bool IsOverConst = (fabs(errorLo)+fabs(errorHi))/2.0<ErrorMinAcceptable;
      bool IsOnesided  = UseMinosError && (errorHi==0 || errorLo==0);
      if (IsTooPulled || IsOverConst || IsOnesided){
	TGraphAsymmErrors *myGraph = new TGraphAsymmErrors(1);
	myGraph->SetName("TGraph_"+vname2);
	myGraph->SetLineWidth(2);
	myGraph->SetLineColor(kRed+1);
	myGraph->SetMarkerColor(kRed+1);
	myGraph->SetMarkerStyle(21);
	myGraph->SetMarkerSize(1.2); 
	myGraph->SetPoint(0,xc,pull);
	myGraph->SetPointEXlow(0,h1Dpull_axis->GetBinWidth(ib)/3.0);
	myGraph->SetPointEXhigh(0,h1Dpull_axis->GetBinWidth(ib)/3.0);
	myGraph->SetPointEYlow(0,fabs(errorLo));
	myGraph->SetPointEYhigh(0,fabs(errorHi));
	vec_MyGraph.push_back(myGraph);
      }
    }
    
    fnuisPar << "\\hline" << endl;
    fnuisPar << "\\end{tabular}" << endl;
    fnuisPar.close();
    
    fnuisParAndCorr << endl << endl << "CORRELATION_MATRIX" << endl;
    fnuisParAndCorr << h2Dcorrelation->GetNbinsX() << "   " << h2Dcorrelation->GetNbinsY() << endl;
    for(int kk=1; kk < h2Dcorrelation->GetNbinsX()+1; kk++) {
      for(int ll=1; ll < h2Dcorrelation->GetNbinsY()+1; ll++) {
	fnuisParAndCorr << h2Dcorrelation->GetBinContent(kk,ll) << "   ";
      }
      fnuisParAndCorr << endl;
    }
    fnuisParAndCorr << endl;
    fnuisParAndCorr.close();
    
    double _1SigmaValue[1000];
    double _2SigmaValue[1000];
    double NuisParamValue[1000];
    for (int i=0 ; i<NparNotStat+1 ; i++){
      _1SigmaValue[i] = 1.0;
      _1SigmaValue[2*NparNotStat-i] = -1;
      _2SigmaValue[i] = 2;
      _2SigmaValue[2*NparNotStat-i] = -2;
      NuisParamValue[i] = i;
      NuisParamValue[2*NparNotStat-1-i] = i;
    }
    TGraph *_1sigma = new TGraph(2*NparNotStat,NuisParamValue,_1SigmaValue);
    TGraph *_2sigma = new TGraph(2*NparNotStat,NuisParamValue,_2SigmaValue);
    //c1->cd(2); 
    c_meh->cd();
    h1Dpull->SetLineWidth(2);
    h1Dpull->SetLineColor(1);
    h1Dpull->SetMarkerColor(1);
    h1Dpull->SetMarkerStyle(21);
    h1Dpull->SetMarkerSize(1.2);      
    _2sigma->SetFillColor(5);
    _2sigma->SetLineColor(5);
    _2sigma->SetMarkerColor(5);
    _1sigma->SetFillColor(3);
    _1sigma->SetLineColor(3);
    _1sigma->SetMarkerColor(3);
    h1Dpull_axis->Draw("hist");
    _2sigma->Draw("F"); 
    _1sigma->Draw("F");
    gPad->RedrawAxis("y"); 
    h1Dpull->Draw("P");
    for (unsigned i=0 ; i<vec_MyGraph.size() ; i++) vec_MyGraph[i]->Draw("P");
    h1Dpull_axis->GetYaxis()->DrawClone();
    
    TLatex text;
    text.SetNDC();
    text.SetTextSize( 0.054);
    text.SetTextAlign(31);
    TString WritDownMuValue;
    if(!IsConditionnal) WritDownMuValue = "#mu_{best} = ";
    else                WritDownMuValue = "#mu_{fixed} = ";
    WritDownMuValue += Form("%2.2f",firstPOI->getVal());
    c_meh->cd(); 
    text.DrawLatex( 0.87,0.81, WritDownMuValue );

    MainDir->cd();
    c1->Write();
    c_meh->Write();
    TString fnamei2 = OutputDir + "/corr.png";
    TString fnamei3 = OutputDir + "/pulls.png";
    TString fnamei4 = OutputDir + "/corr.root";
    TString fnamei5 = OutputDir + "/pulls.root";
    c1->Print(fnamei2);
    c_meh->Print(fnamei3);
    c1->Print(fnamei4);
    c_meh->Print(fnamei5);
    gROOT->cd();



    // Plotting the likelihood projection in each NP direction
    TDirectory *NLLprojection = (TDirectory*) MainDir->mkdir("AllNNLProjections");
    gROOT->cd();
    RooAbsReal* nll = simPdf->createNLL(*data);
    if (!IsConditionnal){
      var = (RooRealVar*) firstPOI;
      TString vname=var->GetName();
      vname.ReplaceAll("alpha_","");
      vname.ReplaceAll("gamma_","");
      vname.ReplaceAll("ATLAS_","");
      RooPlot* frame2 = var->frame(Title("-log(L) vs "+vname));
      nll->plotOn(frame2,LineColor(kRed),ShiftToZero()) ;
      frame2->GetYaxis()->SetRangeUser(0.0,5.0);
      frame2->GetYaxis()->SetTitle("#Delta [-2Log(L)]");
      TCanvas *can2 = new TCanvas( "NLLscan_"+vname );
      can2->cd();
      frame2->Draw();
      NLLprojection->cd();
      can2->Write();
      gROOT->cd();
    }
    TIterator* it3 = mc->GetNuisanceParameters()->createIterator();
    while( (var = (RooRealVar*) it3->Next()) ){
      TString vname=var->GetName();
      if (vname.Contains("gamma_stat")) continue;
      vname.ReplaceAll("alpha_","");
      vname.ReplaceAll("gamma_","");
      vname.ReplaceAll("ATLAS_","");
      RooPlot* frame2 = var->frame(Title("-log(L) vs "+vname)) ;
      nll->plotOn(frame2,LineColor(kRed),ShiftToZero()) ;
      frame2->GetYaxis()->SetRangeUser(0.0,5.0);
      frame2->GetYaxis()->SetTitle("#Delta [-2Log(L)]");
      TCanvas *can2 = new TCanvas( "NLLscan_"+vname );
      can2->cd();
      frame2->Draw();
      NLLprojection->cd();
      can2->Write();
      gROOT->cd();
    }


    // Plotting the distributions for each subchannel
    RooCategory* channelCat = (RooCategory*) (&simPdf->indexCat());
    TIterator *iter = channelCat->typeIterator() ;
    RooCatType *tt  = NULL;
    vector<double> Chi2Channel;Chi2Channel.clear();
    vector<TString> NameChannel;NameChannel.clear();
    TString dirName(OutputDir+"/PlotsAfterGlobalFit");
    if(drawPlots) { system(TString("mkdir -vp "+dirName)); }
    while((tt=(RooCatType*) iter->Next()) ){
                
      RooAbsPdf  *pdftmp  = simPdf->getPdf( tt->GetName() );
      RooAbsData *datatmp = data->reduce(Form("%s==%s::%s",channelCat->GetName(),channelCat->GetName(),tt->GetName()));
      RooArgSet  *obstmp  = pdftmp->getObservables( *mc->GetObservables() ) ;
      RooRealVar *obs     = ((RooRealVar*) obstmp->first());

      // Bin Width
      RooRealVar* binWidth = ((RooRealVar*) pdftmp->getVariables()->find(Form("binWidth_obs_x_%s_0",tt->GetName()))) ;
      //check if this might be a combined file...
      if(!binWidth){
	TString bwName = tt->GetName();
	bwName.ReplaceAll("_file","_0_file");
	bwName = "binWidth_obs_x_"+bwName;
	binWidth = ((RooRealVar*) pdftmp->getVariables()->find(bwName));
      }
      if(!binWidth) { cout << "No bin width " << tt->GetName() << endl; }
      cout << "    Bin Width : " << binWidth->getVal() << endl;

      // Load the value from the global fit
      if(!w->loadSnapshot("snapshot_paramsVals_GlobalFit")) { 
        cout << "Cannot load " <<  "snapshot_paramsVals_GlobalFit" << endl;
        exit(-1);
      }
      if   (!IsConditionnal) firstPOI->setVal(muhat);
      else                   firstPOI->setVal(mu);
      
      TString modelName(tt->GetName());
      modelName.Append("_model");

      RooRealSumPdf *pdfmodel = (RooRealSumPdf*) (pdftmp->getComponents())->find(modelName);
      if(!pdfmodel){
	modelName.ReplaceAll("_fileOne_model", "_model_fileOne");
	modelName.ReplaceAll("_fileTwo_model", "_model_fileTwo");
	modelName.ReplaceAll("_fileThree_model", "_model_fileThree");
	modelName.ReplaceAll("_fileFour_model", "_model_fileFour");
	pdfmodel = (RooRealSumPdf*) (pdftmp->getComponents())->find(modelName);
      }
      if(!pdfmodel){ cout << "No pdfmodel: " << modelName << endl; return;}
      RooArgList funcList =  pdfmodel->funcList();
      RooProduct* comp = 0;
      RooLinkedListIter funcIter = funcList.iterator() ;
      cout << "Post Fit " << endl;
      while( (comp = (RooProduct*) funcIter.Next()) ) {
        cout << "\t" << comp->GetName() << "\t" << (comp->createIntegral(*obs))->getVal() * binWidth->getVal() << endl;
      }

      cname = "can_DistriAfterFit_"+ (TString) tt->GetName() +"_GlobalFit_" + TS_IsConditionnal + "_mu";
      cname += mu;
      TCanvas* c2 = new TCanvas( cname );
      RooPlot* frame = obs->frame();
      TString FrameName = "Plot_DistriGlobal_" + (TString) IsConditionnal;
      frame->SetName( FrameName );
      frame->SetYTitle("EVENTS");

      float postFitIntegral = pdftmp->expectedEvents(*obs);
      datatmp->plotOn(frame,MarkerSize(1),Name("Data"),DataError(RooAbsData::Poisson));
      pdftmp->plotOn(frame,FillColor(kOrange),LineWidth(2),LineColor(kBlue),VisualizeError(*fitresGlobal,1),
		     Normalization(postFitIntegral,RooAbsReal::NumEvent),Name("FitError_NotAppears"));
      pdftmp->plotOn(frame,LineWidth(2),Normalization(postFitIntegral,RooAbsReal::NumEvent),Name("CentralFit_NotAppears"));
      double chi2 = frame->chiSquare();
      if(std::isnan(chi2)) chi2 = -1;
      Chi2Channel.push_back( chi2 );
      NameChannel.push_back( (TString)tt->GetName() );


      // miniloop over componant to make a bkg stack
      TString modelName1(tt->GetName());
      modelName1.Append("_model");

      RooRealSumPdf *pdfmodel1 = (RooRealSumPdf*) (pdftmp->getComponents())->find(modelName1);
      if(!pdfmodel1){
	modelName1.ReplaceAll("_fileOne_model", "_model_fileOne");
	modelName1.ReplaceAll("_fileTwo_model", "_model_fileTwo");
	modelName1.ReplaceAll("_fileThree_model", "_model_fileThree");
	modelName1.ReplaceAll("_fileFour_model", "_model_fileFour");
	pdfmodel1 = (RooRealSumPdf*) (pdftmp->getComponents())->find(modelName1);
      }
      if(!pdfmodel1){ cout << "No pdfmodel: " << modelName1 << endl; return;}
      RooArgList funcList1 =  pdfmodel1->funcList();
      RooLinkedListIter funcIter1 = funcList1.iterator() ;
      RooProduct* comp1 = 0;
      if (!IsConditionnal) firstPOI->setVal(muhat);
      else                 firstPOI->setVal(mu);
      int ibkg=0;
      int icolor=0;
      TString previous="";
      while( (comp1 = (RooProduct*) funcIter1.Next()) ) {
	ibkg++;

	int color=kGray;
	
	TString compname(comp1->GetName());
	compname.ReplaceAll("L_x_","");
        compname.ReplaceAll(tt->GetName(),"");
        compname.ReplaceAll("_overallSyst_x_StatUncert","");
        compname.ReplaceAll("_overallSyst_x_HistSyst","");
        compname.ReplaceAll("_overallSyst_x_Exp","");
	compname.ReplaceAll("_","");
	
	icolor++;
	if(icolor==1) { color = kOrange - 3; }
	else if(icolor==2) { color = kCyan + 1; }
	else if(icolor==3) { color = kGreen - 9; }
	else if(icolor==4) { color = kAzure - 9; }
	else if(icolor==5) { color = kOrange + 10;}
	else if(icolor==6) { color = kGreen - 6; }
	else if(icolor==7) { color = kAzure - 4; }
	else if(icolor==8) { color = kOrange + 6; }
	else if(icolor==9) { color = kGreen + 1; }
	else if(icolor==10) { color = kAzure + 2; }
	else if(icolor==11) { color = kOrange; }
	else if(icolor==12) { color = kGreen + 3; }
	else if(icolor==13) { color = kAzure - 4; }
	else if(icolor==14) { color = kOrange; }
	else if(icolor==15) { color = kGreen + 1; }
	else if(icolor==16) { color = kOrange - 7; }
	else if(icolor==17) { color = kPink + 1; }
	else   color=icolor;
	
	// Get the signal x 1 in white (for further purposes)
	if (IsConditionnal) firstPOI->setVal(1.0);
	double Ntemp=(comp1->createIntegral(*obs))->getVal() * binWidth->getVal();
	pdfmodel1->plotOn(frame,LineWidth(0),Components(*comp1),LineColor(0), LineStyle(3), Normalization(Ntemp,RooAbsReal::NumEvent),Name("NoStacked_"+compname));
	if (IsConditionnal) firstPOI->setVal(mu);
	
	// Stack bkg
	Ntemp=(comp1->createIntegral(*obs))->getVal() * binWidth->getVal();
	if (ibkg==0) pdfmodel1->plotOn(frame, FillColor(color), FillStyle(1001), LineWidth(2),Components(*comp1), LineColor(color), Normalization(Ntemp,RooAbsReal::NumEvent),Name("Stacked_"+compname));
	else         pdfmodel1->plotOn(frame, FillColor(color), FillStyle(1001), LineWidth(2),Components(*comp1), LineColor(color), Normalization(Ntemp,RooAbsReal::NumEvent),Name("Stacked_"+compname),AddTo(previous));
	previous="Stacked_"+compname;
      }

      if (!IsConditionnal) firstPOI->setVal(muhat);
      else                 firstPOI->setVal(mu);
      pdftmp->plotOn(frame,FillColor(kOrange),LineWidth(2),LineColor(kBlue),VisualizeError(*fitresGlobal,1),
		     Normalization(postFitIntegral,RooAbsReal::NumEvent),Name("FitError_AfterFit"));
      pdftmp->plotOn(frame,LineWidth(2),Normalization(postFitIntegral,RooAbsReal::NumEvent),Name("FitCentral2_NotAppears"));
      datatmp->plotOn(frame,MarkerSize(1),Name("Dat_NotAppears"),DataError(RooAbsData::Poisson));
      	
      // Putting nuisance parameter at the central value and draw the nominal distri
      SetAllStatErrorToSigma(0.0);
      SetAllNuisanceParaToSigma(0.0);
      if (!IsConditionnal) SetPOI(0.0);
      else                 SetPOI(mu);
      TString muValueBeforeFitLegend = Form("Before fit (#mu=%2.2f)",firstPOI->getVal());
      funcIter = funcList.iterator() ;
      cout << "Pre Fit " << endl;
      while( (comp = (RooProduct*) funcIter.Next()) ) {
        cout << "\t" << comp->GetName() << "\t" << (comp->createIntegral(*obs))->getVal() * binWidth->getVal() << endl;
      }
      float preFitIntegral = pdftmp->expectedEvents(*obs);
      pdftmp->plotOn(frame,LineWidth(2),Name("BeforeFit"),LineStyle(kDashed),Normalization(preFitIntegral,RooAbsReal::NumEvent));      
      c2->cd();
      frame->Draw();
      c2->cd(); 
      
      TString modelName2(tt->GetName());
      modelName2.Append("_model");

      RooRealSumPdf *pdfmodel2 = (RooRealSumPdf*) (pdftmp->getComponents())->find(modelName2);
      if(!pdfmodel2){
	modelName2.ReplaceAll("_fileOne_model", "_model_fileOne");
	modelName2.ReplaceAll("_fileTwo_model", "_model_fileTwo");
	modelName2.ReplaceAll("_fileThree_model", "_model_fileThree");
	modelName2.ReplaceAll("_fileFour_model", "_model_fileFour");
	pdfmodel2 = (RooRealSumPdf*) (pdftmp->getComponents())->find(modelName2);
      }
      if(!pdfmodel2){ cout << "No pdfmodel: " << modelName2 << endl; return;}
      RooArgList funcList2 =  pdfmodel2->funcList();
      RooLinkedListIter funcIter2 = funcList2.iterator() ;
      RooProduct* comp2 = 0;
      if (!IsConditionnal) firstPOI->setVal(muhat);
      else                 firstPOI->setVal(mu);
      ibkg=0;
      icolor=0;
      while( (comp2 = (RooProduct*) funcIter2.Next()) ) {
	ibkg++;
	int color=kGray;
	TString compname(comp2->GetName());
	compname.ReplaceAll("L_x_","");
        compname.ReplaceAll(tt->GetName(),"");
        compname.ReplaceAll("_overallSyst_x_StatUncert","");
        compname.ReplaceAll("_overallSyst_x_HistSyst","");
        compname.ReplaceAll("_overallSyst_x_Exp","");
	compname.ReplaceAll("_","");
	if (IsConditionnal) firstPOI->setVal(1.0);
	
	icolor++;
	if(icolor==1) { color = kOrange - 3; }
	else if(icolor==2) { color = kCyan + 1; }
	else if(icolor==3) { color = kGreen - 9; }
	else if(icolor==4) { color = kAzure - 9; }
	else if(icolor==5) { color = kOrange + 10;}
	else if(icolor==6) { color = kGreen - 6; }
	else if(icolor==7) { color = kAzure - 4; }
	else if(icolor==8) { color = kOrange + 6; }
	else if(icolor==9) { color = kGreen + 1; }
	else if(icolor==10) { color = kAzure + 2; }
	else if(icolor==11) { color = kOrange; }
	else if(icolor==12) { color = kGreen + 3; }
	else if(icolor==13) { color = kAzure - 4; }
	else if(icolor==14) { color = kOrange; }
	else if(icolor==15) { color = kGreen + 1; }
	else if(icolor==16) { color = kOrange - 7; }
	else if(icolor==17) { color = kPink + 1; }
	else   color=icolor;
	double Ntemp=(comp2->createIntegral(*obs))->getVal() * binWidth->getVal();
	pdfmodel2->plotOn(frame,LineWidth(0),Components(*comp2),LineColor(0), LineStyle(3), Normalization(Ntemp,RooAbsReal::NumEvent),Name("NoStacked_BkgBeforeFit_"+compname));

      }
      if (!IsConditionnal) firstPOI->setVal(muhat);
      else                 firstPOI->setVal(mu);

      c2->cd();
      frame->Draw();
      text.DrawLatex( 0.73,0.81, WritDownMuValue );
      TString ts_chi2 = Form("#chi^{2}=%1.1f", chi2 );
      text.DrawLatex( 0.22, 0.83, ts_chi2 );

      TLegend *leg = new TLegend(0.54,0.40,0.77,0.76);
      leg->SetBorderSize(0);
      leg->SetFillColor(0);
      leg->SetTextFont(62);
      leg->SetTextSize(0.050);
      for (int i=0; i<frame->numItems(); i++) {
        TString obj_name=frame->nameOf(i); 
        if (obj_name=="" || obj_name.Contains("NotAppears") || obj_name.Contains("NoStacked") ) continue;
        TObject *obj = frame->findObject(obj_name.Data());
        if (((string)obj_name).find("Data")   !=string::npos) { leg->AddEntry( obj , "Data" , "p"); continue; }
	TString legname;
	if (!IsConditionnal) legname = "After fit (#mu[best] S+B)";
	else                 legname = "After fit (#mu[fixed] S+B)";
        if (((string)obj_name).find("AfterFit")!=string::npos){ leg->AddEntry( obj , legname , "lf"); continue; }
	legname = muValueBeforeFitLegend;
	if (((string)obj_name).find("BeforeFit")!=string::npos){leg->AddEntry( obj ,legname , "l"); continue;}
	
	obj_name.ReplaceAll("Stacked_","");
	leg->AddEntry(obj,obj_name,"l");
      }	
  
      leg->Draw();


      // Save the plots
      MainDir->cd();
      c2->Write();
      if(drawPlots) { 
        c2->Print(dirName+"/"+c2->GetName()+".eps");
        c2->Print(dirName+"/"+c2->GetName()+".png");
      }
      c2->Close();
      gROOT->cd();


      cout << "Number of items in frame " << frame->numItems() << endl;
      frame->Clear();
      cout << "Number of items in frame " << frame->numItems() << endl;
      delete frame;
      frame = 0;


      continue;

      // plot each component
      TString chanName(tt->GetName());
      funcIter = funcList.iterator() ;
      while( (comp = (RooProduct*) funcIter.Next()) ) {

        // Load the value from the global fit
        if(!w->loadSnapshot("snapshot_paramsVals_GlobalFit")) { 
          cout << "Cannot load " <<  "snapshot_paramsVals_GlobalFit" << endl;
          exit(-1);
        }

        cname = "can_DistriAfterFit_"+ (TString) tt->GetName() +"_GlobalFit_" + TS_IsConditionnal + "_mu";
        cname += mu;
        TString compName(comp->GetName());
        compName.ReplaceAll("L_x_","");
        compName.ReplaceAll(chanName,"");
        compName.ReplaceAll("__overallSyst_x_StatUncert","");
        compName.ReplaceAll("__overallSyst_x_HistSyst","");
        compName.ReplaceAll("__overallSyst_x_Exp","");
        cname.Append("_"+compName);

        TCanvas* c3 = new TCanvas( cname );
        RooPlot* compFrame = obs->frame();
        cout << "COMP FRAMCE " << compFrame->numItems() << endl;
        FrameName = "Plot_" + compName + "_Global_" + (TString) IsConditionnal;
        compFrame->SetName( FrameName );
        compFrame->SetYTitle("EVENTS");
        postFitIntegral = ( (comp->createIntegral(*obs))->getVal() * binWidth->getVal() );
        comp->plotOn(compFrame,FillColor(kOrange),LineWidth(2),LineColor(kBlue),VisualizeError(*fitresGlobal,1),
            Normalization(postFitIntegral),Name("AfterFit"));
        comp->plotOn(compFrame,LineWidth(2),Normalization(postFitIntegral));
        c3->cd();
        compFrame->Draw();

        // Putting nuisance parameter at the central value and draw the nominal distribution
        if(!w->loadSnapshot("snapshot_paramsVals_initial")) { 
          cout << "Cannot load " <<  "snapshot_paramsVals_initial" << endl;
          exit(-1);
        }
        preFitIntegral = ( (comp->createIntegral(*obs))->getVal() * binWidth->getVal() );
        comp->plotOn(compFrame,LineWidth(2),Name("BeforeFit"),LineStyle(kDashed),Normalization(preFitIntegral));      
        //comp->plotOn(compFrame,LineWidth(2),Name("BeforeFit"),LineStyle(kDashed),Normalization(preFitIntegral,RooAbsReal::NumEvent));      
        cout << tt->GetName() << "\t" << compName << "\t" << preFitIntegral << " " << postFitIntegral <<  endl;
        c3->cd();
        compFrame->Draw();
        c3->cd(); 
        TString normChange = Form("Norm %5.2f -> %5.2f = %5.2f",preFitIntegral, postFitIntegral, postFitIntegral/preFitIntegral);
        text.DrawLatex( 0.84,0.83, normChange);

        leg->Clear();
        leg->SetBorderSize(0);
        leg->SetFillColor(0);
        leg->SetTextFont(62);
        leg->SetTextSize(0.050);
        for (int i=0; i<compFrame->numItems(); i++) {
          TString obj_name=compFrame->nameOf(i); 
          if (obj_name=="") continue;
          TObject *obj = compFrame->findObject(obj_name.Data());
          if (((string)obj_name).find("Data")   !=string::npos) leg->AddEntry( obj , "Data" , "p");
          if (((string)obj_name).find("AfterFit")!=string::npos) leg->AddEntry( obj , "After fit" , "lf");
          TString legname = Form("Before fit (#mu=%2.2f)",firstPOI->getVal());
          if (((string)obj_name).find("BeforeFit")!=string::npos) leg->AddEntry( obj ,legname , "l");
        }	  
        leg->Draw();


        // Save the plots
        MainDir->cd();
        c3->Write();
        if(drawPlots) { 
          c3->Print(dirName+"/"+c3->GetName()+".eps");
          c3->Print(dirName+"/"+c3->GetName()+".png");
        }
        c3->Close();
        gROOT->cd();
        delete compFrame;
        compFrame = 0;
        

      } // loop over components

    } // loop over channels
    // make a webpage
    if(drawPlots) {
      system("./createHTMLpageAllPlots.sh "+dirName+" &");
    }

    int Nchannel = NameChannel.size();
    TH1F *hChi2 = new TH1F("Chi2PerChannel","Chi2PerChannel",Nchannel,0,Nchannel);
    for (int jb=0 ; jb<Nchannel ; jb++){
      hChi2->SetBinContent(jb+1,Chi2Channel[jb]);
      hChi2->GetXaxis()->SetBinLabel(jb+1,NameChannel[jb]);
    }
    sort( Chi2Channel.begin(), Chi2Channel.end());
    hChi2->GetYaxis()->SetRangeUser(0.0,Chi2Channel[Chi2Channel.size()-1]*1.50);
    hChi2->SetYTitle("#chi^{2}");
    hChi2->SetTitle("#chi^{2} overview among channels");
    hChi2->SetLineColor(1);
    hChi2->SetMarkerColor(1);
    hChi2->SetLineWidth(2);


    MainDir->cd();
    hChi2->Write();
    gROOT->cd();

    return;
  }



  void PlotsNuisanceParametersVSmu(){
    cout << endl;
    cout << endl;
    cout << "Performing a global fit for mu : can take time ..." << endl;
    cout << endl;

    ProfileInspector p;
    TList* list = p.GetListOfProfilePlots(*data,mc);

    for(int i=0; i<list->GetSize(); ++i){

      TString cname = "ProfileInspector_" + (TString) list->At(i)->GetName();
      TCanvas* c1 = new TCanvas(cname);
      c1->cd();
      list->At(i)->Draw("al");

      MainDirModelInspector->cd();
      c1->Write();
      c1->Close();
      gROOT->cd();
    }
    return;
  }


  void PlotsStatisticalTest(double mu_pe, double mu_hyp){

    int nToyMC = 5;
    // set roofit seed
    RooRandom::randomGenerator()->SetSeed();

    cout << endl;
    cout << endl;
    cout << "Will generate " << nToyMC << " pseudo-experiments for : " << endl;
    cout << " - mu[pseudo-data] = " << mu_pe  << endl;
    cout << " - mu[stat-test]   = " << mu_hyp << endl;
    cout << endl;

    // Check number of POI (for Wald approx)
    RooArgSet *ParamOfInterest = (RooArgSet*) mc->GetParametersOfInterest();
    int nPOI = ParamOfInterest->getSize();
    if(nPOI>1){
      cout <<"not sure what to do with other parameters of interest, but here are their values"<<endl;
      mc->GetParametersOfInterest()->Print("v");
    }
    RooRealVar* firstPOI    = (RooRealVar*) ParamOfInterest->first(); 
    RooSimultaneous *simPdf = (RooSimultaneous*)(mc->GetPdf());
    //PrintAllParametersAndValues( *mc->GetGlobalObservables() );
    //PrintAllParametersAndValues( *mc->GetObservables() );
    firstPOI->setVal(0.0); // FIXME

    //simPdf->fitTo( *data, Hesse(kTRUE), Minos(kTRUE), PrintLevel(1) );
    simPdf->fitTo( *data );

    // set up the sampler
    ToyMCSampler sampler;
    sampler.SetPdf(*mc->GetPdf());
    sampler.SetObservables(*mc->GetObservables());
    sampler.SetNToys(nToyMC);
    sampler.SetGlobalObservables(*mc->GetGlobalObservables());
    sampler.SetParametersForTestStat(*mc->GetParametersOfInterest());
    RooArgSet* poiset = dynamic_cast<RooArgSet*>(w->set("ModelConfig_POI")->Clone());

    /*
    // set up the test statistic
    ProfileLikelihoodTestStat *profll = new ProfileLikelihoodTestStat(*mc->GetPdf());
    // enable detailed output on the set statistic
    profll->EnableDetailedOutput(true);
    // add the test statistic to the sampler for evaluation
    sampler.AddTestStatistic(profll);
    */

    // only unconditional fit
    MinNLLTestStat *minNll = new MinNLLTestStat(*mc->GetPdf());
    minNll->EnableDetailedOutput(true);
    sampler.AddTestStatistic(minNll);

    // enable PROOF if desired
    //ProofConfig pc(*w, 8, "workers=8", kFALSE);
    //sampler.SetProofConfig(&pc);

    // evaluate the test statistics - this is where most of our time will be spent
    cout << "Generating " << nToyMC << " toys...this will take a few minutes" << endl;
    TStopwatch *mn_t = new TStopwatch; 
    mn_t->Start();
    RooDataSet* sd = sampler.GetSamplingDistributions(*poiset);
    cout << "Toy generation complete :" << endl;
    // stop timing
    mn_t->Stop();
    cout << " total CPU time: " << mn_t->CpuTime() << endl;
    cout << " total real time: " << mn_t->RealTime() << endl; 

    // now sd contains all information about our test statistics, including detailed output
    // we might eg. want to explore the results either directly, or first converting to a TTree
    // do the conversion
    TFile f("mytoys.root", "RECREATE");
    TTree *toyTree = RooStats::GetAsTTree("toyTree", "TTree created from test statistics", *sd);
    // save result to file, but in general do whatever you like
    f.cd();
    toyTree->Write();
    f.Close();

    TFile* tmpFile = new TFile("mytoys.root","READ");
    TTree* myTree = (TTree*)tmpFile->Get("toyTree");

    // get boundaries for histograms
    TIter nextLeaf( (myTree->GetListOfLeaves())->MakeIterator() );
    TObject* leafObj(0);
    map<TString, float> xMaxs;
    map<TString, float> xMins;
    for(int i(0); i<myTree->GetEntries(); i++) {
      myTree->GetEntry(i);
      nextLeaf = ( (myTree->GetListOfLeaves())->MakeIterator() );
      while( (leafObj = nextLeaf.Next()) ) {
        TString name(leafObj->GetName());
        float value(myTree->GetLeaf( leafObj->GetName() )->GetValue());
        if(value > xMaxs[name]) { xMaxs[name] = value; }
        if(value < xMins[name]) { xMins[name] = value; }
      } // loop over leaves
    } // loop over tree entries

    // plot everything in the tree
    myTree->GetEntry(0);
    nextLeaf = ( (myTree->GetListOfLeaves())->MakeIterator() );
    leafObj = 0;
    // make a histogram per leaf
    map<TString, TH1F*> hists;
    myTree->GetEntry(0);
    while( (leafObj = nextLeaf.Next()) ) {
      if(!leafObj) { continue; }
      //cout << leafObj->GetName() << endl;
      TString name(leafObj->GetName());
      // special ones : fit related things
      if(name.Contains("covQual"))   { hists[name] = new TH1F(name,name,5,0,5); continue; }
      if(name.Contains("fitStatus")) { hists[name] = new TH1F(name,name,5,0,5); continue; }
      int nbin(500); 
      float histMin( xMins[name] - 0.1*fabs(xMins[name]) ); 
      float histMax( xMaxs[name] + 0.1*fabs(xMaxs[name]) );
      if(name.Contains("ATLAS_norm")) { // floating normalization factors
        histMin = 0; histMax = 10;
      }
      else if(name.Contains("gamma_stat")) { // statistical nus param
        if(name.Contains("globObs")) {  // get custom range for sampling
          histMin = int( xMins[name] - 0.1*fabs(xMins[name]) );
          histMax = int( xMaxs[name] + 0.1*fabs(xMaxs[name]) );
        } // use small range for pull and error
        else { nbin = 100; histMin = 0.0; histMax = 2.0; }
      }
      else if(name.Contains("_err")) { // errors on nus param
        nbin = 100; histMin = 0.0; histMax = 2.0;
      }
      else if(name.Contains("fitCond") || name.Contains("fitUncond") || name.Contains("globObs")) { // fit pulls
        nbin = 500; histMin = -5; histMax = 5;
      }
      hists[name] = new TH1F(name,name,nbin,histMin,histMax);
    } // loop over leaves to declare histos

    // loop over entries and fill histograms
    for(int i(0); i<myTree->GetEntries(); i++) {
      myTree->GetEntry(i);
      nextLeaf = ( (myTree->GetListOfLeaves())->MakeIterator() );
      while( (leafObj = nextLeaf.Next()) ) {
        TString name(leafObj->GetName());
        if(hists.find(name) == hists.end()) { continue; }
        hists[name]->Fill( myTree->GetLeaf( leafObj->GetName() )->GetValue() );
      } // loop over leaves
    } // loop over tree entries

    // overflow and underflow
    for(map<TString,TH1F*>::iterator ihist(hists.begin()); ihist!=hists.end(); ihist++) {
      if(ihist->second->GetBinContent(0)>0) {
        ihist->second->SetBinContent(1, ihist->second->GetBinContent(0) + ihist->second->GetBinContent(1) );
        // fix err
      }
      int nBinx = ihist->second->GetNbinsX();
      if(ihist->second->GetBinContent(nBinx)>0) {
        ihist->second->SetBinContent(nBinx-1, ihist->second->GetBinContent(nBinx) + ihist->second->GetBinContent(nBinx-1) );
        // fix err
      }
    }

    // save the results
    TString dirName(OutputDir+"/PlotsStatisticalTest/GlobalFit");
    if(drawPlots) {
      system(TString("mkdir -vp "+dirName));
    }
    TCanvas* canvas = new TCanvas("pulls");
    TLegend *leg = new TLegend(0.67, 0.64, 0.87, 0.86);
    LegendStyle(leg);
    for(map<TString,TH1F*>::iterator ihist(hists.begin()); ihist!=hists.end(); ihist++) {
      if( (ihist->first).Contains("fitCond_") ) { continue; } // skip unconditional fit - get it explicitly
      canvas->Clear();
      leg->Clear();
      TString niceName(ihist->first);
      niceName.ReplaceAll("fitUncond_","");
      //niceName.ReplaceAll("SD_TS0_",""); // not good if have multiple test statistics
      // conditional fit information
      ihist->second->SetLineColor(kGray+2);
      ihist->second->SetTitle(niceName);
      ihist->second->SetLineStyle(kSolid);
      ihist->second->SetLineWidth(2);
      if((ihist->first).Contains("fit") && !(ihist->first).Contains("_err") 
          && !(ihist->first).Contains("Qual") && !(ihist->first).Contains("Status")) {
        ihist->second->Rebin(4);
      }

//      ihist->second->GetXaxis()->SetTitle("");
//      ihist->second->GetYaxis()->SetTitle("");

      if(niceName.Contains("globObs")) {
        leg->AddEntry( ihist->second, "Sampling", "l" ); // add value of mu
      } else {
        leg->AddEntry( ihist->second, "Unconditional Fit", "l" ); // add value of mu
      }
      TString condName(ihist->first);
      condName.ReplaceAll("fitUncond","fitCond");
      // uncomditional fit information
      if(hists.find(condName) != hists.end() && condName != ihist->first) {
        hists[condName]->SetLineColor(kGray+2);
        hists[condName]->SetLineStyle(kDashed);
        hists[condName]->SetLineWidth(2);
        if(!(ihist->first).Contains("_err")) { hists[condName]->Rebin(4); }
        leg->AddEntry( hists[condName], "Conditional Fit", "l" );
        if( hists[condName]->GetMaximum() > ihist->second->GetMaximum() ) {
          ihist->second->SetMaximum( hists[condName]->GetMaximum() );
        }
      }
      ihist->second->SetMaximum( 1.2 * ihist->second->GetMaximum() );
      canvas->cd();
      ihist->second->Draw();
      leg->Draw();
      if(hists[condName] && condName != ihist->first) { hists[condName]->Draw("same"); }
      if(drawPlots) { 
        canvas->Print(dirName+"/"+niceName+".eps");
        canvas->Print(dirName+"/"+niceName+".png");
      }

      MainDirStatTest->cd();
      canvas->Write();
      gROOT->cd();
    }

    // make a webpage
    if(drawPlots) {
      system("./createHTMLpageAllPlots.sh "+dirName+" &");
    }

    // save result to file, but in general do whatever you like
//    f.cd();
//    toyTree->Write();
//    f.Close();
    return;


    /*
    // Test statistic : ProfiledLikelihood
    RooSimultaneous *simPdf = (RooSimultaneous*)(mc->GetPdf());
    ProfileLikelihoodTestStat ts(*simPdf);

    // To generate toy MC
    ToyMCSampler sampler;
    sampler.SetPdf(*mc->GetPdf());
    sampler.SetObservables(*mc->GetObservables());
    sampler.SetGlobalObservables(*mc->GetGlobalObservables());
    sampler.SetParametersForTestStat(*mc->GetParametersOfInterest());
    //ProofConfig pc(*w, 4, "workers=4",false);
    //sampler.SetProofConfig(&pc); 

    // Load all the model paramters
    RooArgSet allParameters;
    allParameters.add(*mc->GetParametersOfInterest());
    allParameters.add(*mc->GetNuisanceParameters());

    // Observed value
    firstPOI->setVal(mu_hyp);
    double ObsPLHR = ts.Evaluate( *data , *ParamOfInterest );
    data->Print();
    TCanvas *cobs = PlotData(data,simPdf);
    TString cobsname  = (TString) cobs->GetName() + (TString) "_RealData";
    cobs->SetName(cobsname);
    MainDirStatTest->cd();
    cobs->Write();
    gROOT->cd();

    // Make pseudo experiment and plot the TestStat distribution
    TString hname = Form("Distribution of q_{#mu=%1.1f} under pseudodata with #mu=%1.1f",mu_hyp,mu_pe);
    TH1F *hStatTest = new TH1F(hname,hname,100,0,10);
    double Npe_disagreed = 0;
    for (int ipe=0 ; ipe<nToyMC ; ipe++){
      firstPOI->setVal(mu_pe);
      RooAbsData *SampledDataSet = sampler.GenerateToyData(allParameters);
      firstPOI->setVal(mu_hyp);
      double StatTest = ts.Evaluate( *SampledDataSet , *ParamOfInterest );      
      hStatTest->Fill( StatTest );
      if (ipe%10==0){
        cout << "pseudo-exp " << ipe << ", StatTest = " << StatTest << endl;
        TCanvas *ctemp = PlotData(SampledDataSet,simPdf);
        TString ctempname = (TString) ctemp->GetName() + (TString) "_PseudoExp";
        ctempname += ipe;
        ctemp->SetName(ctempname);
        MainDirStatTest->cd();
        ctemp->Write();
        gROOT->cd();
      }

      if (StatTest>ObsPLHR) Npe_disagreed++;

    }
    hStatTest->Scale( 1./hStatTest->Integral(0,hStatTest->GetNbinsX()+1),"width" );
    hStatTest->GetYaxis()->SetTitle( Form("f(-log #lambda(#mu=%.2f) | #mu=%.2f)",mu_hyp,mu_pe) );
    hStatTest->GetXaxis()->SetTitle(Form("-log #lambda(#mu=%.2f)",mu_hyp) );

    // Plotting approximate distribution
    TString cname = "can_StatTestDistribution_ToyMC_mu"; cname += mu_pe;
    TCanvas* c1 = new TCanvas( cname );
    c1->SetLogy();
    hStatTest->Draw("hist");
    double min = 0;
    double max = 10;
    TF1* f = new TF1("f","1./pow(x,0.5) * 1./pow(2*3.14,0.5) * exp(-x/2) ",min,max);
    f->Draw("same");

    // Plotting the observed value of the stat test
    double  x[2] = {ObsPLHR,ObsPLHR};
    double  y[2] = {0.0001,2.0};
    TGraph *gobs = new TGraph(2,x,y);
    gobs->SetLineStyle(2);
    gobs->SetLineWidth(2);
    gobs->SetLineColor(1);
    c1->cd();
    gobs->Draw("CP");

    TLatex text;
    text.SetNDC();
    text.SetTextSize( 0.054);
    text.SetTextAlign(31);
    TString WritDownPvalue = Form("p_{#mu} = #int^{#infty}_{q^{obs}_{%1.1f}} f(q_{%1.1f}|%1.1f)dq_{%1.1f} = ",mu_hyp,mu_hyp,mu_pe,mu_hyp);
    WritDownPvalue += Form("%1.3f",(double)Npe_disagreed/nToyMC);
    c1->cd(); 
    text.DrawLatex( 0.88,0.77, WritDownPvalue );


    MainDirStatTest->cd();
    c1->Write();
    gROOT->cd();
    */

    return;
  }



  void PrintSuspiciousNPs(){

    cout.precision(3);

    cout << endl;
    cout << endl;
    cout << endl;
    cout << "==================================================================" << endl;
    cout << "     List of nuisance parameters which deserve more attention     " << endl;
    cout << "===================================================================" << endl;
    cout << endl;
    cout << endl;
    cout << " === Tension between the NP central value and CP measurement ===" << endl;
    cout << " ===============================================================" << endl;
    cout << endl;
    for (unsigned i=0 ; i<AllNPafterEachFit.size() ; i++){
      NPContainer MyNPsTemp = AllNPafterEachFit[i];
      TString name = MyNPsTemp.NPname;
      double value = MyNPsTemp.NPvalue;
      double errHi = MyNPsTemp.NPerrorHi;
      double errLo = MyNPsTemp.NPerrorLo;
      TString Fit  = MyNPsTemp.WhichFit;
      
      name.ReplaceAll("\\","");

      if (fabs(value)>PullMaxAcceptable){
	cout << name << "\t : \t" << value << " \t +" << errHi << "\t -" << fabs(errLo) << "  \t Fit : " << Fit << endl;
      }
      
    }
    cout << endl;
    cout << endl;
    cout << " === Overconstraint of profiled NP wrt CP measurement ===" << endl;
    cout << " ========================================================" << endl;
    cout << endl;
    for (unsigned i=0 ; i<AllNPafterEachFit.size() ; i++){
      NPContainer MyNPsTemp = AllNPafterEachFit[i];
      TString name = MyNPsTemp.NPname;
      double value = MyNPsTemp.NPvalue;
      double errHi = MyNPsTemp.NPerrorHi;
      double errLo = MyNPsTemp.NPerrorLo;
      TString Fit  = MyNPsTemp.WhichFit;
      
      name.ReplaceAll("\\","");
      if ( (fabs(errHi)+fabs(errLo))/2.0<ErrorMinAcceptable ){
	cout << name << "\t : \t" << value << " \t +" << errHi << "\t -" << fabs(errLo) << "  \t Fit : " << Fit << endl;
      }
    }

    if (UseMinosError){
      cout << endl;
      cout << endl;
      cout << " === Nuisance parameters with one sided Minos error ===" << endl;
      cout << " ======================================================" << endl;
      cout << endl;
      for (unsigned i=0 ; i<AllNPafterEachFit.size() ; i++){
	NPContainer MyNPsTemp = AllNPafterEachFit[i];
	TString name = MyNPsTemp.NPname;
	double value = MyNPsTemp.NPvalue;
	double errHi = MyNPsTemp.NPerrorHi;
	double errLo = MyNPsTemp.NPerrorLo;
	TString Fit  = MyNPsTemp.WhichFit;
	
	name.ReplaceAll("\\","");
	if ( errHi==0 || errLo==0 ){
	  cout << name << "\t : \t" << value << " \t +" << errHi << "\t -" << fabs(errLo) << "  \t Fit : " << Fit << endl;
	}
      }
    }

    cout << endl;
    cout << endl;
    cout << "===================================================================" << endl;
    cout << endl;
    cout << endl;
    cout << endl;

    return;
  }



  double FindMuUpperLimit(){

    //RooMsgService::instance().setGlobalKillBelow(ERROR);

    RooRealVar* firstPOI = (RooRealVar*) mc->GetParametersOfInterest()->first();
    ProfileLikelihoodCalculator plc(*data,*mc);
    LikelihoodInterval* interval = plc.GetInterval();    
    double UpperLimit = interval->UpperLimit(*firstPOI);

    TCanvas* c2 = new TCanvas( "Likelihood_vs_mu" );
    LikelihoodIntervalPlot plot(interval);
    plot.SetNPoints(50);
    c2->cd();
    plot.Draw("");
    delete interval;
    
    SetAllStatErrorToSigma(0.0);
    SetAllNuisanceParaToSigma(0.0);

    outputfile->cd();
    c2->Write();
    gROOT->cd();

    return UpperLimit;

  }


    void GetNominalValueNuisancePara(){
    TIterator *it = mc->GetNuisanceParameters()->createIterator();
    RooRealVar *var = NULL;
    if (MapNuisanceParamNom.size() > 0) MapNuisanceParamNom.clear();
    std::cout << "Nuisance parameter names and values" << std::endl;
    while ((var = (RooRealVar*)it->Next()) != NULL){
      const double val = var->getVal();
      MapNuisanceParamNom[(string)var->GetName()] = val;
    }
    return;
  }
  

  void SetNominalValueNuisancePara(){
    TIterator *it = mc->GetNuisanceParameters()->createIterator();
    RooRealVar *var = NULL;
    while ((var = (RooRealVar*)it->Next()) != NULL){
      const double val =  MapNuisanceParamNom[(string)var->GetName()];
      var->setVal(val);
    }
    return;
  }
  
  
  void SetAllStatErrorToSigma(double Nsigma){
    
    TIterator* it = mc->GetNuisanceParameters()->createIterator();
    RooRealVar* var = NULL;
    while( (var = (RooRealVar*) it->Next()) ){
      string varname = (string) var->GetName();
      if ( varname.find("gamma_stat")!=string::npos ){
	RooAbsReal* nom_gamma = (RooConstVar*) w->obj( ("nom_" + varname).c_str() );
	double nom_gamma_val = nom_gamma->getVal();
	double sigma = 1/TMath::Sqrt( nom_gamma_val );
	var->setVal(1 + Nsigma*sigma);
      }
    }

    return;
  }



  void SetAllNuisanceParaToSigma(double Nsigma){
    
    TIterator* it = mc->GetNuisanceParameters()->createIterator();
    RooRealVar* var = NULL;
    while( (var = (RooRealVar*) it->Next()) ){
      string varname = (string) var->GetName();
      if ( varname.find("gamma_stat")!=string::npos ) continue;
      if(strcmp(var->GetName(),"Lumi")==0){
	var->setVal(w->var("nominalLumi")->getVal()*(1+Nsigma*LumiRelError));
      } else{
	var->setVal(Nsigma);
      }	
    }
    
    return;
  }
  
  
  void SetNuisanceParaToSigma(RooRealVar *var, double Nsigma){
    
    string varname = (string) var->GetName();
    if ( varname.find("gamma_stat")!=string::npos ) return;

    if(strcmp(var->GetName(),"Lumi")==0){
      var->setVal(w->var("nominalLumi")->getVal()*(1+Nsigma*LumiRelError));
    } else{
      var->setVal(Nsigma);
    }	
    
    return;
  }
  
  
  void SetPOI(double mu){
    RooRealVar * firstPOI = dynamic_cast<RooRealVar*>(mc->GetParametersOfInterest()->first());
    firstPOI->setVal(mu);
    return  ;
  }
  
  
  bool IsSimultaneousPdfOK(){
    
    bool IsOK=true;
    
    bool IsSimultaneousPDF = strcmp(mc->GetPdf()->ClassName(),"RooSimultaneous")==0;
    if (!IsSimultaneousPDF){
      cout << " ERROR : no Simultaneous PDF was found, will stop here." << endl;
      cout << " You need to investigate your input histogramms." << endl;
      IsOK = false;
    }
    
    return IsOK;

  }


  bool IsChannelNameOK(){

    bool IsOK=true; 
    if( !IsSimultaneousPdfOK() ) return false;

    RooSimultaneous* simPdf = (RooSimultaneous*)(mc->GetPdf());
    RooCategory* channelCat = (RooCategory*) (&simPdf->indexCat());
    TIterator* iter = channelCat->typeIterator() ;
    RooCatType* tt = NULL;    
    while((tt=(RooCatType*) iter->Next()) ){
      string channelName =  tt->GetName();
      if (channelName.find("/")!=string::npos){
	cout << endl;
	cout << "One of the channel name contain a caracter \"/\" : " << endl;
	cout << "  - "  << channelName << endl;
	cout << "This is mis-intrepreted by roofit in the reading of the workspace. " << endl;
	cout << "Please change the channel name in the xml file to run this code." << endl;
	cout << endl;
	IsOK = false;
      }
    }


    return IsOK;
  }

  
  void PrintModelObservables(){
    
    RooArgSet* AllObservables = (RooArgSet*) mc->GetObservables();
    TIterator* iter = AllObservables->createIterator() ;
    RooAbsArg* MyObs = NULL;    
    cout << endl;
    cout << "List of model Observables : "  << endl;
    cout << "----------------------------"  << endl;
    while( (MyObs = (RooAbsArg*) iter->Next()) )
      MyObs->Print();
    
    return;
  }

  
  void PrintNuisanceParameters(){
    
    RooArgSet nuis = *mc->GetNuisanceParameters();
    TIterator* itr = nuis.createIterator();
    RooRealVar* arg;
    cout << endl;
    cout << "List of nuisance parameters : "  << endl;
    cout << "----------------------------"  << endl;    
    while ((arg=(RooRealVar*)itr->Next())) {
      if (!arg) continue;
      cout << arg->GetName()  << " : " << arg->getVal() << "+/-" << arg->getError() << endl;
    }
    return;
  }


  void PrintAllParametersAndValues(RooArgSet para){
    TIterator* itr = para.createIterator();
    RooRealVar* arg;
    cout << endl;
    cout << "List of parameters : "  << endl;
    cout << "----------------------------"  << endl;    
    while ((arg=(RooRealVar*)itr->Next())) {
      if (!arg) continue;
      cout << arg->GetName() << " = " << arg->getVal() << endl;
    }
    return;
  }

  void PrintSubChannels(){
    
    RooMsgService::instance().setGlobalKillBelow(ERROR);

    if( !IsSimultaneousPdfOK() ) return;
    
    RooSimultaneous* simPdf = (RooSimultaneous*)(mc->GetPdf());
    RooCategory* channelCat = (RooCategory*) (&simPdf->indexCat());
    TIterator* iter = channelCat->typeIterator() ;
    RooCatType* tt = NULL;    

    while((tt=(RooCatType*) iter->Next()) ){
      
      RooAbsPdf  *pdftmp  = simPdf->getPdf( tt->GetName() );
      RooAbsData *datatmp = data->reduce(Form("%s==%s::%s",channelCat->GetName(),channelCat->GetName(),tt->GetName()));

      cout << endl;
      cout << endl;
      cout << "Details on channel " << tt->GetName() << " : "  << endl;
      cout << "----------------------------------------------------------" << endl;      
      datatmp->Print();
      pdftmp->Print();
      PrintNumberOfEvents(pdftmp);

    }

    return;
  }


  void PrintNumberOfEvents(RooAbsPdf *pdf){
    
    RooRealVar* firstPOI = (RooRealVar*) mc->GetParametersOfInterest()->first();
    double val_sym=1;
    cout 
      << Form(" %3s |","")
      << Form(" %-32s |","Nuisance Parameter") 
      << Form(" %18s |","Signal events") 
      << Form(" %18s |","% Change (+1sig)") 
      << Form(" %18s |","% Change (-1sig)") 
      << Form(" %18s |","Background events") 
      << Form(" %18s |","% Change (+1sig)") 
      << Form(" %18s |","% Change (-1sig)") 
      << endl;
  
    int inuis=-1;
    RooArgSet  *obstmp  = pdf->getObservables( *mc->GetObservables() ) ;
    RooRealVar *myobs   = ((RooRealVar*) obstmp->first());

    RooArgSet nuis = *mc->GetNuisanceParameters();
    TIterator* itr = nuis.createIterator();
    RooRealVar* arg;
    while ((arg=(RooRealVar*)itr->Next())) {
      if (!arg) continue;
      //
      ++inuis;
      //

      double val_hi = val_sym;
      double val_lo = -val_sym;
      double val_nom = arg->getVal();
      
      if (string(arg->GetName()) == "Lumi"){
	val_nom = w->var("nominalLumi")->getVal();
	val_hi  = w->var("nominalLumi")->getVal() * (1+LumiRelError);
	val_lo  = w->var("nominalLumi")->getVal() * (1-LumiRelError);
      }
      
      //
      arg->setVal(val_hi);
      firstPOI->setVal(0);
      double b_hi = pdf->expectedEvents(*myobs);
      firstPOI->setVal(1);
      double s_hi = pdf->expectedEvents(*myobs)-b_hi;
      //
      arg->setVal(val_lo);
      firstPOI->setVal(0);
      double b_lo = pdf->expectedEvents(*myobs);
      firstPOI->setVal(1);
      double s_lo = pdf->expectedEvents(*myobs)-b_lo;
      //
      arg->setVal(val_nom);
      firstPOI->setVal(0);
      double b_nom = pdf->expectedEvents(*myobs);
      firstPOI->setVal(1);
      double s_nom = pdf->expectedEvents(*myobs)-b_nom;
      //
      double x_nom = s_nom ;
      double x_hi  = 0; if (s_nom) x_hi = (s_hi-s_nom)/s_nom; 
      double x_lo  = 0; if (s_nom) x_lo = (s_lo-s_nom)/s_nom; 
      double y_nom = b_nom ;
      double y_hi  = 0; if (b_nom) y_hi = (b_hi-b_nom)/b_nom; 
      double y_lo  = 0; if (b_nom) y_lo = (b_lo-b_nom)/b_nom; 

      cout 
	<< Form(" %3d |",inuis)
	<< Form(" %-32s |",arg->GetName()) 
	<< Form(" %18.2f |",x_nom) 
	<< Form(" %18.2f |",100*x_hi) 
	<< Form(" %18.2f |",100*x_lo) 
	<< Form(" %18.2f |",y_nom) 
	<< Form(" %18.2f |",100*y_hi) 
	<< Form(" %18.2f |",100*y_lo) 
	<< endl;
    } 

    return;
  }
  
  void SetStyle(){
    gStyle->SetOptStat(0);
    
    return;
  }

  void LegendStyle(TLegend* l) {
    l->SetBorderSize(0);
    l->SetFillColor(0);
    l->SetLineColor(0);
    l->SetFillStyle(0);
    //l->SetTextFont(62);
    l->SetTextSize(0.050);
    return;
  }
  
 
}

