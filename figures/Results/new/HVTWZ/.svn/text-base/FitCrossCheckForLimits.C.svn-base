/*
Author: Romain Madar & Gabriel Facini
Date:   2012-02-16
Email:  romain.madar@cern.ch, gabriel.facini@cern.ch


Description : This code allows the check quality of fit performed in the limit derivation.
              It works on a generic workspace produced by hist2workspace command. It performs
	      a global fit and a fit per subchannel automatically. Various control plots (pull 
	      distribution, correlation matrix, distribution before and after fit, ...) are 
	      stored in a the rootfile FitCrossChecks.root. Please use root version >=5.34.17


Updates:

- 2012-09-20 G. Facini
   * Get Histograms to plot systematic shapes
   * Add plotRelative flag to plot the relative shape difference for a given systematic
   * Add drawPlots flag to make eps files
   * Toys (still in developpement)
   * components post-fit

- 2012-10 R. Madar
   * Post-fit NP versus subchannel
   * Morphing control plots for each syst x process x subchannel
   * Add the stack of different backgrounds in plot after profiling

- 2012-11 R. Madar
   * Add the asymmetric error given by minos for the NPs
   * Add the -2Log(L) versus each NP
   * Add a red color for/summary of suspicious NPs

- 2013-01 N. Morange
   * Bugfix. NP not correctly reset to their initial values at the beginning of function calls.
 
 - 2013-03 G. Facini
 * Add the -Log(L) for each subchannel & fit for poisson term (1D Response)

 - 2013-05 N. Ruthmann
 * Add a blind mode with an asimov dataset, or another pseudo-dataset.

 - 2015-01 R. Madar
 * Change in normalization for pre-fit histogram (due to a change in RooFit version)

*/
 

// C++
#include <iostream>
#include <fstream>
#include <iomanip>
#include <sstream>
#include <algorithm>
#include <map>

// Root
#include "TFile.h"
#include "TROOT.h"
#include "TSystem.h"
#include "TStyle.h"
#include "TLatex.h"
#include "TCanvas.h"
#include "TList.h"
#include "TMath.h"
#include "TH1.h"
#include "TH2.h"
#include "TF1.h"
#include "TGaxis.h"
#include "TTree.h"
#include "TLeaf.h"
#include "TMarker.h"

// RooFit
#include "RooWorkspace.h"
#include "RooRealVar.h"
#include "RooPlot.h"
#include "RooAbsData.h"
#include "RooHist.h"
#include "RooSimultaneous.h"
#include "RooCategory.h"
#include "RooFitResult.h"
#include "RooAbsData.h"
#include "RooRealSumPdf.h"
#include "Roo1DTable.h"
#include "RooConstVar.h"
#include "RooProduct.h"
#include "RooRandom.h"
#include "TStopwatch.h"
#include "RooNLLVar.h"
#include "RooMsgService.h"
#include "RooMinimizer.h"

// RooStat
#include "RooStats/ModelConfig.h"
#include "RooStats/ProfileInspector.h"
#include "RooStats/ProfileLikelihoodCalculator.h"
#include "RooStats/LikelihoodInterval.h"
#include "RooStats/LikelihoodIntervalPlot.h"
#include "RooStats/ProfileLikelihoodTestStat.h"
#include "RooStats/SamplingDistribution.h"
#include "RooStats/SamplingDistPlot.h"
#include "RooStats/ToyMCSampler.h"
#include "RooStats/RooStatsUtils.h"

using namespace std;
using namespace RooFit;
using namespace RooStats;

struct NPContainer{ 
  TString NPname; 
  double  NPvalue; 
  double  NPerrorHi;
  double  NPerrorLo;
  TString WhichFit;
};

static bool comp_second_abs_decend( const pair< RooRealVar*, float >& i, const pair< RooRealVar*, float >& j ) {
  return fabs(i.second) > fabs(j.second);
}

namespace LimitCrossCheck{  

  // Global variables;
  // User configuration one
  bool drawPlots(true);                    // create eps & png files and creat a webpage
  bool plotRelative(false);                 // plot % shift of systematic
  bool draw1DResponse(false);		    // draw 1D response for each NP 
  bool UseMinosError(false);                // compute minos error (if false : use minuit error)
  int isBlind(0);                           // 0: Use observed Data 1: use Asimov data 2: use toydata
  double mu_asimov(0.0);                    // mu value used to generate Asimov dataset (not used if isBlind==0)
  double PullMaxAcceptable(1.5);            // Threshold to consider a NP[central value] as suspicious
  double ErrorMinAcceptable(0.2);           // Threshold to consider a NP[error] as suspicious
  TString xAxisLabel("Final Distribution"); // set what the x-axis of the distribution is
  
  // not switches
  RooWorkspace *w         ;
  ModelConfig  *mc        ;
  RooAbsData   *data      ;
  TFile        *outputfile; 
  double        LumiRelError;
  TDirectory   *MainDirSyst;
  TDirectory   *MainDirMorphing;
  TDirectory   *MainDirFitEachSubChannel;
  TDirectory   *MainDirFitGlobal;
  TDirectory   *MainDirModelInspector;
  TDirectory   *MainDirStatTest;
  map <string,double> MapNuisanceParamNom;
  map <TString,RooFitResult*> AllFitResults_map;
  map <TString,int> AllFitStatus_map;
  vector<NPContainer> AllNPafterEachFit_vec;
  TString OutputDir;
  
  //Global functions
  RooFitResult* FitPDF( ModelConfig* model, RooAbsPdf* fitpdf, RooAbsData* fitdata, 
			int &MinuitStatus, int &HessStatus, double &Edm,
			TString minimType = "Minuit2", bool useMinos = false );
  void     PlotHistosBeforeFit(double nSigmaToVary, double mu);
  void     PlotMorphingControlPlots();
  void     PlotHistosAfterFitEachSubChannel(bool IsConditionnal , double mu);
  void     PlotHistosAfterFitGlobal(bool IsConditionnal , double mu);
  void     PlotsNuisanceParametersVSmu();
  void     PlotsStatisticalTest(double mu_pe, double mu_hyp);
  void 	   Plot1DResponse(RooAbsReal* nll, RooRealVar* var, TString cname, TCanvas* can, 
			  TF1* poly, bool IsFloating, TLatex* latex, TDirectory* tdir, RooArgSet* SliceSet = 0);
  double   FindMuUpperLimit();
  void     PrintModelObservables();
  void     PrintNuisanceParameters();
  void     PrintAllParametersAndValues(RooArgSet para);
  void     PrintNumberOfEvents(RooAbsPdf *pdf);
  void     PrintSubChannels();
  void     PrintSuspiciousNPs();
  void     PrintFits();
  bool     IsSimultaneousPdfOK();
  bool     IsChannelNameOK();
  void     SetAllNuisanceParaToSigma(double Nsigma);
  void     SetAllStatErrorToSigma(double Nsigma);
  void     SetNuisanceParaToSigma(RooRealVar *var, double Nsigma);
  void     GetNominalValueNuisancePara();
  void     SetNominalValueNuisancePara();
  void     SetPOI(double mu);
  void     SetStyle();
  void     LegendStyle(TLegend* l);
  bool     IsAnormFactor(RooRealVar *var);
  int 	   GetPosition(RooRealVar* var, TH2D* corrMatrix);
  list< pair<RooRealVar*, float> > GetOrderedCorrelations(RooRealVar* var, RooFitResult* fitres);
  TCanvas* DrawShift(TString channel, TString var, TString comp, double mu, TH1* d, TH1* n, TH1* p1s, TH1* m1s);
  TH2D*    GetSubsetOfCorrMatrix(RooRealVar* var, list< pair<RooRealVar*,float> >& pairs, RooFitResult* fitres, int size);
  void     Initialize(const char* infile , const char* outputdir, const char* workspaceName, const char* modelConfigName, const char* ObsDataName);
  void     Finalize();
  void unfoldConstraints(RooArgSet& initial, RooArgSet& final, RooArgSet& obs, RooArgSet& nuis, int& counter);
  RooDataSet* makeAsimovData(double mu_val, bool fluctuateData=false, string* mu_str = NULL);

  
  //======================================================
  // ================= Main function =====================
  //======================================================
  void PlotFitCrossChecks(const char* infile          = "WorkspaceForTest1.root",
			  const char* outputdir       = "./results/",
			  const char* workspaceName   = "ws_1100p000",
			  const char* modelConfigName = "ModelConfig",
			  const char* ObsDataName     = "obsData"){
    
    Initialize(infile, outputdir, workspaceName, modelConfigName, ObsDataName);

    // -----------------------------------------------------------------------------------
    // 1 - Plot nominal and +/- Nsigma (for each nuisance paramater) for Data, signal+bkg
    // -----------------------------------------------------------------------------------
    //PlotHistosBeforeFit(1.0,0.0); // (nSigma,mu)
    

    // -----------------------------------------------------------------------------------
    // 2 - Control plots for morphing (ie, -1/0/+1 sigma --> continuous NP)
    // -----------------------------------------------------------------------------------    
    //PlotMorphingControlPlots();


    // ----------------------------------------------------------------------------------
    // 3 - Plot histograms after unconditional fit (theta and mu fitted at the same time)
    // ----------------------------------------------------------------------------------    
    bool IsConditional = false;
    //PlotHistosAfterFitEachSubChannel(IsConditional,0.0);
    PlotHistosAfterFitGlobal(IsConditional,0.0);
        
    
    // --------------------------------------------------------------------------------------------
    // 4 - Plot the unconditionnal fitted nuisance paramters value (theta fitted while mu is fixed)
    // -------------------------------------------------------------------------------------------
    //IsConditional = true;
    //PlotHistosAfterFitEachSubChannel(IsConditional, 0.0);
    //PlotHistosAfterFitGlobal(IsConditional,0.0);


    // -------------------------------------------
    // 5 - Plot the nuisance parameters versus mu
    // -------------------------------------------
    //PlotsNuisanceParametersVSmu(); // This can take time


    // -------------------------------------------
    // 6 - Plot the pulls and stat test from toys
    // -------------------------------------------
    //PlotsStatisticalTest(0,0);

    Finalize();
    return;
  
  }
  






  // ============================================================
  // ============ Definition of all the functions ===============
  // ============================================================




  // ============================================================
  // ============ Definition of Fitting Function ================
  // ============================================================
  
  RooFitResult* FitPDF( ModelConfig* model, RooAbsPdf* fitpdf, RooAbsData* fitdata, 
			int &MinuitStatus, int &HessStatus, double &Edm,
			TString minimType, bool useMinos ) {
    
    model->Print();

    RooArgSet* constrainedParams = fitpdf->getParameters(*data);
    RemoveConstantParameters(constrainedParams);
    Constrain(*constrainedParams);

    const RooArgSet* glbObs = mc->GetGlobalObservables();

    RooRealVar * poi = (RooRealVar*) model->GetParametersOfInterest()->first();
    cout << "Constatnt POI " << poi->isConstant() << endl;
    cout << "Value of POI  " << poi->getVal() << endl;

    RooAbsReal * nll = fitpdf->createNLL(*fitdata, Constrain(*constrainedParams), GlobalObservables(*glbObs), Offset(1) );
    double nllval = nll->getVal();

    std::cout << "initial parameters" << std::endl;
    constrainedParams->Print("v");

    std::cout << "INITIAL NLL = " << nllval << std::endl;

    static int nrItr = 0;
    int maxRetries = 3;
    ROOT::Math::MinimizerOptions::SetDefaultMinimizer(minimType);
    int strat = ROOT::Math::MinimizerOptions::DefaultStrategy();
    int save_strat = strat;
    RooMinimizer minim(*nll);
    minim.setStrategy(strat);
    minim.setPrintLevel(1);
    minim.setEps(1);

    TStopwatch sw; sw.Start(); 

    int status=-99;
    HessStatus=-99;
    Edm = -99;
    RooFitResult * r;
    while (nrItr<maxRetries && status!=0 && status!=1){

      cout << endl;
      cout << endl;
      cout << endl;
      cout << "Fit try n°" << nrItr+1 << endl;
      cout << "======================" << endl;
      cout << endl;
      
          
      ROOT::Math::MinimizerOptions::SetDefaultStrategy(save_strat);
      status = minim.minimize(ROOT::Math::MinimizerOptions::DefaultMinimizerType().c_str(),ROOT::Math::MinimizerOptions::DefaultMinimizerAlgo().c_str());
      HessStatus= minim.hesse();
      r = minim.save();
      Edm = r->edm();

      //up the strategy
      bool FitIsNotGood = ((status!=0 && status!=1) || (HessStatus!=0 && HessStatus!=1) || Edm>1.0);
      if (FitIsNotGood && strat<2){
	cout << endl;
	cout << "   *******************************" << endl;
	cout << "   * Increasing Minuit strategy (was " << strat << ")" << endl;
	strat++;
	cout << "   * Fit failed with : " << endl;
	cout << "      - minuit status " << status << endl;
	cout << "      - hess status " << HessStatus << endl;
	cout << "      - Edm = " << Edm << endl;
	cout << "   * Retrying with strategy " << strat << endl;
	cout << "   ********************************" << endl;
	cout << endl;
	minim.setStrategy(strat);
	status = minim.minimize(ROOT::Math::MinimizerOptions::DefaultMinimizerType().c_str(), ROOT::Math::MinimizerOptions::DefaultMinimizerAlgo().c_str());
	HessStatus= minim.hesse();
	r = minim.save();
	Edm = r->edm();
      }
      
      FitIsNotGood = ((status!=0 && status!=1) || (HessStatus!=0 && HessStatus!=1) || Edm>1.0);
      if (FitIsNotGood && strat < 2){
	cout << endl;
	cout << "   ********************************" << endl;
	cout << "   * Increasing Minuit strategy (was " << strat << ")" << endl;
	strat++;
	cout << "   * Fit failed with : " << endl;
	cout << "      - minuit status " << status << endl;
	cout << "      - hess status " << HessStatus << endl;
	cout << "      - Edm = " << Edm << endl;
	cout << "   * Retrying with strategy " << strat << endl;
	cout << "   ********************************" << endl;
	cout << endl;
	minim.setStrategy(strat);
	status = minim.minimize(ROOT::Math::MinimizerOptions::DefaultMinimizerType().c_str(), ROOT::Math::MinimizerOptions::DefaultMinimizerAlgo().c_str());
	r = minim.save();
	Edm = r->edm();
      }
      
      FitIsNotGood = ((status!=0 && status!=1) || (HessStatus!=0 && HessStatus!=1) || Edm>1.0);
      if (FitIsNotGood && strat < 2){
	cout << endl;
	cout << "   *******************************" << endl;
	cout << "   * Increasing Minuit strategy (was " << strat << ")" << endl;
	strat++;
	cout << "   * Fit failed with : " << endl;
	cout << "      - minuit status " << status << endl;
	cout << "      - hess status " << HessStatus << endl;
	cout << "      - Edm = " << Edm << endl;
	cout << "   * Retrying with strategy " << strat << endl;
	cout << "   ********************************" << endl;
	cout << endl;
	minim.setStrategy(strat);
	status = minim.minimize(ROOT::Math::MinimizerOptions::DefaultMinimizerType().c_str(), ROOT::Math::MinimizerOptions::DefaultMinimizerAlgo().c_str());
	HessStatus= minim.hesse();
	r = minim.save();
	Edm = r->edm();
      }
      
      if(useMinos) { minim.minos(); }


      FitIsNotGood = ((status!=0 && status!=1) || (HessStatus!=0 && HessStatus!=1) || Edm>1.0);
      if ( FitIsNotGood) nrItr++;
      if (nrItr == maxRetries) {
	cout << endl;
	cout << endl;
	cout << endl;
	cout << "***********************************************************" << endl;
	cout << "WARNING::Fit failure unresolved with status " << status << endl;
	cout << "   Please investigate your workspace" << endl;
	cout << "   Find a wall : you will need it to crash your head on it" << endl;
	cout << "***********************************************************" << endl;
	cout << endl;
	cout << endl;
	cout << endl;
	MinuitStatus = status;
	return r;
      }
      
    }  
    
    r = minim.save();
    cout << endl;
    cout << endl;
    cout << endl;
    cout << "***********************************************************" << endl;
    cout << "         FIT FINALIZED SUCCESSFULLY : " << endl;
    cout << "            - minuit status " << status << endl;
    cout << "            - hess status " << HessStatus << endl;
    cout << "            - Edm = " << Edm << endl;
    cout << " -- " ; sw.Print();
    cout << "***********************************************************" << endl;
    cout << endl;
    cout << endl;
    cout << endl;

    MinuitStatus = status;
    sw.Print();
    
    return r;
  } // FitPDF
  
    
  void PlotHistosBeforeFit(double nSigmaToVary, double mu){
    cout << endl << "Plotting Histos Before Fit " << endl;
    cout << "\t Plotting relative " << plotRelative << endl;

    // Put all parameters to their iniital values
    if(!w->loadSnapshot("snapshot_paramsVals_initial")) { 
      cout << "Cannot load " <<  "snapshot_paramsVals_initial" << endl;
      exit(-1);
    }

    RooMsgService::instance().setGlobalKillBelow(ERROR);

    TString MaindirName("MuIsEqualTo_");
    MaindirName += mu;
    if(plotRelative) { MaindirName.Append("_relative"); }
    TDirectory *MainDir = (TDirectory*) MainDirSyst->mkdir(MaindirName);
    gROOT->cd();

    // Get the RooSimultaneous PDF
    RooSimultaneous *simPdf = (RooSimultaneous*)(mc->GetPdf());
    RooRealVar * firstPOI = dynamic_cast<RooRealVar*>(mc->GetParametersOfInterest()->first());
    firstPOI->setVal(mu);

    RooCategory* channelCat = (RooCategory*) (&simPdf->indexCat());
    TIterator* iter = channelCat->typeIterator() ;
    RooCatType* tt = NULL;    
    TString dirName("");
    while((tt=(RooCatType*) iter->Next()) ){
      
      cout << endl;
      cout << endl;
      cout << " -- On category " << tt->GetName() << " " << endl;
      ostringstream SubdirName;
      SubdirName << tt->GetName();
      TDirectory *SubDirChannel = (TDirectory*) MainDir->mkdir(SubdirName.str().c_str());
      gROOT->cd();
    
      // Get pdf associated with state from simpdf
      RooAbsPdf  *pdftmp  = simPdf->getPdf(tt->GetName()) ;
      RooArgSet  *obstmp  = pdftmp->getObservables( *mc->GetObservables() ) ;
      RooAbsData *datatmp = data->reduce(Form("%s==%s::%s",channelCat->GetName(),channelCat->GetName(),tt->GetName()));
      RooRealVar *obs     = ((RooRealVar*) obstmp->first());

      if( !pdftmp || !obstmp || !datatmp ||!obs ){
	cerr<<"Problem accessing pdf : "<<pdftmp<<" "<<obstmp<<" "<<datatmp<<" "<<obs<<endl;
	exit(6);
      }
	  
      // Get the bin width
      RooRealVar* binWidth = ((RooRealVar*) pdftmp->getVariables()->find(Form("binWidth_obs_x_%s_0",tt->GetName()))) ;

      //RooArgSet* testparams = pdftmp->getVariables() ;
      //testparams->Print();

      if(!binWidth) { cout << "No bin width!" << tt->GetName() << endl; return; }
      cout << "    Bin Width : " << binWidth->getVal() << endl;

      // First be sure that all nuisance parameters are nominal
      SetAllStatErrorToSigma(0.0);
      SetAllNuisanceParaToSigma(0.0);

      // Look at each component
      TString modelName(tt->GetName());
      modelName.Append("_model");
      cout << "    Contains the following components for modelName "<<modelName<<" : " << endl;
      //testparams = pdftmp->getComponents();
      //testparams->Print();
      RooRealSumPdf *pdfmodel = (RooRealSumPdf*) (pdftmp->getComponents())->find(modelName);
      if( !pdfmodel ){
	cerr<<"pdfmodel "<<modelName<<" doesn't exist\nCan't look at the component"<<endl;
	exit(6);
      }
      RooArgList funcList =  pdfmodel->funcList();
      RooLinkedListIter funcIter = funcList.iterator() ;
      RooProduct* comp = 0;
      float total(0);
      SetPOI(1);	 // want to see signal
      map<TString, TH1*> nominals;
      while( (comp = (RooProduct*) funcIter.Next())) { 
        cout << " Component : " << comp->GetName() << endl;
        cout << "\t" << ( comp->createIntegral(*obs) )->getVal() * binWidth->getVal() << endl;
        total += ( comp->createIntegral(*obs) )->getVal() * binWidth->getVal();
      }
      SetPOI(mu);	
      cout << " Total (mu = 1) : " << total << endl;

      // Loop over nuisance params
      TIterator* it = mc->GetNuisanceParameters()->createIterator();
      RooRealVar* var = NULL;
      bool IsAllStatDone = false; 
      TString chanName(tt->GetName());
      while( (var = (RooRealVar*) it->Next()) ){

        string varname = (string) var->GetName();
        if ( varname.find("gamma_stat")!=string::npos ){
          continue;
        }

        // one sigma not defined for floating parameters 
        // is there a more general way of getting to this fact?
	if (IsAnormFactor(var)) continue;

        // user firendly label / name
        TString varName(var->GetName());
        varName.ReplaceAll("alpha_Sys","");
        varName.ReplaceAll("alpha_","");

        dirName = OutputDir+"/"+MainDirSyst->GetName()+"/"+MaindirName+"/"+chanName+"/"+varName;

        // Not consider nuisance parameter being not assocaited to systematics
        if (MapNuisanceParamNom[varname]!=0.0 &&
            MapNuisanceParamNom[varname]!=1.0 ) continue;

        cout << endl;
        cout << "  -- On nuisance parameter : " << var->GetName() << endl; 

        TString histName("");

        // -1 sigma
        SetNuisanceParaToSigma(var,-nSigmaToVary);
        SetPOI(mu);
        histName = chanName+"_"+varName+"_"+TString(plotRelative)+"_m1sigma";
        TH1* hm1sigma = pdftmp->createHistogram(histName,*obs);
        //hm1sigma->Scale(pdftmp->expectedEvents(*obs)); --> Not needed anymore for root v5-34-17

        // +1 sigma
        SetNuisanceParaToSigma(var,+nSigmaToVary);
        SetPOI(mu);	
        histName.ReplaceAll("m1sigma","p1sigma");
        TH1* hp1sigma = pdftmp->createHistogram(histName,*obs);
        //hp1sigma->Scale(pdftmp->expectedEvents(*obs)); --> Not needed anymore for root v5-34-17

        // Nominal
        SetNuisanceParaToSigma(var,0.0);
        SetPOI(mu);
        histName.ReplaceAll("p1sigma","nominal");
        TH1* hnominal = pdftmp->createHistogram(histName,*obs);
        //hnominal->Scale(pdftmp->expectedEvents(*obs)); --> Not needed anymore for root v5-34-17

        // Data
        histName.ReplaceAll("nominal","data");
        TH1* hdata = datatmp->createHistogram(histName,*obs);
	for (int ib=0 ; ib<hdata->GetNbinsX()+1 ; ib++) hdata->SetBinError(ib, sqrt(hdata->GetBinContent(ib)));


        TString expName("AllBkg(#mu=");
        expName += mu;
        expName.Append(")");
        TCanvas* c2 = DrawShift(chanName,(TString)var->GetName(),expName,mu,hdata,hnominal,hp1sigma,hm1sigma);

        SubDirChannel->cd();
        c2->Write();
        if(drawPlots) { 
          system(TString("mkdir -vp "+dirName));
          c2->Print(dirName+"/totalExpected.eps");
          c2->Print(dirName+"/totalExpected.png");
        }
        c2->Close();
        gROOT->cd();

        // reset pointer
        hdata->~TH1();
        hnominal->~TH1();
        hp1sigma->~TH1();
        hm1sigma->~TH1();
        hdata = 0;
        hnominal = 0;
        hp1sigma = 0;
        hm1sigma = 0;

        // Loop over components and make these plots for each one
        funcIter = funcList.iterator();
        while( (comp = (RooProduct*) funcIter.Next()) ) {
          TString compName(comp->GetName());
          compName.ReplaceAll("L_x_","");
          compName.ReplaceAll(chanName,"");
          compName.ReplaceAll("__overallSyst_x_StatUncert","");
          compName.ReplaceAll("__overallSyst_x_HistSyst","");
          compName.ReplaceAll("__overallSyst_x_Exp","");

          // Fisrt be sure that all nuisance parameters are nominal
          SetAllStatErrorToSigma(0.0);
          SetAllNuisanceParaToSigma(0.0);
          SetPOI(1);	// set to one so do not ignore signal

          // -1 sigma
          SetNuisanceParaToSigma(var,-nSigmaToVary);
          SetPOI(1);
          histName = chanName+"_"+varName+"_"+compName+"_"+TString(plotRelative)+"_m1sigma";
          hm1sigma = comp->createHistogram(histName,*obs);
          hm1sigma->Scale( binWidth->getVal() );

          // +1 sigma
          SetNuisanceParaToSigma(var,+nSigmaToVary);
          SetPOI(1);
          histName.ReplaceAll("m1sigma","p1sigma");
          hp1sigma = comp->createHistogram(histName,*obs);
          hp1sigma->Scale( binWidth->getVal() );

          // nominal
          SetNuisanceParaToSigma(var,0.0);
          SetPOI(1);
          histName.ReplaceAll("p1sigma","nominal");
          hnominal = comp->createHistogram(histName,*obs);
          hnominal->Scale( binWidth->getVal() );

          // skip components which are not affected by this nuisance parameter 
          if(hp1sigma->Integral() == 0 || hm1sigma->Integral() == 0) { 
            cout << "Integral 0 " << varName << " on " << compName << " in " << chanName 
              << " ( " << hp1sigma->Integral() << ", " << hm1sigma->Integral() << " ) " << endl;
            continue;
          }

          // skip components which are not affected by this nuisance parameter
          float totUp(0), totDn(0);
          for(int b=1; b<hnominal->GetNbinsX()+1; b++) { // no over/under-flow
            if(hnominal->GetBinContent(b)>0) {
              totUp += pow((hp1sigma->GetBinContent(b)-hnominal->GetBinContent(b))/hnominal->GetBinContent(b),2);
              totUp += pow((hm1sigma->GetBinContent(b)-hnominal->GetBinContent(b))/hnominal->GetBinContent(b),2);
            }
          }
          if( totUp < 0.05 && totDn < 0.05 ) { 
            cout << "No " << varName << " on " << compName << " in " << chanName << " ( " << totUp << ", " << totDn << " ) " << endl;
            continue; 
          }

          c2 = DrawShift(chanName,(TString)var->GetName(),compName,mu,0,hnominal,hp1sigma,hm1sigma);

          SubDirChannel->cd();
          c2->Write();
          if(drawPlots) { 
            //system(TString("mkdir -vp "+dirName));
            c2->Print(dirName+"/"+compName+".eps");
            c2->Print(dirName+"/"+compName+".png");
          }
          c2->Close();
          gROOT->cd();

          // Put everything back to the nominal
          SetAllNuisanceParaToSigma(0.0);
          SetPOI(mu);
          
          //
          hnominal->~TH1();
          hp1sigma->~TH1();
          hm1sigma->~TH1();
          hnominal = 0;
          hp1sigma = 0;
          hm1sigma = 0;
        } // loop over components

        // Put everything back to the nominal
        SetAllNuisanceParaToSigma(0.0);
        SetPOI(mu);

        // Stat uncertainty
        if (!IsAllStatDone){

          // reset pointer
          hdata = 0;
          hnominal = 0;
          hp1sigma = 0;
          hm1sigma = 0;

          // -1 sigma
          SetAllStatErrorToSigma(-nSigmaToVary);
          SetAllNuisanceParaToSigma(0.0);
          SetPOI(mu);
          histName = chanName+"_Stat_"+TString(plotRelative)+"_m1sigma";
          hm1sigma = pdftmp->createHistogram(histName,*obs);
          //hm1sigma->Scale(pdftmp->expectedEvents(*obs)); --> Not needed anymore for root v5-34-17

          // +1 sigma
          SetAllStatErrorToSigma(+nSigmaToVary);
          SetAllNuisanceParaToSigma(0.0);
          SetPOI(mu);	
          histName.ReplaceAll("m1sigma","p1sigma");
          hp1sigma = pdftmp->createHistogram(histName,*obs);
          //hp1sigma->Scale(pdftmp->expectedEvents(*obs)); --> Not needed anymore for root v5-34-17

          // Nominal
          SetAllStatErrorToSigma(0.0);
          SetNuisanceParaToSigma(var,0.0);
          SetPOI(mu);
          histName.ReplaceAll("p1sigma","nominal");
          hnominal = pdftmp->createHistogram(histName,*obs);
          //hnominal->Scale(pdftmp->expectedEvents(*obs)); --> Not needed anymore for root v5-34-17

          // Data
          histName.ReplaceAll("nominal","data");
          hdata = datatmp->createHistogram(histName,*obs);
	  for (int ib=0 ; ib<hdata->GetNbinsX()+1 ; ib++) hdata->SetBinError(ib, sqrt(hdata->GetBinContent(ib)));

	  cout << endl;
	  cout << " - stat uncertainty : " << endl;
          TCanvas* c4 = DrawShift(chanName,"Stat",expName,mu,hdata,hnominal,hp1sigma,hm1sigma);

          dirName = OutputDir+"/"+MainDirSyst->GetName()+"/"+MaindirName+"/"+chanName+"/Stat";
          SubDirChannel->cd();
          c4->Write();
          if(drawPlots) { 
            system(TString("mkdir -vp "+dirName));
            c4->Print(dirName+"/totalExpected.eps");
            c4->Print(dirName+"/totalExpected.png");
          }
          c4->Close();
          gROOT->cd();

          IsAllStatDone=true;
        }

      }
      
    } 
    
    return;
  }
  

  // create the canvas and put stuff on it 
  // to be used when plotting the +/- 1 sigma shifts
  TCanvas* DrawShift(TString channel, TString var, TString comp, double mu, TH1* d, TH1* n, TH1* p1s, TH1* m1s) {
    cout << " " << comp << endl;
    cout << "N(-sigma) = " << m1s->Integral() << endl;
    cout << "N(+sigma) = " << p1s->Integral() << endl;
    cout << "N(nominal) = " << n->Integral() << endl;
    if(d) { cout << "N(Observed) = " << d->Integral() << endl; }

    var.ReplaceAll("alpha_Sys","");
    var.ReplaceAll("alpha_","");

    TString cname = "can_" + channel + "_" + comp + "_" + var + "_mu";
    cname += mu;
    if(plotRelative) { cname.Append("_relative"); }
    cname.ReplaceAll("#","");
    cname.ReplaceAll("(","");
    cname.ReplaceAll(")","");
    cname.ReplaceAll("=","");
    TCanvas *canvas = new TCanvas(cname,cname,700,550);
    canvas->cd();
    TPad *pad1 = new TPad("pad1","pad1",0,0.25,1,1);
    pad1->SetBottomMargin(0.009);
    pad1->Draw();
    TPad *pad2 = new TPad("pad2","pad2",0,0,1,0.25);
    pad2->SetTopMargin(0.009);
    pad2->SetBottomMargin(0.5);
    pad2->Draw();
    
    // style
    if(d) { 
      d->SetLineColor(1);
      d->SetLineWidth(1); 
      d->SetMarkerColor(1); 
      d->SetMarkerSize(0.9); 
      d->SetMarkerStyle(20); 
    }
    n->SetLineWidth(2);
    p1s->SetLineColor(kRed);
    p1s->SetLineWidth(2);
    p1s->SetLineStyle(2);
    m1s->SetLineColor(kGreen);
    m1s->SetLineWidth(2);
    m1s->SetLineStyle(2);

    float max(0);
    float min(0);

    // put averages on the plot
    float avgUp = ( p1s->Integral() - n->Integral() ) / n->Integral();
    float avgDn = ( m1s->Integral() - n->Integral() ) / n->Integral();

    // Distribution in the upper pad
    pad1->cd();
    n->SetTitle(channel);
    n->GetXaxis()->SetTitle(xAxisLabel);
    max = p1s->GetMaximum();
    if(m1s->GetMaximum() > max) { max = m1s->GetMaximum(); }
    if(n->GetMaximum() > max) { max = n->GetMaximum(); }
    if(d) { if(d->GetMaximum() > max) { max = d->GetMaximum(); } }
    n->SetMaximum( 1.2*max );
    n->Draw("hist");
    if(d) { d->Draw("E1 same"); }
    p1s->Draw("hist same");
    m1s->Draw("hist same");
    
    // Distribution of the ratio in %
    pad2->cd();
    TH1F *p1s_ratio = (TH1F*) p1s->Clone();
    p1s_ratio->Add(n,-1); p1s_ratio->Divide(n); p1s_ratio->Scale(100);
    p1s_ratio->SetLineStyle(1);
    TH1F *m1s_ratio = (TH1F*) m1s->Clone();
    m1s_ratio->Add(n,-1); m1s_ratio->Divide(n); m1s_ratio->Scale(100);
    m1s_ratio->SetLineStyle(1);
    max = p1s_ratio->GetMaximum();
    if(m1s_ratio->GetMaximum() > max) { max = m1s_ratio->GetMaximum(); }
    min = p1s_ratio->GetMinimum();
    if(m1s_ratio->GetMinimum() < min) { min = m1s_ratio->GetMinimum(); }
    p1s_ratio->SetMaximum( 1.5*max );
    p1s_ratio->SetMinimum( min - 0.5*fabs(min) );
    p1s_ratio->GetYaxis()->SetNdivisions(004);
    p1s_ratio->GetXaxis()->SetTitleFont(43);
    p1s_ratio->GetXaxis()->SetTitleSize(16);
    p1s_ratio->GetXaxis()->SetTitleOffset(4);
    p1s_ratio->GetYaxis()->SetTitleOffset(1.1);
    p1s_ratio->GetYaxis()->SetTitleFont(43);
    p1s_ratio->GetYaxis()->SetTitleSize(13);
    p1s_ratio->GetXaxis()->SetLabelFont(43);
    p1s_ratio->GetXaxis()->SetLabelSize(13);
    p1s_ratio->GetYaxis()->SetLabelFont(43);
    p1s_ratio->GetYaxis()->SetLabelSize(13);
    p1s_ratio->SetTitle("");
    p1s_ratio->GetYaxis()->SetTitle("Rel. unc. (%)");
    p1s_ratio->Draw("hist");
    m1s_ratio->Draw("hist same");
    if (d){
      TH1F *d_ratio = (TH1F*) d->Clone();
      d_ratio->Add(n,-1); d_ratio->Divide(n); d_ratio->Scale(100);
      d_ratio->Draw("E1 same");
    }


    // get max and min and draw
    //  -- old way, just keep for book-keeping --
    if(plotRelative) {
      // draw percent error bands
      p1s->Add(n,-1); p1s->Divide(n); p1s->Scale(100);
      m1s->Add(n,-1); m1s->Divide(n); m1s->Scale(100);
      p1s->GetYaxis()->SetTitle("Percent Error");
      p1s->SetTitle(channel);
      p1s->GetXaxis()->SetTitle(xAxisLabel);
      max = p1s->GetMaximum();
      if(m1s->GetMaximum() > max) { max = m1s->GetMaximum(); }
      min = p1s->GetMinimum();
      if(m1s->GetMinimum() < min) { min = m1s->GetMinimum(); }
      p1s->SetMaximum( 1.5*max );
      p1s->SetMinimum( min - 0.5*fabs(min) );
      canvas->cd();
      p1s->Draw("hist");
      m1s->Draw("hist same");
      // draw nominal with a seperate axis on a transparent pad
      TPad *pad = new TPad("pad","pad",0,0,1,1);
      pad->SetFillStyle(4000); //will be transparent
      pad->SetFrameFillStyle(4000);
      pad->SetLeftMargin(canvas->GetLeftMargin());
      pad->SetRightMargin(canvas->GetRightMargin());
      pad->SetTopMargin(canvas->GetTopMargin());
      pad->SetBottomMargin(canvas->GetBottomMargin());
      pad->Draw();
      pad->cd();
      // new axis
      float xloc = n->GetXaxis()->GetBinLowEdge( n->GetNbinsX()+1 );
      TGaxis *axis = new TGaxis(xloc,0,xloc,p1s->GetMaximum(),0,n->GetMaximum(),510,"+L");
      axis->SetTitle(n->GetYaxis()->GetTitle());
      axis->SetTitleColor(kBlue);
      axis->SetLabelColor(kBlue);
      //axis->SetTitleFont(mFont);
      n->SetLineColor(kBlue);
      n->SetLineStyle(kDashed);
      n->GetYaxis()->SetTitle(""); n->SetTitle(""); n->GetXaxis()->SetTitle("");
      //n->Draw("hist ah e");
      n->Draw("hist ah");
      axis->Draw("same");
      pad->Update();
    }
    
    // write average shift on canvas
    if (!plotRelative) pad1->cd();
    TString info(var+" "+comp);
    info.Append(Form(" %5.2f, %5.2f",avgUp*100,avgDn*100));
    info.Append('%'); 
    TLatex *niceinfo = new TLatex(0.12, 0.85, info);
    niceinfo->SetNDC();
    niceinfo->SetTextSize(0.045);
    niceinfo->Draw("same");

    // legend
    TLegend *leg = new TLegend(0.67, 0.64, 0.87, 0.86);
    LegendStyle(leg);
    TString varLegName(var);
    varLegName.ReplaceAll("alpha_Sys","");
    varLegName.ReplaceAll("alpha_","");
    if(!plotRelative && d) { leg->AddEntry( d, "Data", "p" ); }
    leg->AddEntry( n, comp, "l" );
    leg->AddEntry( p1s, "+#sigma", "l" );
    leg->AddEntry( m1s, "-#sigma", "l" );
    leg->Draw();

    return canvas;
  } // DrawShift
  


  
  
  void PlotMorphingControlPlots(){
        
    cout << endl << "Plotting Systematic morphing control plots" << endl;    
    RooMsgService::instance().setGlobalKillBelow(ERROR);
    
    // Put all parameters to their iniital values
    if(!w->loadSnapshot("snapshot_paramsVals_initial")) { 
      cout << "Cannot load " <<  "snapshot_paramsVals_initial" << endl;
      exit(-1);
    }

    // Get the RooSimultaneous PDF
    RooSimultaneous *simPdf = (RooSimultaneous*)(mc->GetPdf());
    RooRealVar * firstPOI = dynamic_cast<RooRealVar*>(mc->GetParametersOfInterest()->first());
    double mu=0;
    firstPOI->setVal(mu);
    
    RooCategory* channelCat = (RooCategory*) (&simPdf->indexCat());
    TIterator* iter = channelCat->typeIterator() ;
    RooCatType* tt = NULL;    
    TString dirName("");
    while((tt=(RooCatType*) iter->Next()) ){
      
      cout << endl;
      cout << endl;
      cout << " -- On category " << tt->GetName() << " " << endl;
      ostringstream SubdirName;
      SubdirName << tt->GetName();
      TDirectory *SubDirChannel = (TDirectory*) MainDirMorphing->mkdir(SubdirName.str().c_str());
      gROOT->cd();
    
      // Get pdf associated with state from simpdf
      RooAbsPdf  *pdftmp  = simPdf->getPdf(tt->GetName()) ;
      RooArgSet  *obstmp  = pdftmp->getObservables( *mc->GetObservables() ) ;
      RooRealVar *obs     = ((RooRealVar*) obstmp->first());

      // First be sure that all nuisance parameters are nominal
      SetAllStatErrorToSigma(0.0);
      SetAllNuisanceParaToSigma(0.0);

      // Loop over nuisance params
      TIterator* it = mc->GetNuisanceParameters()->createIterator();
      RooRealVar* var = NULL;
      TString chanName(tt->GetName());
      while( (var = (RooRealVar*) it->Next()) ){

        string varname = (string) var->GetName();
        if ( varname.find("gamma_stat")!=string::npos ){
          continue;
        }

        if ( varname.find("ATLAS_norm")!=string::npos ){
          continue;
        }
        if ( varname.find("ATLAS_sampleNorm")!=string::npos ){
          continue;
        }

        // user friendly label / name
        TString varName(var->GetName());
        varName.ReplaceAll("alpha_Sys","");
        varName.ReplaceAll("alpha_","");

        // Not consider nuisance parameter being not assocaited to systematics
        if (MapNuisanceParamNom[varname]!=0.0 &&
            MapNuisanceParamNom[varname]!=1.0 ) continue;

	cout << endl;
        cout << "  -- On nuisance parameter : " << var->GetName() << endl; 
	TDirectory *SubDirNP = (TDirectory*) SubDirChannel->mkdir(varName);
	gROOT->cd();
       
        TString cname = "can_" + (TString)tt->GetName() + "_" + varName;
	TCanvas* c2 = new TCanvas( cname );
	c2->cd();
	TH1* hh = pdftmp->createHistogram("hh_"+cname,*obs,YVar(*var,Binning(60)) ) ;
	hh->SetLineColor(kBlue) ;
	hh->GetZaxis()->SetTitleOffset(2.5) ; hh->Draw("surf") ;

	SubDirNP->cd();
        c2->Write();
        c2->Close();
        gROOT->cd();

        // Loop over components and make these plots for each one
	TString modelName(tt->GetName());
	modelName.Append("_model");
	RooRealSumPdf *pdfmodel = (RooRealSumPdf*) (pdftmp->getComponents())->find(modelName);
	RooArgList funcList =  pdfmodel->funcList();
	RooLinkedListIter funcIter = funcList.iterator() ;
	RooProduct* comp = 0;
        while( (comp = (RooProduct*) funcIter.Next()) ) {
          TString compName(comp->GetName());
          compName.ReplaceAll("L_x_","");
          compName.ReplaceAll(chanName,"");
          compName.ReplaceAll("__overallSyst_x_StatUncert","");
          compName.ReplaceAll("__overallSyst_x_HistSyst","");
          compName.ReplaceAll("__overallSyst_x_Exp","");

	  // Fisrt be sure that all nuisance parameters are nominal
          SetAllStatErrorToSigma(0.0);
          SetAllNuisanceParaToSigma(0.0);
          SetPOI(1);	// set to one so do not ignore signal
	  
	  cname = "can_" + (TString)tt->GetName() + "_" + compName + "_" + varName;
	  TCanvas* c3 = new TCanvas( cname );
	  c2->cd();
	  
	  hh = comp->createHistogram("hh_"+cname,*obs,YVar(*var,Binning(60)) ) ;
	  hh->SetLineColor(kBlue) ;
	  hh->GetZaxis()->SetTitleOffset(2.5) ; hh->Draw("surf") ;
	  
	  SubDirNP->cd();
	  c3->Write();
	  c3->Close();
	  gROOT->cd();
	  
          // Put everything back to the nominal
          SetAllNuisanceParaToSigma(0.0);
          SetPOI(mu);

        } // loop over components
	
	
        // Put everything back to the nominal
        SetAllNuisanceParaToSigma(0.0);
        SetPOI(mu);
  
      }
    }
    
    return;
  }
  


  void PlotHistosAfterFitEachSubChannel(bool IsConditionnal, double mu){
    cout << endl << "Plotting Histos After Fit in Each Subchannel" << endl;
    
    // Prepare NP_i[after fit] vs category histogram
    map < TString,vector<NPContainer> > MapChannelNPs;

    // Put all parameters to their iniital values
    if(!w->loadSnapshot("snapshot_paramsVals_initial")) { 
      cout << "Cannot load " <<  "snapshot_paramsVals_initial" << endl;
      exit(-1);
    }

    // Conditionnal or unconditional fit
    TString TS_IsConditionnal;
    if (IsConditionnal) TS_IsConditionnal="conditionnal";
    else                TS_IsConditionnal="unconditionnal";
    RooRealVar * firstPOI = dynamic_cast<RooRealVar*>(mc->GetParametersOfInterest()->first());
    firstPOI->setVal(mu);

    ostringstream MaindirName;
    if (IsConditionnal) MaindirName << TS_IsConditionnal << "_MuIsEqualTo_" << mu;
    else                MaindirName << TS_IsConditionnal;
    TDirectory *MainDir =  (TDirectory*) MainDirFitEachSubChannel->mkdir(MaindirName.str().c_str());
    gROOT->cd();
    
    // Get the RooSimultaneous PDF
    RooSimultaneous *simPdf = (RooSimultaneous*)(mc->GetPdf());
    
    RooCategory* channelCat = (RooCategory*) (&simPdf->indexCat());
    TIterator *iter = channelCat->typeIterator() ;
    RooCatType *tt  = NULL;
    while((tt=(RooCatType*) iter->Next()) ){
     
      cout << endl;
      cout << endl;
      cout << " -- On category " << tt->GetName() << " " << endl;
      ostringstream SubdirName;
      SubdirName << tt->GetName();
      TDirectory *SubDirChannel = (TDirectory*) MainDir->mkdir(SubdirName.str().c_str());
      gROOT->cd();
         
      // Get pdf and datset associated to the studied channel
      RooAbsPdf  *pdftmp  = simPdf->getPdf( tt->GetName() );
      RooArgSet  *obstmp  = pdftmp->getObservables( *mc->GetObservables() ) ;
      RooAbsData *datatmp = data->reduce(Form("%s==%s::%s",channelCat->GetName(),channelCat->GetName(),tt->GetName()));
      RooRealVar *obs = ((RooRealVar*) obstmp->first());
      
      // Fit 
      if (IsConditionnal) firstPOI->setConstant();
      ROOT::Math::MinimizerOptions::SetDefaultStrategy(0);

      int status = -99;
      int HessStatus = -99;
      double Edm=-99;
      RooFitResult *fitres = FitPDF( mc, pdftmp, datatmp, status,HessStatus,Edm, "Minuit2", UseMinosError );
      TString FitName = (TString)tt->GetName() + "_" + TS_IsConditionnal + "_mu";
      FitName += mu;
      AllFitResults_map[FitName] = fitres;
      AllFitStatus_map[FitName] = status;
      cout << endl;
      cout << endl;
      if (IsConditionnal) cout << "Conditionnal fit : mu is fixed at " << mu << endl;
      else                cout << "Unconditionnal fit : mu is fitted" << endl;
      double muhat = firstPOI->getVal();
      firstPOI->setConstant(kFALSE);
  
      // Plotting the nuisance paramaters correlations during the fit
      TString cname1 = "can_NuisPara" + (TString)tt->GetName() + "_" + TS_IsConditionnal + "_mu";
      cname1 += mu;
      TCanvas* c1 = new TCanvas( cname1, cname1, 800, 800);
      c1->Divide(2,1);
      TString cname2 = "can_NormFactor" + (TString)tt->GetName() + "_" + TS_IsConditionnal + "_mu";
      cname2 += mu;
      TCanvas* c3 = new TCanvas( cname2, cname2, 650, 500);
      TH2D *h2Dcorrelation = (TH2D*) fitres->correlationHist(cname1);
      TString hname = "Corr_NuisPara_"+ (TString)tt->GetName() + "_"  + TS_IsConditionnal + "_mu";
      h2Dcorrelation->SetName(hname);
      c1->cd(1); 
//      h2Dcorrelation->DrawClone("col");
      h2Dcorrelation->SetMaximum(1.0);
      h2Dcorrelation->SetMinimum(-1.0);
      h2Dcorrelation->Draw("colz");


      // Plotting the nuisance paramaters after fit
      TString h1name = "h_NuisParaPull_" + (TString)tt->GetName() + "_" + TS_IsConditionnal + "_mu";
      h1name += mu;
      TString h2name = "h_NormFactor_" + (TString)tt->GetName() + "_" + TS_IsConditionnal + "_mu";
      h2name += mu;
      TIterator* it1 = mc->GetNuisanceParameters()->createIterator();
      RooRealVar* var = NULL;
      int Npar=0;
      int NparNotStat=0;
      int NparNormFactor=0;
      while( (var = (RooRealVar*) it1->Next()) ) {
	Npar++;
	string varname = (string) var->GetName();      
	if (varname.find("gamma_stat")==string::npos &&
	    !IsAnormFactor(var) ) NparNotStat++;
	if (IsAnormFactor(var)) NparNormFactor++;
      }
      NparNotStat=NparNotStat;
      TH1F * h1Dpull_axis = new TH1F(h1name,h1name,NparNotStat,0,NparNotStat);
      TGraphAsymmErrors *h1Dpull = new TGraphAsymmErrors(NparNotStat);
      h1Dpull->SetLineWidth(2);
      h1Dpull->SetLineColor(1);
      h1Dpull->SetMarkerColor(1);
      h1Dpull->SetMarkerStyle(21);
      h1Dpull->SetMarkerSize(1.2);      
      h1Dpull_axis->GetYaxis()->SetRangeUser(-5.5,5.5);
      h1Dpull_axis->GetXaxis()->SetTitle("#theta");
      h1Dpull_axis->GetYaxis()->SetTitle("(#theta_{fit} - #theta_{0}) / #Delta#theta");

      TH1F * hNormFactor_axis = new TH1F(h2name,h2name,NparNormFactor,0,NparNormFactor);
      TGraphAsymmErrors *hNormFactor = new TGraphAsymmErrors(NparNormFactor);
      hNormFactor->SetLineWidth(2);
      hNormFactor->SetLineColor(1);
      hNormFactor->SetMarkerColor(1);
      hNormFactor->SetMarkerStyle(21);
      hNormFactor->SetMarkerSize(1.2);      
      hNormFactor_axis->GetYaxis()->SetRangeUser(0.8,1.2);
      hNormFactor_axis->GetXaxis()->SetTitle("Normalization factor");
      hNormFactor_axis->GetYaxis()->SetTitle("Post fit value");

      // Create a latex table of NPs after fit
      vector <NPContainer> MyNPContainerVector; MyNPContainerVector.clear();
      TString fname = OutputDir + "/LatexFileNPs/Fit"+(TString)tt->GetName()+"_nuisPar_"+TS_IsConditionnal+"_mu";
      fname += mu;
      fname += ".tex";
      ofstream fnuisPar(fname.Data());
      TString fnuiscorr = OutputDir + "/TextFileFitResult/Fit"+(TString)tt->GetName()+"_fitres_"+TS_IsConditionnal+"_mu";
      fnuiscorr += mu;
      fnuiscorr += ".txt";
      ofstream fnuisParAndCorr(fnuiscorr.Data());
      fnuisParAndCorr << "NUISANCE_PARAMETERS" << endl;
      
      fnuisPar << endl;
      fnuisPar << "\\begin{tabular}{|l|c|}" << endl;
      fnuisPar << "\\hline" << endl;
      fnuisPar << "Nuisance parameter & postfit value (in $\\sigma$ unit) \\\\\\hline" << endl;

      if(!IsConditionnal){
	fnuisPar.precision(3);
	fnuisPar << "$\\mu$ & $" << firstPOI->getVal() << "^{+" << firstPOI->getErrorHi() << "}_{-" << fabs(firstPOI->getErrorLo()) << "}$ \\\\" << endl;
	
	NPContainer MyNPTemp;
	MyNPTemp.NPname  = "#mu";
	MyNPTemp.NPvalue = firstPOI->getVal();
	MyNPTemp.NPerrorLo = firstPOI->getErrorLo();
	MyNPTemp.NPerrorHi = firstPOI->getErrorHi();
	MyNPContainerVector.push_back(MyNPTemp);
      }
      

      vector<TGraphAsymmErrors*> vec_MyGraph;
      vec_MyGraph.clear();
      int ibNPs=0;
      int ibNormFactor=0;
      TIterator* it2 = mc->GetNuisanceParameters()->createIterator();
      while( (var = (RooRealVar*) it2->Next()) ){

	// Not consider nuisance parameter being not associated to syst
	string varname = (string) var->GetName();
	if ( (varname.find("gamma_stat")!=string::npos) ) continue;
	
	double pull  = var->getVal() / 1.0 ; // GetValue() return value in unit of sigma
	double errorHi = var->getErrorHi() / 1.0; 
	double errorLo = var->getErrorLo() / 1.0; 
	
	if(strcmp(var->GetName(),"Lumi")==0){
	  pull  = (var->getVal() - w->var("nominalLumi")->getVal() ) / (w->var("nominalLumi")->getVal() * LumiRelError );
	  errorHi = var->getErrorHi() / (w->var("nominalLumi")->getVal() * LumiRelError);
	  errorLo = var->getErrorLo() / (w->var("nominalLumi")->getVal() * LumiRelError); 
	}
	
	TString vname=var->GetName();
	vname.ReplaceAll("alpha_","");
	vname.ReplaceAll("gamma_","");
	vname.ReplaceAll("Lumi","Luminosity");
	vname.ReplaceAll("_","\\_");
	fnuisPar.precision(3);
	fnuisPar << vname << " & $" << pull << "^{+" << fabs(errorHi) << "}_{-" << fabs(errorLo)  << "}$ \\\\" << endl;
	fnuisParAndCorr << vname << " & $" << pull << "^{+ " << fabs(errorHi) << "}_{-" << fabs(errorLo)  << "}$ \\\\" << endl;
	
	NPContainer MyNPsTemp;
	MyNPsTemp.NPname  = vname;
	MyNPsTemp.NPvalue = pull;
	MyNPsTemp.NPerrorHi = errorHi;
	MyNPsTemp.NPerrorLo = errorLo;
	MyNPContainerVector.push_back(MyNPsTemp);

	MyNPsTemp.WhichFit = TS_IsConditionnal+"_FitOnChannel_"+(TString)tt->GetName()+"_Mu";
	MyNPsTemp.WhichFit += mu;
	if (!IsAnormFactor(var)) AllNPafterEachFit_vec.push_back(MyNPsTemp);

	
	TString vname2=var->GetName();
	vname2.ReplaceAll("alpha_","");
	vname2.ReplaceAll("gamma_","");
	vname2.ReplaceAll("ATLAS_","");
	
	if (IsAnormFactor(var)){
	  ibNormFactor++;
	  double xcNF = hNormFactor_axis->GetBinCenter(ibNormFactor);
	  hNormFactor_axis->GetXaxis()->SetBinLabel(ibNormFactor,vname2);
	  hNormFactor->SetPoint(ibNormFactor-1,xcNF,pull);
	  hNormFactor->SetPointEXlow(ibNormFactor-1 ,hNormFactor_axis->GetBinWidth(ibNormFactor)/3.0);
	  hNormFactor->SetPointEXhigh(ibNormFactor-1,hNormFactor_axis->GetBinWidth(ibNormFactor)/3.0);
	  hNormFactor->SetPointEYlow(ibNormFactor-1 ,fabs(errorLo));
	  hNormFactor->SetPointEYhigh(ibNormFactor-1,fabs(errorHi));
	} else {
	  ibNPs++;
	  double xc = h1Dpull_axis->GetBinCenter(ibNPs);
	  h1Dpull_axis->GetXaxis()->SetBinLabel(ibNPs,vname2);
	  h1Dpull->SetPoint(ibNPs-1,xc,pull);
	  h1Dpull->SetPointEXlow(ibNPs-1 ,h1Dpull_axis->GetBinWidth(ibNPs)/3.0);
	  h1Dpull->SetPointEXhigh(ibNPs-1,h1Dpull_axis->GetBinWidth(ibNPs)/3.0);
	  h1Dpull->SetPointEYlow(ibNPs-1 ,fabs(errorLo));
	  h1Dpull->SetPointEYhigh(ibNPs-1,fabs(errorHi));
	
	  // Put in red NP with pull>1.5 OR Err<0.2, in black otherwise
	  bool IsTooPulled = fabs(pull)>PullMaxAcceptable;
	  bool IsOverConst = (fabs(errorLo)+fabs(errorHi))/2.0<ErrorMinAcceptable;
	  bool IsOnesided  = UseMinosError && (errorHi==0 || errorLo==0);
	  if (IsTooPulled || IsOverConst || IsOnesided){
	    TGraphAsymmErrors *myGraph = new TGraphAsymmErrors(1);
	    myGraph->SetLineWidth(2);
	    myGraph->SetLineColor(kRed+1);
	    myGraph->SetMarkerColor(kRed+1);
	    myGraph->SetMarkerStyle(21);
	    myGraph->SetMarkerSize(1.2); 
	    myGraph->SetPoint(0,xc,pull);
	    myGraph->SetPointEXlow(0 ,h1Dpull_axis->GetBinWidth(ibNPs)/3.0);
	    myGraph->SetPointEXhigh(0,h1Dpull_axis->GetBinWidth(ibNPs)/3.0);
	    myGraph->SetPointEYlow(0 ,fabs(errorLo));
	    myGraph->SetPointEYhigh(0,fabs(errorHi));
	    vec_MyGraph.push_back(myGraph);	
	  }
	}

      }

      MapChannelNPs[(TString)tt->GetName()] = MyNPContainerVector;

      fnuisPar << "\\hline" << endl;
      fnuisPar << "\\end{tabular}" << endl;
      fnuisPar.close();
      
      fnuisParAndCorr << endl << endl << "CORRELATION_MATRIX" << endl;
      fnuisParAndCorr << h2Dcorrelation->GetNbinsX() << "   " << h2Dcorrelation->GetNbinsY() << endl;
      for(int kk=1; kk < h2Dcorrelation->GetNbinsX()+1; kk++) {
	for(int ll=1; ll < h2Dcorrelation->GetNbinsY()+1; ll++) {
	  fnuisParAndCorr << h2Dcorrelation->GetBinContent(kk,ll) << "   ";
	}
	fnuisParAndCorr << endl;
      }
      fnuisParAndCorr << endl;
      fnuisParAndCorr.close();
      
      
      double _1SigmaValue[1000];
      double _2SigmaValue[1000];
      double NuisParamValue[1000];
      for (int i=0 ; i<NparNotStat+1 ; i++){
	_1SigmaValue[i] = 1.0;
	_1SigmaValue[2*NparNotStat-i] = -1;
	_2SigmaValue[i] = 2;
	_2SigmaValue[2*NparNotStat-i] = -2;
	NuisParamValue[i] = i;
	NuisParamValue[2*NparNotStat-1-i] = i;
      }

      TGraph *_1sigma = new TGraph(2*NparNotStat,NuisParamValue,_1SigmaValue);
      TGraph *_2sigma = new TGraph(2*NparNotStat,NuisParamValue,_2SigmaValue);
      c1->cd();
      //c1->cd(2); 
      _2sigma->SetFillColor(5);
      _2sigma->SetLineColor(5);
      _2sigma->SetMarkerColor(5);
      _1sigma->SetFillColor(3);
      _1sigma->SetLineColor(3);
      _1sigma->SetMarkerColor(3);
      h1Dpull_axis->Draw("hist");
      _2sigma->Draw("F"); 
      _1sigma->Draw("F"); 
      h1Dpull->Draw("P");
      for (unsigned i=0 ; i<vec_MyGraph.size() ; i++) vec_MyGraph[i]->Draw("P");
      h1Dpull_axis->GetYaxis()->DrawClone();
      

      TLatex text;
      text.SetNDC();
      text.SetTextSize( 0.054);
      text.SetTextAlign(31);
      TString WritDownMuValue;
      if(!IsConditionnal) WritDownMuValue = "#mu_{best} = ";
      else                WritDownMuValue = "#mu_{fixed} = ";
      WritDownMuValue += Form("%2.2f",firstPOI->getVal());
      c1->cd();
      //c1->cd(2); 
      text.DrawLatex( 0.87,0.81, WritDownMuValue );
      TString statusText="Minuit status:" ;
      statusText+=status;
      text.DrawLatex( 0.45,0.85, statusText);  
      statusText="Hess status:" ;
      statusText+=HessStatus;
      text.DrawLatex( 0.45,0.78, statusText);
      statusText="Edm=" ;
      statusText+=Form("%1.4f",Edm);;
      text.DrawLatex( 0.45,0.71, statusText);
      if(status!=0 && status!=1) {
	statusText="#color[2]{Unconverged Fit}" ;
	text.DrawLatex( 0.87,0.71, statusText);
      }

      c3->cd();
      hNormFactor_axis->Draw("hist");
      hNormFactor->Draw("P");
      text.DrawLatex( 0.87,0.81, WritDownMuValue );

      // Plotting the likelihood projection in each NP direction
      TDirectory *NLLprojection = (TDirectory*) SubDirChannel->mkdir("AllNNLProjections");
      gROOT->cd();
      RooAbsReal* nll = pdftmp->createNLL(*datatmp);
      if (!IsConditionnal){
	var = (RooRealVar*) firstPOI;
	TString vname=var->GetName();
	vname.ReplaceAll("alpha_","");
	vname.ReplaceAll("gamma_","");
	vname.ReplaceAll("ATLAS_","");
	RooPlot* frame2 = var->frame(Title("-log(L) vs "+vname));
	nll->plotOn(frame2,LineColor(kRed),ShiftToZero()) ;
	frame2->GetYaxis()->SetRangeUser(0.0,5.0);
	frame2->GetYaxis()->SetTitle("#Delta [-2Log(L)]");
	TCanvas *can2 = new TCanvas( "NLLscan_"+vname );
	can2->cd();
	frame2->Draw();
	NLLprojection->cd();
	can2->Write();
	gROOT->cd();
      }
      TIterator* it3 = mc->GetNuisanceParameters()->createIterator();
      while( (var = (RooRealVar*) it3->Next()) ){
	TString vname=var->GetName();
	if (vname.Contains("gamma_stat")) continue;
	vname.ReplaceAll("alpha_","");
	vname.ReplaceAll("gamma_","");
	vname.ReplaceAll("ATLAS_","");
	RooPlot* frame2 = var->frame(Title("-log(L) vs "+vname)) ;
	nll->plotOn(frame2,LineColor(kRed),ShiftToZero()) ;
	frame2->GetYaxis()->SetRangeUser(0.0,5.0);
	frame2->GetYaxis()->SetTitle("#Delta [-2Log(L)]");
	TCanvas *can2 = new TCanvas( "NLLscan_"+vname );
	can2->cd();
	frame2->Draw();
	NLLprojection->cd();
	can2->Write();
	gROOT->cd();
      }
      
      
      // Bin Width
      RooRealVar* binWidth = ((RooRealVar*) pdftmp->getVariables()->find(Form("binWidth_obs_x_%s_0",tt->GetName()))) ;
      if(!binWidth) { cout << "No bin width " << tt->GetName() << endl; }
      cout << "    Bin Width : " << binWidth->getVal() << endl;     

      // Plotting the distributions
      TString cname = "can_DistriAfterFit_" + (TString)tt->GetName() + "_" + TS_IsConditionnal + "_mu";
      cname += mu;
      TCanvas* c2 = new TCanvas( cname );
      RooPlot* frame = obs->frame();
      TString FrameName = "Plot_" + (TString)tt->GetName() + "_FitIsconditional" + (TString) IsConditionnal;
      frame->SetName( FrameName );
      frame->SetYTitle("EVENTS");
      float postFitIntegral = pdftmp->expectedEvents(*obs);
      datatmp->plotOn(frame,MarkerSize(1),Name("Data"),DataError(RooAbsData::Poisson) );
      pdftmp->plotOn(frame,FillColor(kOrange),LineWidth(2),LineColor(kBlue),VisualizeError(*fitres,1),
		     Normalization(postFitIntegral,RooAbsReal::NumEvent),Name("FitError_NotAppears"));
      pdftmp->plotOn(frame,LineWidth(2),Normalization(postFitIntegral,RooAbsReal::NumEvent),Name("CentralFit_NotAppears"));
      double chi2  = frame->chiSquare();
      double chi2_prefit = -99;

      // miniloop over componant to make a bkg stack
      TString modelName1(tt->GetName());
      modelName1.Append("_model");
      RooRealSumPdf *pdfmodel1 = (RooRealSumPdf*) (pdftmp->getComponents())->find(modelName1);
      RooArgList funcList1 =  pdfmodel1->funcList();
      RooLinkedListIter funcIter1 = funcList1.iterator() ;
      RooProduct* comp1 = 0;
      firstPOI->setVal(0.);
      int ibkg=0;
      int icolor=0;
      TString previous="";
      while( (comp1 = (RooProduct*) funcIter1.Next()) ) {
	ibkg++;

	int color= kGray;

	TString compname(comp1->GetName());
	compname.ReplaceAll("L_x_","");
        compname.ReplaceAll(tt->GetName(),"");
        compname.ReplaceAll("_overallSyst_x_StatUncert","");
        compname.ReplaceAll("_overallSyst_x_HistSyst","");
        compname.ReplaceAll("_overallSyst_x_Exp","");
	compname.ReplaceAll("_","");
	double Ntemp = (comp1->createIntegral(*obs))->getVal() * binWidth->getVal();
	if (Ntemp!=0){
	  icolor++;
	  if(icolor==1) { color = kOrange - 3; }
	  else if(icolor==2) { color = kCyan + 1; }
	  else if(icolor==3) { color = kGreen - 9; }
	  else if(icolor==4) { color = kAzure - 9; }
	  else if(icolor==5) { color = kOrange + 10;}
	  else if(icolor==6) { color = kGreen - 6; }
	  else if(icolor==7) { color = kAzure - 4; }
	  else if(icolor==8) { color = kOrange + 6; }
	  else if(icolor==9) { color = kGreen + 1; }
	  else if(icolor==10) { color = kAzure + 2; }
	  else if(icolor==11) { color = kOrange; }
	  else if(icolor==12) { color = kGreen + 3; }
	  else if(icolor==13) { color = kAzure - 4; }
	  else if(icolor==14) { color = kOrange; }
	  else if(icolor==15) { color = kGreen + 1; }
	  else if(icolor==16) { color = kOrange - 7; }
	  else if(icolor==17) { color = kPink + 1; }
	  else   color=icolor;

	  // Get the signal x 1 in white (for further purposes)
	  if (IsConditionnal) firstPOI->setVal(1.0);
	  Ntemp=(comp1->createIntegral(*obs))->getVal() * binWidth->getVal();
	  pdfmodel1->plotOn(frame,LineWidth(0),Components(*comp1),LineColor(0), LineStyle(3), Normalization(Ntemp,RooAbsReal::NumEvent),Name("NoStacked_"+compname));
	  if (IsConditionnal) firstPOI->setVal(mu);

	  // Get the stack of background
	  Ntemp=(comp1->createIntegral(*obs))->getVal() * binWidth->getVal();
	  pdfmodel1->plotOn(frame,LineWidth(0),Components(*comp1),LineColor(0), Normalization(Ntemp,RooAbsReal::NumEvent),Name("NoStacked"+compname));
	  if (ibkg==0) pdfmodel1->plotOn(frame,LineWidth(2),Components(*comp1),LineColor(color), Normalization(Ntemp,RooAbsReal::NumEvent),Name("Stacked_"+compname));
	  else         pdfmodel1->plotOn(frame,LineWidth(2),Components(*comp1),LineColor(color), Normalization(Ntemp,RooAbsReal::NumEvent),Name("Stacked_"+compname),AddTo(previous));
	  previous="Stacked_"+compname;
	}
      }
      firstPOI->setVal(muhat);
      pdftmp->plotOn(frame,FillColor(kOrange),LineWidth(2),LineColor(kBlue),VisualizeError(*fitres,1),
		     Normalization(postFitIntegral,RooAbsReal::NumEvent),Name("FitError_AfterFit"));
      pdftmp->plotOn(frame,LineWidth(2),Normalization(postFitIntegral,RooAbsReal::NumEvent),Name("FitCentral2_NotAppears"));
      datatmp->plotOn(frame,MarkerSize(1),Name("Dat_NotAppears"),DataError(RooAbsData::Poisson));

      // Putting nuisance parameter at the central value and draw the nominal distri
      SetAllStatErrorToSigma(0.0);
      SetAllNuisanceParaToSigma(0.0);
      if (!IsConditionnal) SetPOI(0.0);
      else                 SetPOI(mu);
      TString muValueBeforeFitLegend = Form("Before fit (#mu=%2.2f)",firstPOI->getVal());
      pdftmp->plotOn(frame,LineWidth(2),Name("BeforeFit"),LineStyle(kDashed),Normalization(pdftmp->expectedEvents(*obs),RooAbsReal::NumEvent));      
      chi2_prefit  = frame->chiSquare();

      
      TString modelName2(tt->GetName());
      modelName2.Append("_model");
      RooRealSumPdf *pdfmodel2 = (RooRealSumPdf*) (pdftmp->getComponents())->find(modelName2);
      RooArgList funcList2 =  pdfmodel2->funcList();
      RooLinkedListIter funcIter2 = funcList2.iterator() ;
      RooProduct* comp2 = 0;
      if (!IsConditionnal) firstPOI->setVal(muhat);
      else                 firstPOI->setVal(mu);
      ibkg=0;
      icolor=0;
      while( (comp2 = (RooProduct*) funcIter2.Next()) ) {
	ibkg++;
	int color=kGray;
	TString compname(comp2->GetName());
	compname.ReplaceAll("L_x_","");
        compname.ReplaceAll(tt->GetName(),"");
        compname.ReplaceAll("_overallSyst_x_StatUncert","");
        compname.ReplaceAll("_overallSyst_x_HistSyst","");
        compname.ReplaceAll("_overallSyst_x_Exp","");
	compname.ReplaceAll("_","");
	double Ntemp = (comp2->createIntegral(*obs))->getVal() * binWidth->getVal();
	if (Ntemp!=0){
	  icolor++;
	  if(icolor==1) { color = kOrange - 3; }
	  else if(icolor==2) { color = kCyan + 1; }
	  else if(icolor==3) { color = kGreen - 9; }
	  else if(icolor==4) { color = kAzure - 9; }
	  else if(icolor==5) { color = kOrange + 10;}
	  else if(icolor==6) { color = kGreen - 6; }
	  else if(icolor==7) { color = kAzure - 4; }
	  else if(icolor==8) { color = kOrange + 6; }
	  else if(icolor==9) { color = kGreen + 1; }
	  else if(icolor==10) { color = kAzure + 2; }
	  else if(icolor==11) { color = kOrange; }
	  else if(icolor==12) { color = kGreen + 3; }
	  else if(icolor==13) { color = kAzure - 4; }
	  else if(icolor==14) { color = kOrange; }
	  else if(icolor==15) { color = kGreen + 1; }
	  else if(icolor==16) { color = kOrange - 7; }
	  else if(icolor==17) { color = kPink + 1; }
	  else   color=icolor;
	  pdfmodel2->plotOn(frame,LineWidth(0),Components(*comp2),LineColor(0), LineStyle(3), Normalization(Ntemp,RooAbsReal::NumEvent),Name("NoStacked_BkgBeforeFit_"+compname));
	}
      }
      if (!IsConditionnal) firstPOI->setVal(muhat);
      else                 firstPOI->setVal(mu);

      c2->cd();
      frame->Draw();
      text.DrawLatex( 0.84,0.81, WritDownMuValue );
      TString ts_chi2 = Form("Post-fit #chi^{2}=%1.1f",chi2);
      text.DrawLatex( 0.22, 0.83, ts_chi2 );
      ts_chi2 = Form("Pre-fit #chi^{2}=%1.1f",chi2_prefit);
      text.DrawLatex( 0.22, 0.73, ts_chi2 );
      
      TLegend *leg = new TLegend(0.54,0.40,0.77,0.76);
      leg->SetBorderSize(0);
      leg->SetFillColor(0);
      leg->SetTextFont(62);
      leg->SetTextSize(0.050);
      for (int i=0; i<frame->numItems(); i++) {
	TString obj_name=frame->nameOf(i); 
        if (obj_name=="" || obj_name.Contains("NotAppears") || obj_name.Contains("NoStacked") ) continue;
        TObject *obj = frame->findObject(obj_name.Data());
        if (((string)obj_name).find("Data")   !=string::npos) { leg->AddEntry( obj , "Data" , "p"); continue; }
	TString legname;
	if (!IsConditionnal) legname = "After fit (#mu[best] S+B)";
	else                 legname = "After fit (#mu[fixed] S+B)";
        if (((string)obj_name).find("AfterFit")!=string::npos){ leg->AddEntry( obj , legname , "lf"); continue; }
	legname = muValueBeforeFitLegend;
	if (((string)obj_name).find("BeforeFit")!=string::npos){leg->AddEntry( obj ,legname , "l"); continue;}
	
	obj_name.ReplaceAll("Stacked_","");
	leg->AddEntry(obj,obj_name,"l");
      }	  
      leg->Draw();
            

      // Save plots in outputfile
      SubDirChannel->cd();
      c1->Write();
      c2->Write();
      c3->Write();
      c1->Close();
      c2->Close();
      c3->Close();
      gROOT->cd();          
    }


    // Plots of each NP[posfit] vs subchannel
    int Nchannel=0;
    int Nsyst;
    vector<NPContainer> NPvecForName;
    TIterator *iter1 = channelCat->typeIterator() ;
    RooCatType *tt1  = NULL;
    while((tt1=(RooCatType*) iter1->Next()) ){
      Nchannel++;
      if (Nchannel==1) NPvecForName = MapChannelNPs[(TString)tt1->GetName()];
    }
    Nsyst = NPvecForName.size();
    for (int isys=0 ; isys<Nsyst ; isys++){
      TString hname = NPvecForName[isys].NPname;
      hname.ReplaceAll("\\_","_");

      TH1F * hsys_axis = new TH1F(hname,hname,Nchannel,0,Nchannel);
      TGraphAsymmErrors *hsys = new TGraphAsymmErrors(Nchannel);
      hsys_axis->GetYaxis()->SetRangeUser(-5.5,5.5);
      hsys_axis->GetXaxis()->SetTitle("#theta");
      hsys_axis->GetYaxis()->SetTitle("(#theta_{fit} - #theta_{0}) / #Delta#theta");

      TString cname = "can_"+ hname;
      cname.ReplaceAll("#","");
      cname.ReplaceAll("(","");
      cname.ReplaceAll(")","");
      cname.ReplaceAll("=","");
      TCanvas* can = new TCanvas( cname, cname , 600, 500);

      TIterator *iter2 = channelCat->typeIterator() ;
      RooCatType *tt2  = NULL;
      int ich=0;
      while((tt2=(RooCatType*) iter2->Next()) ){
	ich++;
	vector<NPContainer> NPvec = MapChannelNPs[(TString)tt2->GetName()];
	double NPval   = NPvec[isys].NPvalue;
	double NPerrHi = NPvec[isys].NPerrorHi;
	double NPerrLo = NPvec[isys].NPerrorLo;

	double xc = hsys_axis->GetBinCenter(ich);
	hsys->SetPoint(ich-1,xc,NPval);
	hsys->SetPointEXlow(ich-1,hsys_axis->GetBinWidth(ich)/3.0);
	hsys->SetPointEXhigh(ich-1,hsys_axis->GetBinWidth(ich)/3.0);
	hsys->SetPointEYlow(ich-1,fabs(NPerrLo));
	hsys->SetPointEYhigh(ich-1,fabs(NPerrHi));
	hsys_axis->GetXaxis()->SetBinLabel(ich,tt2->GetName());	
      }

      double _1SigmaValue[1000];
      double _2SigmaValue[1000];
      double NuisParamValue[1000];
      for (int i=0 ; i<Nchannel+1 ; i++){
	_1SigmaValue[i] = 1.0;
	_1SigmaValue[2*Nchannel-i] = -1;
	_2SigmaValue[i] = 2;
	_2SigmaValue[2*Nchannel-i] = -2;
	NuisParamValue[i] = i;
	NuisParamValue[2*Nchannel-1-i] = i;
      }
      
      TGraph *_1sigma = new TGraph(2*Nchannel,NuisParamValue,_1SigmaValue);
      TGraph *_2sigma = new TGraph(2*Nchannel,NuisParamValue,_2SigmaValue);
      can->cd(); 
      hsys->SetLineWidth(2);
      hsys->SetLineColor(1);
      hsys->SetMarkerColor(1);
      hsys->SetMarkerStyle(21);
      hsys->SetMarkerSize(1.2);      
      _2sigma->SetFillColor(5);
      _2sigma->SetLineColor(5);
      _2sigma->SetMarkerColor(5);
      _1sigma->SetFillColor(3);
      _1sigma->SetLineColor(3);
      _1sigma->SetMarkerColor(3);
      hsys_axis->GetYaxis()->SetRangeUser(-5.0,5.0);
      hsys_axis->Draw("hist");
      if (NPvecForName[isys].NPname != "#mu"){
	_2sigma->Draw("F"); 
	_1sigma->Draw("F"); 
      }
      hsys->Draw("P");
      MainDir->cd();
      can->Write();
      can->Close();
      gROOT->cd();           
    }
       
    return;
  }


  void PlotHistosAfterFitGlobal(bool IsConditionnal, double mu){
    
    // Put all parameters to their iniital values
    if(!w->loadSnapshot("snapshot_paramsVals_initial")) { 
      cout << "Cannot load " <<  "snapshot_paramsVals_initial" << endl;
      exit(-1);
    }

    // Conditionnal or unconditional fit
    TString TS_IsConditionnal;
    if (IsConditionnal) TS_IsConditionnal="conditionnal";
    else                TS_IsConditionnal="unconditionnal";

    RooRealVar * firstPOI = dynamic_cast<RooRealVar*>(mc->GetParametersOfInterest()->first());
    firstPOI->setVal(mu);
    
    ostringstream MaindirName;
    if (IsConditionnal) MaindirName << TS_IsConditionnal << "_MuIsEqualTo_" << mu;
    else                MaindirName << TS_IsConditionnal;
    TDirectory *MainDir =  (TDirectory*) MainDirFitGlobal->mkdir(MaindirName.str().c_str());
    gROOT->cd();

    // Get the RooSimultaneous PDF
    RooSimultaneous *simPdf = (RooSimultaneous*)(mc->GetPdf());

    // Fit 
    if (IsConditionnal) firstPOI->setConstant();


    /*********** HACK TO MODIFY THE RANGE OF GAMMA_ABCD NPs ***********/
    /*TIterator* it0 = mc->GetNuisanceParameters()->createIterator();
    RooRealVar* var0 = NULL;
    while( (var0 = (RooRealVar*) it0->Next()) ) {
    TString varname = var0->GetName();      
    if ( varname.Contains("gamma_ATLAS_shape_LH_ABCD_tau") ) var0->setRange(0.0,10.0) ;
    }*/



    ROOT::Math::MinimizerOptions::SetDefaultStrategy(0);
    int status = -99;
    int HessStatus = -99;
    double Edm=-99;
    RooFitResult  *fitresGlobal = FitPDF( mc, simPdf, data, status, HessStatus, Edm, "Minuit2", UseMinosError );
    TString FitName = "GlobalFit_" + TS_IsConditionnal + "_mu";
    FitName += mu;
    AllFitResults_map[FitName] = fitresGlobal;
    AllFitStatus_map[FitName] = status;
    const RooArgSet *ParaGlobalFit = mc->GetNuisanceParameters();
    w->saveSnapshot("snapshot_paramsVals_GlobalFit",*ParaGlobalFit);
    double muhat = firstPOI->getVal();
    firstPOI->setConstant(kFALSE);

    
    if (IsConditionnal) cout << "Conditionnal fit : mu is fixed at " << mu << endl;
    else                cout << "Unconditionnal fit : mu is fitted" << endl;
    fitresGlobal->Print("v");
    
    // PLotting the nuisance paramaters correlations during the fit
    TString cname = "can_NuisPara_GlobalFit_" + TS_IsConditionnal + "_mu";
    cname += mu;

    cout << "==========================   " << cname << endl;

    TCanvas* c1 = new TCanvas( cname, cname, 1260, 800);
    c1->SetBottomMargin( 0.4 );
    TString cname0 = "can_NuisPara_GlobalFit_" + TS_IsConditionnal + "_mu_TEST";
    TCanvas* c0 = new TCanvas( cname0, cname0, 5000, 5000);
    c0->cd();
    c0->SetBottomMargin(1.3);
    c0->SetRightMargin(0.9);
    c0->SetLeftMargin(1.3);

    //c1->Divide(2,1);
    TH2D *h2Dcorrelation = (TH2D*) fitresGlobal->correlationHist();
    TString hname = "Corr_NuisPara_GlobalFit_" + TS_IsConditionnal + "_mu";
    h2Dcorrelation->SetName(hname);
    //c1->cd(1); 
    h2Dcorrelation->Draw("colz");

    //Reduced Corr Matrix
    TH2D *h2cm =  (TH2D*) fitresGlobal->correlationHist();
    const int px = h2cm->GetXaxis()->GetNbins();
    const int py = h2cm->GetYaxis()->GetNbins();
    
    TH2D *h2ncm = new TH2D( "CorrelationMartixNew", "", px, 0., px, py, 0, py ); 
    
    double valz;
    string valx, valy;
    int nx = 0, ny = 0;
    
    for( int i1 = 0; i1 < px; i1++ ){
      valx = h2cm->GetXaxis()->GetBinLabel(i1+1);
      if( valx.find("_bin_") < valx.length() )
        continue;
      nx++;
      ny = 0;
      //
      for( int i2 = 0; i2 < py; i2++ ){
        valy = h2cm->GetYaxis()->GetBinLabel(i2+1);
        if( valy.find("_bin_") < valy.length() )
          continue;
        //
        ny++;
        //
        valz = h2cm->GetBinContent(i1+1, i2+1);
        //cout<<"debug "<<i1<<" "<<i2<<" "<<nx<<" "<<ny<<" "<<valz<<endl;

        h2ncm->SetBinContent( nx, ny,  valz );
        h2ncm->GetXaxis()->SetBinLabel( nx, valx.c_str() );
        h2ncm->GetYaxis()->SetBinLabel( ny, valy.c_str() );
      }
    } 
    h2ncm->GetXaxis()->SetRangeUser( 0, nx );
    h2ncm->GetYaxis()->SetRangeUser( 0, ny );
    h2ncm->GetXaxis()->SetLabelSize(0.02);
    h2ncm->GetYaxis()->SetLabelSize(0.02);
    h2ncm->Draw("colz");
    
    //
    TString cname2 = "can_NormFactor_GlobalFit_" + TS_IsConditionnal + "_mu";
    cname2 += mu;
    TCanvas* c3 = new TCanvas( cname2, cname2, 650, 500);

    // PLotting the nuisance paramaters correlations during the fit
    TString h1name = "h_NuisParaPull_GlobalFit_" + TS_IsConditionnal + "_mu";
    h1name += mu;
    TString h2name = "h_NormFactor_GlobalFit_" + TS_IsConditionnal + "_mu";
    h2name += mu;
    TIterator* it1 = mc->GetNuisanceParameters()->createIterator();
    RooRealVar* var = NULL;
    int Npar=0;
    int NparNotStat=0;
    int NparNormFactor=0;
    while( (var = (RooRealVar*) it1->Next()) ) {
      Npar++;
      string varname = (string) var->GetName();      
      if (varname.find("gamma_stat")==string::npos && !IsAnormFactor(var)) NparNotStat++;
      if (IsAnormFactor(var)) NparNormFactor++;
    }

    TH1F * h1Dpull_axis = new TH1F(h1name,h1name,NparNotStat,0,NparNotStat);
    TGraphAsymmErrors *h1Dpull = new TGraphAsymmErrors(NparNotStat);
    h1Dpull->SetLineWidth(2);
    h1Dpull->SetLineColor(1);
    h1Dpull->SetMarkerColor(1);
    h1Dpull->SetMarkerStyle(21);
    h1Dpull->SetMarkerSize(1.2);      
    h1Dpull_axis->GetYaxis()->SetRangeUser(-5.5,5.5);
    h1Dpull_axis->GetXaxis()->LabelsOption("v");
    h1Dpull_axis->GetXaxis()->SetTitle("#theta");
    h1Dpull_axis->GetYaxis()->SetTitle("(#theta_{fit} - #theta_{0}) / #Delta#theta");
    
    TH1F * hNormFactor_axis = new TH1F(h2name,h2name,NparNormFactor,0,NparNormFactor);
    TGraphAsymmErrors *hNormFactor = new TGraphAsymmErrors(NparNormFactor);
    hNormFactor->SetLineWidth(2);
    hNormFactor->SetLineColor(1);
    hNormFactor->SetMarkerColor(1);
    hNormFactor->SetMarkerStyle(21);
    hNormFactor->SetMarkerSize(1.2);      
    hNormFactor_axis->GetYaxis()->SetRangeUser(0.8,1.2);
    hNormFactor_axis->GetXaxis()->SetTitle("Normalization factor");
    hNormFactor_axis->GetYaxis()->SetTitle("Post fit value");
    
    
    // Create a latex table of NPs after fit
    TString fname = OutputDir + "/LatexFileNPs/GlobalFit_nuisPar_"+TS_IsConditionnal+"_mu";
    fname += mu;
    fname += ".tex";
    ofstream fnuisPar(fname.Data());
    TString fnuiscorr = OutputDir + "/TextFileFitResult/GlobalFit_fitres_"+TS_IsConditionnal+"_mu";
    fnuiscorr += mu;
    fnuiscorr += ".txt";
    ofstream fnuisParAndCorr(fnuiscorr.Data());
    fnuisParAndCorr << "NUISANCE_PARAMETERS" << endl;

    fnuisPar << endl;
    fnuisPar << "\\begin{tabular}{|l|c|}" << endl;
    fnuisPar << "\\hline" << endl;
    fnuisPar << "Nuisance parameter & postfit value (in $\\sigma$ unit) \\\\\\hline" << endl;

    if(!IsConditionnal){
      fnuisPar.precision(3);
      fnuisPar << "$\\mu$ & $" << firstPOI->getVal() << "^{+" << firstPOI->getErrorHi() << "}_{-" << fabs(firstPOI->getErrorLo()) << "}$ \\\\" << endl;
    }
    
    vector<TGraphAsymmErrors*> vec_MyGraph;
    vec_MyGraph.clear();
    int ibNPs=0;
    int ibNormFactor=0;
    TIterator* it2 = mc->GetNuisanceParameters()->createIterator();
    while( (var = (RooRealVar*) it2->Next()) ){
      
      // Not consider nuisance parameter being not associated to syst
      string varname = (string) var->GetName();
      
      if ((varname.find("gamma_stat")!=string::npos)) continue;
      cout<<"variation name for pulls plot : "<<varname<<endl;

      double pull  = var->getVal() / 1.0 ; // GetValue() return value in unit of sigma
      double errorHi = var->getErrorHi() / 1.0; 
      double errorLo = var->getErrorLo() / 1.0; 
      
      if(strcmp(var->GetName(),"Lumi")==0){
	pull  = (var->getVal() - w->var("nominalLumi")->getVal() ) / (w->var("nominalLumi")->getVal() * LumiRelError );
	  errorHi = var->getErrorHi() / (w->var("nominalLumi")->getVal() * LumiRelError);
	  errorLo = var->getErrorLo() / (w->var("nominalLumi")->getVal() * LumiRelError); 
      }
      
      TString vname=var->GetName();
      vname.ReplaceAll("alpha_","");
      vname.ReplaceAll("Lumi","Luminosity");
      vname.ReplaceAll("_","\\_");
      fnuisPar.precision(3);
      fnuisPar << vname << " & $" << pull << "^{+" << fabs(errorHi) << "}_{-" << fabs(errorLo)  << "}$ \\\\" << endl;
      fnuisParAndCorr << vname << " & $" << pull << "^{+ " << fabs(errorHi) << "}_{-" << fabs(errorLo)  << "}$ \\\\" << endl;

      NPContainer MyNPsTemp;
      MyNPsTemp.NPname  = vname;
      MyNPsTemp.NPvalue = pull;
      MyNPsTemp.NPerrorHi = errorHi;
      MyNPsTemp.NPerrorLo = errorLo;
      MyNPsTemp.WhichFit = TS_IsConditionnal+"_FitGlobal_Mu";
      MyNPsTemp.WhichFit += mu;
      if (!IsAnormFactor(var)) AllNPafterEachFit_vec.push_back(MyNPsTemp);

      TString vname2=var->GetName();
      vname2.ReplaceAll("alpha_","");
      vname2.ReplaceAll("gamma_","");
      vname2.ReplaceAll("ATLAS_","");
      
      
      if (IsAnormFactor(var) ){
        ibNormFactor++;
        double xcNF = hNormFactor_axis->GetBinCenter(ibNormFactor);
        hNormFactor_axis->GetXaxis()->SetBinLabel(ibNormFactor,vname2);
        hNormFactor->SetPoint(ibNormFactor-1,xcNF,pull);
        hNormFactor->SetPointEXlow(ibNormFactor-1 ,hNormFactor_axis->GetBinWidth(ibNormFactor)/3.0);
        hNormFactor->SetPointEXhigh(ibNormFactor-1,hNormFactor_axis->GetBinWidth(ibNormFactor)/3.0);
        hNormFactor->SetPointEYlow(ibNormFactor-1 ,fabs(errorLo));
        hNormFactor->SetPointEYhigh(ibNormFactor-1,fabs(errorHi));
      } else {
        ibNPs++;
        double xc = h1Dpull_axis->GetBinCenter(ibNPs);
        h1Dpull_axis->GetXaxis()->SetBinLabel(ibNPs,vname2);
        h1Dpull->SetPoint(ibNPs-1,xc,pull);
        h1Dpull->SetPointEXlow(ibNPs-1 ,h1Dpull_axis->GetBinWidth(ibNPs)/3.0);
        h1Dpull->SetPointEXhigh(ibNPs-1,h1Dpull_axis->GetBinWidth(ibNPs)/3.0);
        h1Dpull->SetPointEYlow(ibNPs-1 ,fabs(errorLo));
        h1Dpull->SetPointEYhigh(ibNPs-1,fabs(errorHi));

        // Put in red NP with pull>1.5 OR Err<0.2, in black otherwise
        bool IsTooPulled = fabs(pull)>PullMaxAcceptable;
        bool IsOverConst = (fabs(errorLo)+fabs(errorHi))/2.0<ErrorMinAcceptable;
        bool IsOnesided  = UseMinosError && (errorHi==0 || errorLo==0);
        if (IsTooPulled || IsOverConst || IsOnesided){
          TGraphAsymmErrors *myGraph = new TGraphAsymmErrors(1);
          myGraph->SetLineWidth(2);
          myGraph->SetLineColor(kRed+1);
          myGraph->SetMarkerColor(kRed+1);
          myGraph->SetMarkerStyle(21);
          myGraph->SetMarkerSize(1.2); 
          myGraph->SetPoint(0,xc,pull);
          myGraph->SetPointEXlow(0 ,h1Dpull_axis->GetBinWidth(ibNPs)/3.0);
          myGraph->SetPointEXhigh(0,h1Dpull_axis->GetBinWidth(ibNPs)/3.0);
          myGraph->SetPointEYlow(0 ,fabs(errorLo));
          myGraph->SetPointEYhigh(0,fabs(errorHi));
          vec_MyGraph.push_back(myGraph);	
        }
      }
      
      
    }
    
    
    fnuisPar << "\\hline" << endl;
    fnuisPar << "\\end{tabular}" << endl;
    fnuisPar.close();
    
    fnuisParAndCorr << endl << endl << "CORRELATION_MATRIX" << endl;
    fnuisParAndCorr << h2Dcorrelation->GetNbinsX() << "   " << h2Dcorrelation->GetNbinsY() << endl;
    for(int kk=1; kk < h2Dcorrelation->GetNbinsX()+1; kk++) {
      for(int ll=1; ll < h2Dcorrelation->GetNbinsY()+1; ll++) {
	fnuisParAndCorr << h2Dcorrelation->GetBinContent(kk,ll) << "   ";
      }
      fnuisParAndCorr << endl;
    }
    fnuisParAndCorr << endl;
    fnuisParAndCorr.close();
    
    double _1SigmaValue[1000];
    double _2SigmaValue[1000];
    double NuisParamValue[1000];
    for (int i=0 ; i<NparNotStat+1 ; i++){
      _1SigmaValue[i] = 1.0;
      _1SigmaValue[2*NparNotStat-i] = -1;
      _2SigmaValue[i] = 2;
      _2SigmaValue[2*NparNotStat-i] = -2;
      NuisParamValue[i] = i;
      NuisParamValue[2*NparNotStat-1-i] = i;
    }
    TGraph *_1sigma = new TGraph(2*NparNotStat,NuisParamValue,_1SigmaValue);
    TGraph *_2sigma = new TGraph(2*NparNotStat,NuisParamValue,_2SigmaValue);
    c1->cd();
    //c1->cd(2); 
    h1Dpull->SetLineWidth(2);
    h1Dpull->SetLineColor(1);
    h1Dpull->SetMarkerColor(1);
    h1Dpull->SetMarkerStyle(21);
    h1Dpull->SetMarkerSize(1.2);      
    _2sigma->SetFillColor(5);
    _2sigma->SetLineColor(5);
    _2sigma->SetMarkerColor(5);
    _1sigma->SetFillColor(3);
    _1sigma->SetLineColor(3);
    _1sigma->SetMarkerColor(3);
    h1Dpull_axis->Draw("hist");
    _2sigma->Draw("F"); 
    _1sigma->Draw("F"); 
    h1Dpull->Draw("P");
    for (unsigned i=0 ; i<vec_MyGraph.size() ; i++) vec_MyGraph[i]->Draw("P");
    h1Dpull_axis->GetYaxis()->DrawClone();
    
    TLatex text;
    text.SetNDC();
    text.SetTextSize( 0.054);
    text.SetTextAlign(31);
    TString WritDownMuValue;
    if(!IsConditionnal) WritDownMuValue = "#mu_{best} = ";
    else                WritDownMuValue = "#mu_{fixed} = ";
    WritDownMuValue += Form("%2.2f",firstPOI->getVal());
    c1->cd();
    //c1->cd(2); 
    text.DrawLatex( 0.87,0.81, WritDownMuValue );
    TString statusText="Minuit status:" ;
    statusText+=status;
    text.DrawLatex( 0.45,0.85, statusText);  
    statusText="Hess status:" ;
    statusText+=HessStatus;
    text.DrawLatex( 0.45,0.78, statusText);
    statusText="Edm=" ;
    statusText+=Form("%1.4f",Edm);;
    text.DrawLatex( 0.45,0.71, statusText);
    if(status!=0 && status!=1) {
      statusText="#color[2]{Unconverged Fit}" ;
      text.DrawLatex( 0.87,0.71, statusText);
    }
            
    c3->cd();
    hNormFactor_axis->GetXaxis()->SetTitleOffset(1.4);
    hNormFactor_axis->Draw("hist");
    hNormFactor->GetXaxis()->SetTitleOffset(1.4);
    hNormFactor->Draw("P");
    text.DrawLatex( 0.87,0.81, WritDownMuValue );
    
    MainDir->cd();
    c0->Write();
    std::cout << "OutputDir is " << OutputDir << std::endl;
    c0->SaveAs(OutputDir+"/Corr.pdf");
    c1->Write();
    c3->Write();
    c1->SaveAs(OutputDir+"/C1.pdf");
    c3->SaveAs(OutputDir+"/C3.pdf");
    gROOT->cd();

    
    if(draw1DResponse) {
      // Plotting the likelihood projection in each NP direction
      cout << "Plotting 1D Response for each NP" << endl;
      TDirectory *NLLprojection = (TDirectory*) MainDir->mkdir("AllNNLProjections");
      gROOT->cd();
      TDirectory *maxCorrNPs = (TDirectory*) MainDir->mkdir("AllMaxCorrNPs");
      gROOT->cd();
      RooAbsReal* nll = simPdf->createNLL(*data);

      TLatex* latex = new TLatex();
      latex->SetNDC(); latex->SetTextSize(0.055); latex->SetTextAlign(32);
      TF1* poly5 = new TF1("poly5","[0]+[1]*x+[2]*x*x",-5,5);
      TF1* poly2 = new TF1("poly2","[0]+[1]*x+[2]*x*x",0,10);
      TCanvas* can2 = new TCanvas("NLLscan");
      list< pair<RooRealVar*, float> > pairs;
      TH2D* redMat = NULL;

      if (!IsConditionnal){
        var = (RooRealVar*) firstPOI;

        // find NPs with highest correlation
        pairs.clear();
        pairs = GetOrderedCorrelations(var, fitresGlobal);
        redMat = GetSubsetOfCorrMatrix(var, pairs, fitresGlobal, 4);
        can2->SetTitle(redMat->GetName());
        can2->SetName(redMat->GetName());
        can2->cd();
        redMat->Draw("colz text");
        maxCorrNPs->cd();
        TDirectory* saveDir = maxCorrNPs->GetDirectory(var->GetName());
        if(!saveDir) { saveDir = maxCorrNPs->mkdir(var->GetName()); }
        saveDir->cd();
        can2->Write(redMat->GetName());
        gROOT->cd();

        Plot1DResponse(nll, var, "", can2, poly2, true, latex, NLLprojection);

        RooCategory* channelCat = (RooCategory*) (&simPdf->indexCat());
        TIterator *iter = channelCat->typeIterator() ;
        RooCatType *tt  = NULL;
        while((tt=(RooCatType*) iter->Next()) ){
          TString chanName(tt->GetName());
          RooAbsPdf  *pdftmp  = simPdf->getPdf( tt->GetName() );
          RooAbsData *datatmp = data->reduce(Form("%s==%s::%s",channelCat->GetName(),channelCat->GetName(),tt->GetName()));
          RooAbsReal* catNll = pdftmp->createNLL(*datatmp);
          if(!catNll->dependsOn(*var)) { continue; }
          Plot1DResponse(catNll, var, chanName, can2, poly2, true, latex, NLLprojection);
        }

      } // if is *not* conditional fit
      //return;

      TIterator* it3 = mc->GetNuisanceParameters()->createIterator();
      while( (var = (RooRealVar*) it3->Next()) ){
        TString vname=var->GetName();
        if (vname.Contains("gamma_stat")) { continue; }
        //if (!vname.Contains("ATLAS_norm")) { continue; }
        bool floating(false); 
        if(vname.Contains("ATLAS_norm")) { floating = true; }

        /* if want to make a slice instead of a projection
           RooArgSet* SliceNPs = new RooArgSet( *(mc->GetNuisanceParameters()), TString("sliceNP_")+TString(var->GetName()));
           SliceNPs->remove(*var, true, true);
           */

        // find NPs with highest correlation
        pairs.clear();
        pairs = GetOrderedCorrelations(var, fitresGlobal);
        redMat = GetSubsetOfCorrMatrix(var, pairs, fitresGlobal, 4);
        can2->SetTitle(redMat->GetName());
        can2->SetName(redMat->GetName());
        can2->cd();
        redMat->Draw("colz text");
        maxCorrNPs->cd();
        TDirectory* saveDir = maxCorrNPs->GetDirectory(var->GetName());
        if(!saveDir) { saveDir = maxCorrNPs->mkdir(var->GetName()); }
        saveDir->cd();
        can2->Write(redMat->GetName());
        gROOT->cd();

        if(floating) {
          Plot1DResponse(nll, var, "", can2, poly2, floating, latex, NLLprojection);
        } else {
          Plot1DResponse(nll, var, "", can2, poly5, floating, latex, NLLprojection);
        }

        RooCategory* channelCat = (RooCategory*) (&simPdf->indexCat());
        TIterator *iter = channelCat->typeIterator() ;
        RooCatType *tt  = NULL;
        while((tt=(RooCatType*) iter->Next()) ){
          //cout << " -- On category " << tt->GetName() << " " << endl;
          TString chanName(tt->GetName());
          RooAbsPdf  *pdftmp  = simPdf->getPdf( tt->GetName() );
          RooAbsData *datatmp = data->reduce(Form("%s==%s::%s",channelCat->GetName(),channelCat->GetName(),tt->GetName()));
          RooAbsReal* catNll = pdftmp->createNLL(*datatmp);
          if(!catNll->dependsOn(*var)) { continue; }
          if(floating) {
            Plot1DResponse(catNll, var, chanName, can2, poly2, floating, latex, NLLprojection);
          } else {
            Plot1DResponse(catNll, var, chanName, can2, poly5, floating, latex, NLLprojection);
          }
        } // loop over sub channels
      } // loop over NPs
      delete can2;
      cout << "Finished Plotting 1D Response for each NP" << endl;
    }

    cout << "Plotting Distributions for each subchannel" << endl;

    // Plotting the distributions for each subchannel
    RooCategory* channelCat = (RooCategory*) (&simPdf->indexCat());
    TIterator *iter = channelCat->typeIterator() ;
    RooCatType *tt  = NULL;
    vector<double> Chi2Postfit_Channel;Chi2Postfit_Channel.clear();
    vector<double> Chi2Prefit_Channel;Chi2Prefit_Channel.clear();
    vector<TString> NameChannel;NameChannel.clear();
    TString dirName(OutputDir+"/PlotsAfterGlobalFit");
    if(drawPlots) { system(TString("mkdir -vp "+dirName)); }
    while((tt=(RooCatType*) iter->Next()) ){
                
      RooAbsPdf  *pdftmp  = simPdf->getPdf( tt->GetName() );
      RooAbsData *datatmp = data->reduce(Form("%s==%s::%s",channelCat->GetName(),channelCat->GetName(),tt->GetName()));
      RooArgSet  *obstmp  = pdftmp->getObservables( *mc->GetObservables() ) ;
      RooRealVar *obs     = ((RooRealVar*) obstmp->first());

      // Bin Width
      RooRealVar* binWidth = ((RooRealVar*) pdftmp->getVariables()->find(Form("binWidth_obs_x_%s_0",tt->GetName()))) ;
      if(!binWidth) { cout << "No bin width " << tt->GetName() << endl; }
      cout << "    Bin Width : " << binWidth->getVal() << endl;

      // Load the value from the global fit
      if(!w->loadSnapshot("snapshot_paramsVals_GlobalFit")) { 
        cout << "Cannot load " <<  "snapshot_paramsVals_GlobalFit" << endl;
        exit(-1);
      }
      if   (!IsConditionnal) firstPOI->setVal(muhat);
      else                   firstPOI->setVal(mu);
      
      TString modelName(tt->GetName());
      modelName.Append("_model");
      RooRealSumPdf *pdfmodel = (RooRealSumPdf*) (pdftmp->getComponents())->find(modelName);
      RooArgList funcList =  pdfmodel->funcList();
      RooProduct* comp = 0;
      RooLinkedListIter funcIter = funcList.iterator() ;
      cout << "Post Fit " << endl;
      while( (comp = (RooProduct*) funcIter.Next()) ) {
        cout << "\t" << comp->GetName() << "\t" << (comp->createIntegral(*obs))->getVal() * binWidth->getVal() << endl;
      }

      cname = "can_DistriAfterFit_"+ (TString) tt->GetName() +"_GlobalFit_" + TS_IsConditionnal + "_mu";
      cname += mu;
      TCanvas* c2 = new TCanvas( cname );
      RooPlot* frame = obs->frame();
      TString FrameName = "Plot_DistriGlobal_" + (TString) IsConditionnal;
      frame->SetName( FrameName );
      frame->SetYTitle("EVENTS");

      float postFitIntegral = pdftmp->expectedEvents(*obs);
      datatmp->plotOn(frame,MarkerSize(1),Name("Data"),DataError(RooAbsData::Poisson));
      pdftmp->plotOn(frame,FillColor(kOrange),LineWidth(2),LineColor(kBlue),VisualizeError(*fitresGlobal,1),
		     Normalization(postFitIntegral,RooAbsReal::NumEvent),Name("FitError_NotAppears"));
      pdftmp->plotOn(frame,LineWidth(2),Normalization(postFitIntegral,RooAbsReal::NumEvent),Name("CentralFit_NotAppears"));
      double chi2 = frame->chiSquare();
      double chi2_prefit = -99;
      Chi2Postfit_Channel.push_back( chi2 );
      NameChannel.push_back( (TString)tt->GetName() );


      // miniloop over componant to make a bkg stack
      TString modelName1(tt->GetName());
      modelName1.Append("_model");
      RooRealSumPdf *pdfmodel1 = (RooRealSumPdf*) (pdftmp->getComponents())->find(modelName1);
      RooArgList funcList1 =  pdfmodel1->funcList();
      RooLinkedListIter funcIter1 = funcList1.iterator() ;
      RooProduct* comp1 = 0;
      if (!IsConditionnal) firstPOI->setVal(muhat);
      else                 firstPOI->setVal(mu);
      int ibkg=0;
      int icolor=0;
      TString previous="";
      while( (comp1 = (RooProduct*) funcIter1.Next()) ) {
	ibkg++;

	int color=kGray;
	
	TString compname(comp1->GetName());
	compname.ReplaceAll("L_x_","");
        compname.ReplaceAll(tt->GetName(),"");
        compname.ReplaceAll("_overallSyst_x_StatUncert","");
        compname.ReplaceAll("_overallSyst_x_HistSyst","");
        compname.ReplaceAll("_overallSyst_x_Exp","");
	compname.ReplaceAll("_","");
	
	icolor++;
	if(icolor==1) { color = kOrange - 3; }
	else if(icolor==2) { color = kCyan + 1; }
	else if(icolor==3) { color = kGreen - 9; }
	else if(icolor==4) { color = kAzure - 9; }
	else if(icolor==5) { color = kOrange + 10;}
	else if(icolor==6) { color = kGreen - 6; }
	else if(icolor==7) { color = kAzure - 4; }
	else if(icolor==8) { color = kOrange + 6; }
	else if(icolor==9) { color = kGreen + 1; }
	else if(icolor==10) { color = kAzure + 2; }
	else if(icolor==11) { color = kOrange; }
	else if(icolor==12) { color = kGreen + 3; }
	else if(icolor==13) { color = kAzure - 4; }
	else if(icolor==14) { color = kOrange; }
	else if(icolor==15) { color = kGreen + 1; }
	else if(icolor==16) { color = kOrange - 7; }
	else if(icolor==17) { color = kPink + 1; }
	else   color=icolor;
	
	// Get the signal x 1 in white (for further purposes)
	if (IsConditionnal) firstPOI->setVal(1.0);
	double Ntemp=(comp1->createIntegral(*obs))->getVal() * binWidth->getVal();
	pdfmodel1->plotOn(frame,LineWidth(0),Components(*comp1),LineColor(0), LineStyle(3), Normalization(Ntemp,RooAbsReal::NumEvent),Name("NoStacked_"+compname));
	if (IsConditionnal) firstPOI->setVal(mu);
	
	// Stack bkg
	Ntemp=(comp1->createIntegral(*obs))->getVal() * binWidth->getVal();
	if (ibkg==0) pdfmodel1->plotOn(frame,LineWidth(2),Components(*comp1),LineColor(color), Normalization(Ntemp,RooAbsReal::NumEvent),Name("Stacked_"+compname));
	else         pdfmodel1->plotOn(frame,LineWidth(2),Components(*comp1),LineColor(color), Normalization(Ntemp,RooAbsReal::NumEvent),Name("Stacked_"+compname),AddTo(previous));
	previous="Stacked_"+compname;
      }

      if (!IsConditionnal) firstPOI->setVal(muhat);
      else                 firstPOI->setVal(mu);
      pdftmp->plotOn(frame,FillColor(kOrange),LineWidth(2),LineColor(kBlue),VisualizeError(*fitresGlobal,1),
		     Normalization(postFitIntegral,RooAbsReal::NumEvent),Name("FitError_AfterFit"));
      pdftmp->plotOn(frame,LineWidth(2),Normalization(postFitIntegral,RooAbsReal::NumEvent),Name("FitCentral2_NotAppears"));
      datatmp->plotOn(frame,MarkerSize(1),Name("Dat_NotAppears"),DataError(RooAbsData::Poisson));
      	
      // Putting nuisance parameter at the central value and draw the nominal distri
      SetAllStatErrorToSigma(0.0);
      SetAllNuisanceParaToSigma(0.0);
      if (!IsConditionnal) SetPOI(0.0);
      else                 SetPOI(mu);
      TString muValueBeforeFitLegend = Form("Before fit (#mu=%2.2f)",firstPOI->getVal());
      funcIter = funcList.iterator() ;
      cout << "Pre Fit " << endl;
      while( (comp = (RooProduct*) funcIter.Next()) ) {
        cout << "\t" << comp->GetName() << "\t" << (comp->createIntegral(*obs))->getVal() * binWidth->getVal() << endl;
      }
      float preFitIntegral = pdftmp->expectedEvents(*obs);
      pdftmp->plotOn(frame,LineWidth(2),Name("BeforeFit"),LineStyle(kDashed),Normalization(preFitIntegral,RooAbsReal::NumEvent));      
      chi2_prefit = frame->chiSquare();
      Chi2Prefit_Channel.push_back( chi2_prefit );
      c2->cd();
      frame->Draw();
      c2->cd(); 
      
      TString modelName2(tt->GetName());
      modelName2.Append("_model");
      RooRealSumPdf *pdfmodel2 = (RooRealSumPdf*) (pdftmp->getComponents())->find(modelName2);
      RooArgList funcList2 =  pdfmodel2->funcList();
      RooLinkedListIter funcIter2 = funcList2.iterator() ;
      RooProduct* comp2 = 0;
      if (!IsConditionnal) firstPOI->setVal(muhat);
      else                 firstPOI->setVal(mu);
      ibkg=0;
      icolor=0;
      while( (comp2 = (RooProduct*) funcIter2.Next()) ) {
	ibkg++;
	int color=kGray;
	TString compname(comp2->GetName());
	compname.ReplaceAll("L_x_","");
        compname.ReplaceAll(tt->GetName(),"");
        compname.ReplaceAll("_overallSyst_x_StatUncert","");
        compname.ReplaceAll("_overallSyst_x_HistSyst","");
        compname.ReplaceAll("_overallSyst_x_Exp","");
	compname.ReplaceAll("_","");
	if (IsConditionnal) firstPOI->setVal(1.0);
	
	icolor++;
	if(icolor==1) { color = kOrange - 3; }
	else if(icolor==2) { color = kCyan + 1; }
	else if(icolor==3) { color = kGreen - 9; }
	else if(icolor==4) { color = kAzure - 9; }
	else if(icolor==5) { color = kOrange + 10;}
	else if(icolor==6) { color = kGreen - 6; }
	else if(icolor==7) { color = kAzure - 4; }
	else if(icolor==8) { color = kOrange + 6; }
	else if(icolor==9) { color = kGreen + 1; }
	else if(icolor==10) { color = kAzure + 2; }
	else if(icolor==11) { color = kOrange; }
	else if(icolor==12) { color = kGreen + 3; }
	else if(icolor==13) { color = kAzure - 4; }
	else if(icolor==14) { color = kOrange; }
	else if(icolor==15) { color = kGreen + 1; }
	else if(icolor==16) { color = kOrange - 7; }
	else if(icolor==17) { color = kPink + 1; }
	else   color=icolor;
	double Ntemp=(comp2->createIntegral(*obs))->getVal() * binWidth->getVal();
	pdfmodel2->plotOn(frame,LineWidth(0),Components(*comp2),LineColor(0), LineStyle(3), Normalization(Ntemp,RooAbsReal::NumEvent),Name("NoStacked_BkgBeforeFit_"+compname));

      }
      if (!IsConditionnal) firstPOI->setVal(muhat);
      else                 firstPOI->setVal(mu);

      c2->cd();
      frame->Draw();
      text.DrawLatex( 0.73,0.81, WritDownMuValue );
      TString ts_chi2 = Form("post-fit #chi^{2}=%1.1f", chi2 );
      text.DrawLatex( 0.22, 0.83, ts_chi2 );
      ts_chi2 = Form("pre-fit #chi^{2}=%1.1f", chi2_prefit );
      text.DrawLatex( 0.22, 0.73, ts_chi2 );

      TLegend *leg = new TLegend(0.54,0.40,0.77,0.76);
      leg->SetBorderSize(0);
      leg->SetFillColor(0);
      leg->SetTextFont(62);
      leg->SetTextSize(0.050);
      for (int i=0; i<frame->numItems(); i++) {
        TString obj_name=frame->nameOf(i); 
        if (obj_name=="" || obj_name.Contains("NotAppears") || obj_name.Contains("NoStacked") ) continue;
        TObject *obj = frame->findObject(obj_name.Data());
        if (((string)obj_name).find("Data")   !=string::npos) { leg->AddEntry( obj , "Data" , "p"); continue; }
	TString legname;
	if (!IsConditionnal) legname = "After fit (#mu[best] S+B)";
	else                 legname = "After fit (#mu[fixed] S+B)";
        if (((string)obj_name).find("AfterFit")!=string::npos){ leg->AddEntry( obj , legname , "lf"); continue; }
	legname = muValueBeforeFitLegend;
	if (((string)obj_name).find("BeforeFit")!=string::npos){leg->AddEntry( obj ,legname , "l"); continue;}
	
	obj_name.ReplaceAll("Stacked_","");
	leg->AddEntry(obj,obj_name,"l");
      }	
  
      leg->Draw();


      // Save the plots
      MainDir->cd();
      c2->Write();
      //c2->SaveAs("C2.pdf");
      if(drawPlots) { 
        c2->Print(dirName+"/"+c2->GetName()+".eps");
        c2->Print(dirName+"/"+c2->GetName()+".png");
      }
      c2->Close();
      gROOT->cd();


      cout << "Number of items in frame " << frame->numItems() << endl;
      frame->Clear();
      cout << "Number of items in frame " << frame->numItems() << endl;
      delete frame;
      frame = 0;


      continue;

      // plot each component
      TString chanName(tt->GetName());
      funcIter = funcList.iterator() ;
      while( (comp = (RooProduct*) funcIter.Next()) ) {

        // Load the value from the global fit
        if(!w->loadSnapshot("snapshot_paramsVals_GlobalFit")) { 
          cout << "Cannot load " <<  "snapshot_paramsVals_GlobalFit" << endl;
          exit(-1);
        }

        cname = "can_DistriAfterFit_"+ (TString) tt->GetName() +"_GlobalFit_" + TS_IsConditionnal + "_mu";
        cname += mu;
        TString compName(comp->GetName());
        compName.ReplaceAll("L_x_","");
        compName.ReplaceAll(chanName,"");
        compName.ReplaceAll("__overallSyst_x_StatUncert","");
        compName.ReplaceAll("__overallSyst_x_HistSyst","");
        compName.ReplaceAll("__overallSyst_x_Exp","");
        cname.Append("_"+compName);

        TCanvas* c4 = new TCanvas( cname );
        RooPlot* compFrame = obs->frame();
        cout << "COMP FRAMCE " << compFrame->numItems() << endl;
        FrameName = "Plot_" + compName + "_Global_" + (TString) IsConditionnal;
        compFrame->SetName( FrameName );
        compFrame->SetYTitle("EVENTS");
        postFitIntegral = ( (comp->createIntegral(*obs))->getVal() * binWidth->getVal() );
        comp->plotOn(compFrame,FillColor(kOrange),LineWidth(2),LineColor(kBlue),VisualizeError(*fitresGlobal,1),
            Normalization(postFitIntegral),Name("AfterFit"));
        comp->plotOn(compFrame,LineWidth(2),Normalization(postFitIntegral));
        c4->cd();
        compFrame->Draw();

        // Putting nuisance parameter at the central value and draw the nominal distribution
        if(!w->loadSnapshot("snapshot_paramsVals_initial")) { 
          cout << "Cannot load " <<  "snapshot_paramsVals_initial" << endl;
          exit(-1);
        }
        preFitIntegral = ( (comp->createIntegral(*obs))->getVal() * binWidth->getVal() );
        comp->plotOn(compFrame,LineWidth(2),Name("BeforeFit"),LineStyle(kDashed),Normalization(preFitIntegral));      
        //comp->plotOn(compFrame,LineWidth(2),Name("BeforeFit"),LineStyle(kDashed),Normalization(preFitIntegral,RooAbsReal::NumEvent));      
        cout << tt->GetName() << "\t" << compName << "\t" << preFitIntegral << " " << postFitIntegral <<  endl;
        c4->cd();
        compFrame->Draw();
        c4->cd(); 
        TString normChange = Form("Norm %5.2f -> %5.2f = %5.2f",preFitIntegral, postFitIntegral, postFitIntegral/preFitIntegral);
        text.DrawLatex( 0.84,0.83, normChange);

        leg->Clear();
        leg->SetBorderSize(0);
        leg->SetFillColor(0);
        leg->SetTextFont(62);
        leg->SetTextSize(0.050);
        for (int i=0; i<compFrame->numItems(); i++) {
          TString obj_name=compFrame->nameOf(i); 
          if (obj_name=="") continue;
          TObject *obj = compFrame->findObject(obj_name.Data());
          if (((string)obj_name).find("Data")   !=string::npos) leg->AddEntry( obj , "Data" , "p");
          if (((string)obj_name).find("AfterFit")!=string::npos) leg->AddEntry( obj , "After fit" , "lf");
          TString legname = Form("Before fit (#mu=%2.2f)",firstPOI->getVal());
          if (((string)obj_name).find("BeforeFit")!=string::npos) leg->AddEntry( obj ,legname , "l");
        }	  
        leg->Draw();


        // Save the plots
        MainDir->cd();
        c4->Write();
       c4->SaveAs(OutputDir+"/c4.pdf");
        if(drawPlots) { 
          c4->Print(dirName+"/"+c4->GetName()+".eps");
          c4->Print(dirName+"/"+c4->GetName()+".png");
        }
        c4->Close();
        gROOT->cd();
        delete compFrame;
        compFrame = 0;
        

      } // loop over components

    } // loop over channels
    // make a webpage
    if(drawPlots) {
      //system("./createHTMLpageAllPlots.sh "+dirName+" &");
    }

    int Nchannel = NameChannel.size();
    TH1F *hChi2       = new TH1F("Chi2PerChannel","Chi2PerChannel",Nchannel,0,Nchannel);
    TH1F *hChi2Prefit = new TH1F("Chi2PerChannel_pf","Chi2PerChannel_pf",Nchannel,0,Nchannel);
    for (int jb=0 ; jb<Nchannel ; jb++){

      cout << "Channel " << NameChannel[jb] << endl;
      cout << " chi2[post-fit] = " << Chi2Postfit_Channel[jb]  << endl;
      cout << " chi2[pre-fit]  = " << Chi2Prefit_Channel[jb] << endl;

      hChi2Prefit->SetBinContent(jb+1,Chi2Prefit_Channel[jb]);
      hChi2->SetBinContent(jb+1,Chi2Postfit_Channel[jb]);
      hChi2->GetXaxis()->SetBinLabel(jb+1,NameChannel[jb]);
    }
    sort( Chi2Prefit_Channel.begin(), Chi2Prefit_Channel.end());
    hChi2->GetYaxis()->SetRangeUser(0.0,Chi2Prefit_Channel[Chi2Prefit_Channel.size()-1]*1.50);
    hChi2->SetTitle("#chi^{2} overview among channels");
    hChi2->SetLineColor(1);
    hChi2->SetMarkerColor(1);
    hChi2->SetLineWidth(2);

    hChi2Prefit->SetLineColor(1);
    hChi2Prefit->SetMarkerColor(1);
    hChi2Prefit->SetLineWidth(2);
    hChi2Prefit->SetLineStyle(2);
    
    TCanvas *canChi2 = new TCanvas("CanvasChi2","CanvasChi2",800,600);
    canChi2->cd();
    hChi2->Draw();
    hChi2Prefit->Draw("same");

    MainDir->cd();
    canChi2->Write();
    gROOT->cd();

    return;
  }


  void Plot1DResponse(RooAbsReal* nll, RooRealVar* var, TString cname, TCanvas* can, TF1* poly, bool IsFloating, TLatex* latex, TDirectory* tdir, RooArgSet* SliceSet) {
    TString vname=var->GetName();
    vname.ReplaceAll("alpha_","");
    vname.ReplaceAll("gamma_","");
    vname.ReplaceAll("ATLAS_","");
    RooPlot* frame2 = var->frame(Title("-log(L) vs "+vname+" "+cname));
    TString tag("");
    //     if(SliceSet) {
    //	// plot a slice instead of a projection
    //	nll->plotOn(frame2,LineColor(kRed),ShiftToZero(),Slice(*SliceSet)) ;
    //	tag.Append("_slice");
    //     } else {
    //	nll->plotOn(frame2,LineColor(kRed),ShiftToZero()) ;
    //     }

    nll->plotOn(frame2,Name("FullLHood"),LineColor(kRed),ShiftToZero()) ;
    RooCurve* curve = frame2->getCurve();

    if(SliceSet) {
      // plot a slice instead of a projection
      nll->plotOn(frame2,Name("SliceLHood"),LineColor(kGreen),ShiftToZero(),MoveToBack(),Slice(*SliceSet)) ;
    }

    float min(0);
    if(!IsFloating) {
      RooCurve* poissonTerm = new RooCurve(*curve);
      for(int i=1; i<curve->GetN()-2; i++) {
        poissonTerm->SetPoint(i, curve->GetX()[i], curve->GetY()[i] - curve->GetX()[i]*curve->GetX()[i]/2.);
        if(poissonTerm->GetY()[i] < min) { min = poissonTerm->GetY()[i]; }
      }
      poissonTerm->SetLineColor(kBlue);
      frame2->addPlotable(poissonTerm,"same",false,false);
      frame2->GetXaxis()->SetRangeUser(-5.0,5.0);
      curve = poissonTerm;
    } else {
      float val = var->getVal();
      float minVal = 0;
      float maxVal = 2;
      if(val>1/5) {
        minVal = val - 2; if(minVal<0) { minVal = 0; }
        maxVal = val + 2;
      }
      //frame2->GetXaxis()->SetRangeUser(0.0,2.0);
      frame2->GetXaxis()->SetRangeUser(minVal,maxVal);
    }

    // fit
    for( int par(0); par<3; par++) { poly->SetParameter(par,0); }
    curve->Fit(poly,"RQN"); // R=range, Q=quiet, N=do not draw
    TString fitStr = Form("%5.2f + %5.2fx + %5.2fx^{2}", poly->GetParameter(0), poly->GetParameter(1), poly->GetParameter(2));
    latex->SetText(0.925,0.925, fitStr);

    // y axis
    //fixme frame2->updateYAxis(min,5.0);
    frame2->GetYaxis()->SetRangeUser(min,5.0);
    frame2->GetYaxis()->SetTitle("#Delta [-Log(L)]");

    if(cname.Length()>0) { cname.Append("_"); } // it is 0 if plotting nll for full PDF - it is not if plotting for 1 channel
    cname.Prepend("NLLscan_");
    cname.Append(vname);
    cname.Append(tag);
    can->SetTitle(cname);
    can->SetName(cname);
    can->cd();
    frame2->Draw();
    latex->Draw("same");
    TDirectory* saveDir = tdir->GetDirectory(var->GetName());
    if(!saveDir) { saveDir = tdir->mkdir(var->GetName()); }
    saveDir->cd();
    can->Write(cname);
    gROOT->cd();
    if(drawPlots) {
      TString epsDir("LHoodPlots/"+vname+"/");
      system(TString("mkdir -vp ")+epsDir);
      epsDir.Append(cname); epsDir.Append(".eps");
      can->Print(epsDir);
    }
  } // Plot1DResponse

  int GetPosition(RooRealVar* var, TH2D* corrMatrix) {
    int position(0);
    for(int b=0; b<corrMatrix->GetNbinsX()+2; b++) {
      if(TString(corrMatrix->GetXaxis()->GetBinLabel(b)).CompareTo(var->GetName())) { continue; } // 0 = match, non-zero = not match
      position = b; 
      break;
    }
    return position;
  } // GetPosition

  list< pair<RooRealVar*,float> > GetOrderedCorrelations(RooRealVar* var, RooFitResult* fitres) {
    list< pair<RooRealVar*, float> > pairs;
    TIterator* inp = mc->GetNuisanceParameters()->createIterator();
    RooRealVar* np = NULL;
    float corr(0);
    // save all into a list to be sorted
    while( (np = (RooRealVar*) inp->Next()) ){
      if(TString(np->GetName()).Contains("gamma")) { continue; }
      if(np->GetName() == var->GetName()) { continue; }
      corr = fitres->correlation(var->GetName(),np->GetName());
      pairs.push_back( make_pair( np, corr ) );
    }
    pairs.sort(comp_second_abs_decend);
    //     for(list< pair<RooRealVar* ,float> >::iterator p=pairs.begin(); p!=pairs.end(); p++) {
    //	cout << p->first->GetName() << "\t" << p->second << endl;
    //     }
    return pairs;
  } // GetOrderedCorrelations

  TH2D* GetSubsetOfCorrMatrix(RooRealVar* var, list< pair<RooRealVar*,float> >& pairs, RooFitResult* fitres, int size) {
    RooArgList corrNPs = RooArgList("corrNPs");
    // retrieve top "size" NPs and draw correlations in a 2D hist
    for(list< pair<RooRealVar* ,float> >::iterator p=pairs.begin(); p!=pairs.end(); p++) {
      if(corrNPs.getSize()==size) { break; }
      corrNPs.add( *(p->first) );
      //cout << p->first->GetName() << "\t" << p->second << endl;
    }
    corrNPs.add(*var); // add variable of interest
    // this does a decomposition
    //TMatrixDSym redCM = fitresGlobal->reducedCovarianceMatrix( corrNPs );

    // build a matrix by hand
    TString hname("Top_"+TString(Form("%i",size))+"_Correlated_NPs_for_"+TString(var->GetName()));
    size = corrNPs.getSize(); // redefine size to include variable of interest
    TH2D* redMat = new TH2D(hname,hname, size,0,size, size,0,size);
    for(int i=0; i<size; i++) {
      TString vname(corrNPs.at(i)->GetName());
      vname.ReplaceAll("alpha_Sys","");
      vname.ReplaceAll("alpha_","");
      vname.ReplaceAll("alpha_","");
      redMat->GetXaxis()->SetBinLabel(i+1, vname);
      redMat->GetYaxis()->SetBinLabel(i+1, vname);
      for(int j=0; j<size; j++) {
        redMat->SetBinContent(i+1, j+1, fitres->correlation( corrNPs.at(i)->GetName(), corrNPs.at(j)->GetName() ) );
      }
    }
    redMat->SetMinimum(-1);
    redMat->SetMaximum(1);
    return redMat;
  } // GetSubsetOfCorrMatrix

  void PlotsNuisanceParametersVSmu(){
    cout << endl;
    cout << endl;
    cout << "Performing a global fit for mu : can take time ..." << endl;
    cout << endl;

    // Put all parameters to their iniital values
    if(!w->loadSnapshot("snapshot_paramsVals_initial")) { 
      cout << "Cannot load " <<  "snapshot_paramsVals_initial" << endl;
      exit(-1);
    }

    ProfileInspector p;
    TList* list = p.GetListOfProfilePlots(*data,mc);

    for(int i=0; i<list->GetSize(); ++i){

      TString cname = "ProfileInspector_" + (TString) list->At(i)->GetName();
      TCanvas* c1 = new TCanvas(cname);
      c1->cd();
      list->At(i)->Draw("al");

      MainDirModelInspector->cd();
      c1->Write();
      c1->Close();
      gROOT->cd();
    }
    return;
  }


  void PlotsStatisticalTest(double mu_pe, double mu_hyp){

    mu_pe = mu_hyp; // remove compilation warnings

    /*
    // Put all parameters to their iniital values
    if(!w->loadSnapshot("snapshot_paramsVals_initial")) { 
      cout << "Cannot load " <<  "snapshot_paramsVals_initial" << endl;
      exit(-1);
    }

    int nToyMC = 5;
    // set roofit seed
    RooRandom::randomGenerator()->SetSeed();

    cout << endl;
    cout << endl;
    cout << "Will generate " << nToyMC << " pseudo-experiments for : " << endl;
    cout << " - mu[pseudo-data] = " << mu_pe  << endl;
    cout << " - mu[stat-test]   = " << mu_hyp << endl;
    cout << endl;

    // Check number of POI (for Wald approx)
    RooArgSet *ParamOfInterest = (RooArgSet*) mc->GetParametersOfInterest();
    int nPOI = ParamOfInterest->getSize();
    if(nPOI>1){
      cout <<"not sure what to do with other parameters of interest, but here are their values"<<endl;
      mc->GetParametersOfInterest()->Print("v");
    }
    RooRealVar* firstPOI    = (RooRealVar*) ParamOfInterest->first(); 
    RooSimultaneous *simPdf = (RooSimultaneous*)(mc->GetPdf());
    //PrintAllParametersAndValues( *mc->GetGlobalObservables() );
    //PrintAllParametersAndValues( *mc->GetObservables() );
    firstPOI->setVal(0.0); // FIXME

    FitPDF( mc, simPdf, data, "Minuit2", false );

    // set up the sampler
    ToyMCSampler sampler;
    sampler.SetPdf(*mc->GetPdf());
    sampler.SetObservables(*mc->GetObservables());
    sampler.SetNToys(nToyMC);
    sampler.SetGlobalObservables(*mc->GetGlobalObservables());
    sampler.SetParametersForTestStat(*mc->GetParametersOfInterest());
    RooArgSet* poiset = dynamic_cast<RooArgSet*>(w->set("ModelConfig_POI")->Clone());

    // set up the test statistic
    ProfileLikelihoodTestStat *profll = new ProfileLikelihoodTestStat(*mc->GetPdf());
    // enable detailed output on the set statistic
    profll->EnableDetailedOutput(true);
    // add the test statistic to the sampler for evaluation
    sampler.AddTestStatistic(profll);

    // only unconditional fit
    MinNLLTestStat *minNll = new MinNLLTestStat(*mc->GetPdf());
    minNll->EnableDetailedOutput(true);
    sampler.AddTestStatistic(minNll);

    // enable PROOF if desired
    //ProofConfig pc(*w, 8, "workers=8", kFALSE);
    //sampler.SetProofConfig(&pc);

    // evaluate the test statistics - this is where most of our time will be spent
    cout << "Generating " << nToyMC << " toys...this will take a few minutes" << endl;
    TStopwatch *mn_t = new TStopwatch; 
    mn_t->Start();
    RooDataSet* sd = sampler.GetSamplingDistributions(*poiset);
    cout << "Toy generation complete :" << endl;
    // stop timing
    mn_t->Stop();
    cout << " total CPU time: " << mn_t->CpuTime() << endl;
    cout << " total real time: " << mn_t->RealTime() << endl; 

    // now sd contains all information about our test statistics, including detailed output
    // we might eg. want to explore the results either directly, or first converting to a TTree
    // do the conversion
    TFile f("mytoys.root", "RECREATE");
    TTree *toyTree = RooStats::GetAsTTree("toyTree", "TTree created from test statistics", *sd);
    // save result to file, but in general do whatever you like
    f.cd();
    toyTree->Write();
    f.Close();

    TFile* tmpFile = new TFile("mytoys.root","READ");
    TTree* myTree = (TTree*)tmpFile->Get("toyTree");

    // get boundaries for histograms
    TIter nextLeaf( (myTree->GetListOfLeaves())->MakeIterator() );
    TObject* leafObj(0);
    map<TString, float> xMaxs;
    map<TString, float> xMins;
    for(int i(0); i<myTree->GetEntries(); i++) {
      myTree->GetEntry(i);
      nextLeaf = ( (myTree->GetListOfLeaves())->MakeIterator() );
      while( (leafObj = nextLeaf.Next()) ) {
        TString name(leafObj->GetName());
        float value(myTree->GetLeaf( leafObj->GetName() )->GetValue());
        if(value > xMaxs[name]) { xMaxs[name] = value; }
        if(value < xMins[name]) { xMins[name] = value; }
      } // loop over leaves
    } // loop over tree entries

    // plot everything in the tree
    myTree->GetEntry(0);
    nextLeaf = ( (myTree->GetListOfLeaves())->MakeIterator() );
    leafObj = 0;
    // make a histogram per leaf
    map<TString, TH1F*> hists;
    myTree->GetEntry(0);
    while( (leafObj = nextLeaf.Next()) ) {
      if(!leafObj) { continue; }
      //cout << leafObj->GetName() << endl;
      TString name(leafObj->GetName());
      // special ones : fit related things
      if(name.Contains("covQual"))   { hists[name] = new TH1F(name,name,5,0,5); continue; }
      if(name.Contains("fitStatus")) { hists[name] = new TH1F(name,name,5,0,5); continue; }
      int nbin(500); 
      float histMin( xMins[name] - 0.1*fabs(xMins[name]) ); 
      float histMax( xMaxs[name] + 0.1*fabs(xMaxs[name]) );
      if(name.Contains("ATLAS_norm")) { // floating normalization factors
        histMin = 0; histMax = 10;
      }
      else if(name.Contains("gamma_stat")) { // statistical nus param
        if(name.Contains("globObs")) {  // get custom range for sampling
          histMin = int( xMins[name] - 0.1*fabs(xMins[name]) );
          histMax = int( xMaxs[name] + 0.1*fabs(xMaxs[name]) );
        } // use small range for pull and error
        else { nbin = 100; histMin = 0.0; histMax = 2.0; }
      }
      else if(name.Contains("_err")) { // errors on nus param
        nbin = 100; histMin = 0.0; histMax = 2.0;
      }
      else if(name.Contains("fitCond") || name.Contains("fitUncond") || name.Contains("globObs")) { // fit pulls
        nbin = 500; histMin = -5; histMax = 5;
      }
      hists[name] = new TH1F(name,name,nbin,histMin,histMax);
    } // loop over leaves to declare histos

    // loop over entries and fill histograms
    for(int i(0); i<myTree->GetEntries(); i++) {
      myTree->GetEntry(i);
      nextLeaf = ( (myTree->GetListOfLeaves())->MakeIterator() );
      while( (leafObj = nextLeaf.Next()) ) {
        TString name(leafObj->GetName());
        if(hists.find(name) == hists.end()) { continue; }
        hists[name]->Fill( myTree->GetLeaf( leafObj->GetName() )->GetValue() );
      } // loop over leaves
    } // loop over tree entries

    // overflow and underflow
    for(map<TString,TH1F*>::iterator ihist(hists.begin()); ihist!=hists.end(); ihist++) {
      if(ihist->second->GetBinContent(0)>0) {
        ihist->second->SetBinContent(1, ihist->second->GetBinContent(0) + ihist->second->GetBinContent(1) );
        // fix err
      }
      int nBinx = ihist->second->GetNbinsX();
      if(ihist->second->GetBinContent(nBinx)>0) {
        ihist->second->SetBinContent(nBinx-1, ihist->second->GetBinContent(nBinx) + ihist->second->GetBinContent(nBinx-1) );
        // fix err
      }
    }

    // save the results
    TString dirName(OutputDir+"/PlotsStatisticalTest/GlobalFit");
    if(drawPlots) {
      system(TString("mkdir -vp "+dirName));
    }
    TCanvas* canvas = new TCanvas("pulls");
    TLegend *leg = new TLegend(0.67, 0.64, 0.87, 0.86);
    LegendStyle(leg);
    for(map<TString,TH1F*>::iterator ihist(hists.begin()); ihist!=hists.end(); ihist++) {
      if( (ihist->first).Contains("fitCond_") ) { continue; } // skip unconditional fit - get it explicitly
      canvas->Clear();
      leg->Clear();
      TString niceName(ihist->first);
      niceName.ReplaceAll("fitUncond_","");
      //niceName.ReplaceAll("SD_TS0_",""); // not good if have multiple test statistics
      // conditional fit information
      ihist->second->SetLineColor(kGray+2);
      ihist->second->SetTitle(niceName);
      ihist->second->SetLineStyle(kSolid);
      ihist->second->SetLineWidth(2);
      if((ihist->first).Contains("fit") && !(ihist->first).Contains("_err") 
          && !(ihist->first).Contains("Qual") && !(ihist->first).Contains("Status")) {
        ihist->second->Rebin(4);
      }

//      ihist->second->GetXaxis()->SetTitle("");
//      ihist->second->GetYaxis()->SetTitle("");

      if(niceName.Contains("globObs")) {
        leg->AddEntry( ihist->second, "Sampling", "l" ); // add value of mu
      } else {
        leg->AddEntry( ihist->second, "Unconditional Fit", "l" ); // add value of mu
      }
      TString condName(ihist->first);
      condName.ReplaceAll("fitUncond","fitCond");
      // uncomditional fit information
      if(hists.find(condName) != hists.end() && condName != ihist->first) {
        hists[condName]->SetLineColor(kGray+2);
        hists[condName]->SetLineStyle(kDashed);
        hists[condName]->SetLineWidth(2);
        if(!(ihist->first).Contains("_err")) { hists[condName]->Rebin(4); }
        leg->AddEntry( hists[condName], "Conditional Fit", "l" );
        if( hists[condName]->GetMaximum() > ihist->second->GetMaximum() ) {
          ihist->second->SetMaximum( hists[condName]->GetMaximum() );
        }
      }
      ihist->second->SetMaximum( 1.2 * ihist->second->GetMaximum() );
      canvas->cd();
      ihist->second->Draw();
      leg->Draw();
      if(hists[condName] && condName != ihist->first) { hists[condName]->Draw("same"); }
      if(drawPlots) { 
        canvas->Print(dirName+"/"+niceName+".eps");
        canvas->Print(dirName+"/"+niceName+".png");
      }

      MainDirStatTest->cd();
      canvas->Write();
      gROOT->cd();
    }

    // make a webpage
    if(drawPlots) {
      system("./createHTMLpageAllPlots.sh "+dirName+" &");
    }
    */

    // save result to file, but in general do whatever you like
//    f.cd();
//    toyTree->Write();
//    f.Close();
    return;


    /*
    // Test statistic : ProfiledLikelihood
    RooSimultaneous *simPdf = (RooSimultaneous*)(mc->GetPdf());
    ProfileLikelihoodTestStat ts(*simPdf);

    // To generate toy MC
    ToyMCSampler sampler;
    sampler.SetPdf(*mc->GetPdf());
    sampler.SetObservables(*mc->GetObservables());
    sampler.SetGlobalObservables(*mc->GetGlobalObservables());
    sampler.SetParametersForTestStat(*mc->GetParametersOfInterest());
    //ProofConfig pc(*w, 4, "workers=4",false);
    //sampler.SetProofConfig(&pc); 

    // Load all the model paramters
    RooArgSet allParameters;
    allParameters.add(*mc->GetParametersOfInterest());
    allParameters.add(*mc->GetNuisanceParameters());

    // Observed value
    firstPOI->setVal(mu_hyp);
    double ObsPLHR = ts.Evaluate( *data , *ParamOfInterest );
    data->Print();
    TCanvas *cobs = PlotData(data,simPdf);
    TString cobsname  = (TString) cobs->GetName() + (TString) "_RealData";
    cobs->SetName(cobsname);
    MainDirStatTest->cd();
    cobs->Write();
    gROOT->cd();

    // Make pseudo experiment and plot the TestStat distribution
    TString hname = Form("Distribution of q_{#mu=%1.1f} under pseudodata with #mu=%1.1f",mu_hyp,mu_pe);
    TH1F *hStatTest = new TH1F(hname,hname,100,0,10);
    double Npe_disagreed = 0;
    for (int ipe=0 ; ipe<nToyMC ; ipe++){
      firstPOI->setVal(mu_pe);
      RooAbsData *SampledDataSet = sampler.GenerateToyData(allParameters);
      firstPOI->setVal(mu_hyp);
      double StatTest = ts.Evaluate( *SampledDataSet , *ParamOfInterest );      
      hStatTest->Fill( StatTest );
      if (ipe%10==0){
        cout << "pseudo-exp " << ipe << ", StatTest = " << StatTest << endl;
        TCanvas *ctemp = PlotData(SampledDataSet,simPdf);
        TString ctempname = (TString) ctemp->GetName() + (TString) "_PseudoExp";
        ctempname += ipe;
        ctemp->SetName(ctempname);
        MainDirStatTest->cd();
        ctemp->Write();
        gROOT->cd();
      }

      if (StatTest>ObsPLHR) Npe_disagreed++;

    }
    hStatTest->Scale( 1./hStatTest->Integral(0,hStatTest->GetNbinsX()+1),"width" );
    hStatTest->GetYaxis()->SetTitle( Form("f(-log #lambda(#mu=%.2f) | #mu=%.2f)",mu_hyp,mu_pe) );
    hStatTest->GetXaxis()->SetTitle(Form("-log #lambda(#mu=%.2f)",mu_hyp) );

    // Plotting approximate distribution
    TString cname = "can_StatTestDistribution_ToyMC_mu"; cname += mu_pe;
    TCanvas* c1 = new TCanvas( cname );
    c1->SetLogy();
    hStatTest->Draw("hist");
    double min = 0;
    double max = 10;
    TF1* f = new TF1("f","1./pow(x,0.5) * 1./pow(2*3.14,0.5) * exp(-x/2) ",min,max);
    f->Draw("same");

    // Plotting the observed value of the stat test
    double  x[2] = {ObsPLHR,ObsPLHR};
    double  y[2] = {0.0001,2.0};
    TGraph *gobs = new TGraph(2,x,y);
    gobs->SetLineStyle(2);
    gobs->SetLineWidth(2);
    gobs->SetLineColor(1);
    c1->cd();
    gobs->Draw("CP");

    TLatex text;
    text.SetNDC();
    text.SetTextSize( 0.054);
    text.SetTextAlign(31);
    TString WritDownPvalue = Form("p_{#mu} = #int^{#infty}_{q^{obs}_{%1.1f}} f(q_{%1.1f}|%1.1f)dq_{%1.1f} = ",mu_hyp,mu_hyp,mu_pe,mu_hyp);
    WritDownPvalue += Form("%1.3f",(double)Npe_disagreed/nToyMC);
    c1->cd(); 
    text.DrawLatex( 0.88,0.77, WritDownPvalue );


    MainDirStatTest->cd();
    c1->Write();
    gROOT->cd();
    */

    return;
  }


  void PrintFits(){

    cout.precision(3);

    cout << endl;
    cout << endl;
    cout << endl;
    cout << "==================================================================" << endl;
    cout << "                          Fit results : status                    " << endl;
    cout << "===================================================================" << endl;
    cout << endl;
    cout << endl;

    typedef map<TString,int>::iterator it_type;
    for(it_type iterator = AllFitStatus_map.begin(); iterator != AllFitStatus_map.end(); iterator++) {
      TString fitname = iterator->first;
      int status = iterator->second;
      cout << fitname << "  :  minuit status = " << status << endl;
    }
    
    cout << endl;
    cout << "==================================================================" << endl;
    cout << endl;
    cout << endl;
    cout << endl;

    return;
  }

  void PrintSuspiciousNPs(){

    cout.precision(3);

    cout << endl;
    cout << endl;
    cout << endl;
    cout << "==================================================================" << endl;
    cout << "     List of nuisance parameters which deserve more attention     " << endl;
    cout << "===================================================================" << endl;
    cout << endl;
    cout << endl;
    cout << " === Tension between the NP central value and CP measurement ===" << endl;
    cout << " ===============================================================" << endl;
    cout << endl;
    for (unsigned i=0 ; i<AllNPafterEachFit_vec.size() ; i++){
      NPContainer MyNPsTemp = AllNPafterEachFit_vec[i];
      TString name = MyNPsTemp.NPname;
      double value = MyNPsTemp.NPvalue;
      double errHi = MyNPsTemp.NPerrorHi;
      double errLo = MyNPsTemp.NPerrorLo;
      TString Fit  = MyNPsTemp.WhichFit;

      name.ReplaceAll("\\","");

      if (fabs(value)>PullMaxAcceptable){
	cout << name << "\t : \t" << value << " \t +" << errHi << "\t -" << fabs(errLo) << "  \t Fit : " << Fit << endl;
      }
      
    }
    cout << endl;
    cout << endl;
    cout << " === Overconstraint of profiled NP wrt CP measurement ===" << endl;
    cout << " ========================================================" << endl;
    cout << endl;
    for (unsigned i=0 ; i<AllNPafterEachFit_vec.size() ; i++){
      NPContainer MyNPsTemp = AllNPafterEachFit_vec[i];
      TString name = MyNPsTemp.NPname;
      double value = MyNPsTemp.NPvalue;
      double errHi = MyNPsTemp.NPerrorHi;
      double errLo = MyNPsTemp.NPerrorLo;
      TString Fit  = MyNPsTemp.WhichFit;
      
      name.ReplaceAll("\\","");
      if ( (fabs(errHi)+fabs(errLo))/2.0<ErrorMinAcceptable ){
	cout << name << "\t : \t" << value << " \t +" << errHi << "\t -" << fabs(errLo) << "  \t Fit : " << Fit << endl;
      }
    }

    if (UseMinosError){
      cout << endl;
      cout << endl;
      cout << " === Nuisance parameters with one sided Minos error ===" << endl;
      cout << " ======================================================" << endl;
      cout << endl;
      for (unsigned i=0 ; i<AllNPafterEachFit_vec.size() ; i++){
	NPContainer MyNPsTemp = AllNPafterEachFit_vec[i];
	TString name = MyNPsTemp.NPname;
	double value = MyNPsTemp.NPvalue;
	double errHi = MyNPsTemp.NPerrorHi;
	double errLo = MyNPsTemp.NPerrorLo;
	TString Fit  = MyNPsTemp.WhichFit;
	
	name.ReplaceAll("\\","");
	if ( errHi==0 || errLo==0 ){
	  cout << name << "\t : \t" << value << " \t +" << errHi << "\t -" << fabs(errLo) << "  \t Fit : " << Fit << endl;
	}
      }
    }

    cout << endl;
    cout << endl;
    cout << "===================================================================" << endl;
    cout << endl;
    cout << endl;
    cout << endl;

    return;
  }



  double FindMuUpperLimit(){

    //RooMsgService::instance().setGlobalKillBelow(ERROR);

    RooRealVar* firstPOI = (RooRealVar*) mc->GetParametersOfInterest()->first();
    ProfileLikelihoodCalculator plc(*data,*mc);
    LikelihoodInterval* interval = plc.GetInterval();    
    double UpperLimit = interval->UpperLimit(*firstPOI);

    TCanvas* c2 = new TCanvas( "Likelihood_vs_mu" );
    LikelihoodIntervalPlot plot(interval);
    plot.SetNPoints(50);
    c2->cd();
    plot.Draw("");
    delete interval;
    
    SetAllStatErrorToSigma(0.0);
    SetAllNuisanceParaToSigma(0.0);

    outputfile->cd();
    c2->Write();
    gROOT->cd();

    return UpperLimit;

  }


    void GetNominalValueNuisancePara(){
    TIterator *it = mc->GetNuisanceParameters()->createIterator();
    RooRealVar *var = NULL;
    if (MapNuisanceParamNom.size() > 0) MapNuisanceParamNom.clear();
    std::cout << "Nuisance parameter names and values" << std::endl;
    while ((var = (RooRealVar*)it->Next()) != NULL){
      const double val = var->getVal();
      MapNuisanceParamNom[(string)var->GetName()] = val;
    }
    return;
  }
  

  void SetNominalValueNuisancePara(){
    TIterator *it = mc->GetNuisanceParameters()->createIterator();
    RooRealVar *var = NULL;
    while ((var = (RooRealVar*)it->Next()) != NULL){
      string varname = (string)var->GetName();
      const double val =  MapNuisanceParamNom[varname];
      var->setVal(val);
    }
    return;
  }
  
  
  void SetAllStatErrorToSigma(double Nsigma){
    
    TIterator* it = mc->GetNuisanceParameters()->createIterator();
    RooRealVar* var = NULL;
    while( (var = (RooRealVar*) it->Next()) ){
      string varname = (string) var->GetName();
      if ( varname.find("gamma_stat")!=string::npos ){
	RooAbsReal* nom_gamma = (RooConstVar*) w->obj( ("nom_" + varname).c_str() );
	double nom_gamma_val = nom_gamma->getVal();
	double sigma = 1/TMath::Sqrt( nom_gamma_val );
	var->setVal(1 + Nsigma*sigma);
      }
    }

    return;
  }



  void SetAllNuisanceParaToSigma(double Nsigma){

    TIterator* it = mc->GetNuisanceParameters()->createIterator();
    RooRealVar* var = NULL;
    while( (var = (RooRealVar*) it->Next()) ){
      string varname = (string) var->GetName();
      if ( varname.find("gamma_stat")!=string::npos ) continue;
      if(strcmp(var->GetName(),"Lumi")==0){
        var->setVal(w->var("nominalLumi")->getVal()*(1+Nsigma*LumiRelError));
      }
      else if (IsAnormFactor(var) && Nsigma==0) var->setVal(1.); // nominal for normfactor is 1.0
      else if (IsAnormFactor(var)) continue; // don't touch it if this is not nominal
      else  var->setVal(Nsigma);
    }
    
    return;
  }
  
  
  void SetNuisanceParaToSigma(RooRealVar *var, double Nsigma){
    
    string varname = (string) var->GetName();
    if ( varname.find("gamma_stat")!=string::npos ) return;

    if(strcmp(var->GetName(),"Lumi")==0){
      var->setVal(w->var("nominalLumi")->getVal()*(1+Nsigma*LumiRelError));
    } 
    else if (IsAnormFactor(var)) return;
    else var->setVal(Nsigma);
    
    return;
  }
  
  bool IsAnormFactor(RooRealVar *var){
    bool result=false;
    string varname = (string) var->GetName();
    const double val =  MapNuisanceParamNom[varname];
    if (!((TString)varname).Contains("_stat_") && val==1.0) result=true;
    return result;
  }

  void SetPOI(double mu){
    RooRealVar * firstPOI = dynamic_cast<RooRealVar*>(mc->GetParametersOfInterest()->first());
    firstPOI->setVal(mu);
    return  ;
  }
  
  
  bool IsSimultaneousPdfOK(){
    
    bool IsOK=true;
    
    bool IsSimultaneousPDF = strcmp(mc->GetPdf()->ClassName(),"RooSimultaneous")==0;
    if (!IsSimultaneousPDF){
      cout << " ERROR : no Simultaneous PDF was found, will stop here." << endl;
      cout << " You need to investigate your input histogramms." << endl;
      IsOK = false;
    }
    
    return IsOK;

  }


  bool IsChannelNameOK(){

    bool IsOK=true; 
    if( !IsSimultaneousPdfOK() ) return false;

    RooSimultaneous* simPdf = (RooSimultaneous*)(mc->GetPdf());
    RooCategory* channelCat = (RooCategory*) (&simPdf->indexCat());
    TIterator* iter = channelCat->typeIterator() ;
    RooCatType* tt = NULL;    
    while((tt=(RooCatType*) iter->Next()) ){
      string channelName =  tt->GetName();
      if (channelName.find("/")!=string::npos){
	cout << endl;
	cout << "One of the channel name contain a caracter \"/\" : " << endl;
	cout << "  - "  << channelName << endl;
	cout << "This is mis-intrepreted by roofit in the reading of the workspace. " << endl;
	cout << "Please change the channel name in the xml file to run this code." << endl;
	cout << endl;
	IsOK = false;
      }
    }


    return IsOK;
  }

  
  void PrintModelObservables(){
    
    RooArgSet* AllObservables = (RooArgSet*) mc->GetObservables();
    TIterator* iter = AllObservables->createIterator() ;
    RooAbsArg* MyObs = NULL;    
    cout << endl;
    cout << "List of model Observables : "  << endl;
    cout << "----------------------------"  << endl;
    while( (MyObs = (RooAbsArg*) iter->Next()) )
      MyObs->Print();
    
    return;
  }

  
  void PrintNuisanceParameters(){
    
    RooArgSet nuis = *mc->GetNuisanceParameters();
    TIterator* itr = nuis.createIterator();
    RooRealVar* arg;
    cout << endl;
    cout << "List of nuisance parameters : "  << endl;
    cout << "----------------------------"  << endl;    
    while ((arg=(RooRealVar*)itr->Next())) {
      if (!arg) continue;
      cout << arg->GetName()  << " : " << arg->getVal() << "+/-" << arg->getError() << "     IsNormFactor="<< IsAnormFactor(arg) << endl;
    }
    return;
  }


  void PrintAllParametersAndValues(RooArgSet para){
    TIterator* itr = para.createIterator();
    RooRealVar* arg;
    cout << endl;
    cout << "List of parameters : "  << endl;
    cout << "----------------------------"  << endl;    
    while ((arg=(RooRealVar*)itr->Next())) {
      if (!arg) continue;
      cout << arg->GetName() << " = " << arg->getVal() << endl;
    }
    return;
  }

  void PrintSubChannels(){
    
    RooMsgService::instance().setGlobalKillBelow(ERROR);

    if( !IsSimultaneousPdfOK() ) return;
    
    RooSimultaneous* simPdf = (RooSimultaneous*)(mc->GetPdf());
    RooCategory* channelCat = (RooCategory*) (&simPdf->indexCat());
    TIterator* iter = channelCat->typeIterator() ;
    RooCatType* tt = NULL;    

    while((tt=(RooCatType*) iter->Next()) ){
      
      RooAbsPdf  *pdftmp  = simPdf->getPdf( tt->GetName() );
      RooAbsData *datatmp = data->reduce(Form("%s==%s::%s",channelCat->GetName(),channelCat->GetName(),tt->GetName()));

      cout << endl;
      cout << endl;
      cout << "Details on channel " << tt->GetName() << " : "  << endl;
      cout << "----------------------------------------------------------" << endl;      
      datatmp->Print();
      pdftmp->Print();
      PrintNumberOfEvents(pdftmp);

    }

    return;
  }


  void PrintNumberOfEvents(RooAbsPdf *pdf){
    
    RooRealVar* firstPOI = (RooRealVar*) mc->GetParametersOfInterest()->first();
    double val_sym=1;
    cout 
      << Form(" %3s |","")
      << Form(" %-32s |","Nuisance Parameter") 
      << Form(" %18s |","Signal events") 
      << Form(" %18s |","% Change (+1sig)") 
      << Form(" %18s |","% Change (-1sig)") 
      << Form(" %18s |","Background events") 
      << Form(" %18s |","% Change (+1sig)") 
      << Form(" %18s |","% Change (-1sig)") 
      << endl;
  
    int inuis=-1;
    RooArgSet  *obstmp  = pdf->getObservables( *mc->GetObservables() ) ;
    RooRealVar *myobs   = ((RooRealVar*) obstmp->first());

    RooArgSet nuis = *mc->GetNuisanceParameters();
    TIterator* itr = nuis.createIterator();
    RooRealVar* arg;
    while ((arg=(RooRealVar*)itr->Next())) {
      if (!arg) continue;
      //
      ++inuis;
      //

      double val_hi = val_sym;
      double val_lo = -val_sym;
      double val_nom = arg->getVal();
      if (string(arg->GetName()) == "Lumi"){
	val_nom = w->var("nominalLumi")->getVal();
	val_hi  = w->var("nominalLumi")->getVal() * (1+LumiRelError);
	val_lo  = w->var("nominalLumi")->getVal() * (1-LumiRelError);
      }
      //
      arg->setVal(val_hi);
      firstPOI->setVal(0);
      double b_hi = pdf->expectedEvents(*myobs);
      firstPOI->setVal(1);
      double s_hi = pdf->expectedEvents(*myobs)-b_hi;
      //
      arg->setVal(val_lo);
      firstPOI->setVal(0);
      double b_lo = pdf->expectedEvents(*myobs);
      firstPOI->setVal(1);
      double s_lo = pdf->expectedEvents(*myobs)-b_lo;
      //
      arg->setVal(val_nom);
      firstPOI->setVal(0);
      double b_nom = pdf->expectedEvents(*myobs);
      firstPOI->setVal(1);
      double s_nom = pdf->expectedEvents(*myobs)-b_nom;
      //
      double x_nom = s_nom ;
      double x_hi  = 0; if (s_nom) x_hi = (s_hi-s_nom)/s_nom; 
      double x_lo  = 0; if (s_nom) x_lo = (s_lo-s_nom)/s_nom; 
      double y_nom = b_nom ;
      double y_hi  = 0; if (b_nom) y_hi = (b_hi-b_nom)/b_nom; 
      double y_lo  = 0; if (b_nom) y_lo = (b_lo-b_nom)/b_nom; 

      cout 
	<< Form(" %3d |",inuis)
	<< Form(" %-32s |",arg->GetName()) 
	<< Form(" %18.2f |",x_nom) 
	<< Form(" %18.2f |",100*x_hi) 
	<< Form(" %18.2f |",100*x_lo) 
	<< Form(" %18.2f |",y_nom) 
	<< Form(" %18.2f |",100*y_hi) 
	<< Form(" %18.2f |",100*y_lo) 
	<< endl;
    } 

    return;
  }
  
  void SetStyle(){
    gStyle->SetOptStat(0);
    
    return;
  }

  void LegendStyle(TLegend* l) {
    l->SetBorderSize(0);
    l->SetFillColor(0);
    l->SetLineColor(0);
    l->SetFillStyle(0);
    //l->SetTextFont(62);
    l->SetTextSize(0.050);
    return;
  }
  
  void Initialize(const char* infile , const char* outputdir, const char* workspaceName, const char* modelConfigName, const char* ObsDataName) {
    // Cosmetics
    SetStyle();

    // Lumi error hard-coded;
    LumiRelError = 0.032; // 0.037
    
    // Container for the plots
    OutputDir = (TString) outputdir;
    gSystem->Exec("mkdir -p " + OutputDir);
    gSystem->Exec("mkdir -p " + OutputDir + "/LatexFileNPs");
    gSystem->Exec("mkdir -p " + OutputDir + "/TextFileFitResult");
    outputfile = new TFile(OutputDir+"/FitCrossChecks.root","RECREATE");
    
    // Load workspace, model and data
    TFile *file = TFile::Open(infile);
    if (!file) {
      cout << "The file " << infile << " is not found/created, will stop here." << endl;
      return;
    }
    if(!(RooWorkspace*) file->Get(workspaceName)){
      cout <<"workspace not found" << endl;
      return;
    }

    w      = (RooWorkspace*) file->Get(workspaceName);
    mc     = (ModelConfig*) w->obj(modelConfigName);
    data   = w->data(ObsDataName);
    
    
    if (!data || isBlind>0){
      if (isBlind == 1)	data = makeAsimovData(mu_asimov);
      else              data = makeAsimovData(mu_asimov, true); //fluctuated
    }
    
    w->SetName("w");
    w->SetTitle("w");

    // save snapshot before any fit has been done
    RooSimultaneous* pdf = (RooSimultaneous*)(mc->GetPdf()); //CHANGED
    if( !pdf ){
      cerr<<"simPDF cannot be found!\nexiting...."<<endl;
      exit(1);
    }
    RooArgSet* params = (RooArgSet*) pdf->getParameters(*data) ;
    if(!w->loadSnapshot("snapshot_paramsVals_initial"))  w->saveSnapshot("snapshot_paramsVals_initial",*params);
    else cout << endl << " Snapshot 'snapshot_paramsVals_initial' already exists in  workspace, will not overwrite it" << endl;
    if(!data || !mc){
      w->Print();
      cout << "data or ModelConfig was not found" <<endl;
      return;
    }
      
    // Some sanity checks on the workspace
    if ( !IsSimultaneousPdfOK() ) return;
    if (   !IsChannelNameOK()   ) return;
    GetNominalValueNuisancePara();
    AllNPafterEachFit_vec.clear();
    AllFitResults_map.clear();

    // Print some information
    PrintModelObservables();
    PrintNuisanceParameters();
    PrintSubChannels();
    
    // Prepare the directory structure of the outputfile
    MainDirSyst              = (TDirectory*) outputfile->mkdir("PlotsBeforeFit");
    MainDirMorphing          = (TDirectory*) outputfile->mkdir("PlotsMorphing");
    MainDirFitEachSubChannel = (TDirectory*) outputfile->mkdir("PlotsAfterFitOnSubChannel");
    MainDirFitGlobal         = (TDirectory*) outputfile->mkdir("PlotsAfterGlobalFit");
    MainDirModelInspector    = (TDirectory*) outputfile->mkdir("PlotsNuisanceParamVSmu");
    MainDirStatTest          = (TDirectory*) outputfile->mkdir("PlotsStatisticalTest");
    gROOT->cd();

  }

  void Finalize() {
    outputfile->Close();
    PrintSuspiciousNPs();
    PrintFits();
  }
 

void unfoldConstraints(RooArgSet& initial, RooArgSet& final, RooArgSet& obs, RooArgSet& nuis, int& counter)
{
  if (counter > 50)
  {
    cout << "ERROR::Couldn't unfold constraints!" << endl;
    cout << "Initial: " << endl;
    initial.Print("v");
    cout << endl;
    cout << "Final: " << endl;
    final.Print("v");
    exit(1);
  }
  TIterator* itr = initial.createIterator();
  RooAbsPdf* pdf;
  while ((pdf = (RooAbsPdf*)itr->Next()))
  {
    RooArgSet nuis_tmp = nuis;
    RooArgSet constraint_set(*pdf->getAllConstraints(obs, nuis_tmp, false));
    //if (constraint_set.getSize() > 1)
    //{
    string className(pdf->ClassName());
    if (className != "RooGaussian" && className != "RooLognormal" && className != "RooGamma" && className != "RooPoisson" && className != "RooBifurGauss")
    {
      counter++;
      unfoldConstraints(constraint_set, final, obs, nuis, counter);
    }
    else
    {
      final.add(*pdf);
    }
  }
  delete itr;
}

  
  RooDataSet* makeAsimovData(double mu_val, bool fluctuateData, string* mu_str){


  ////////////////////
  //make asimov data//
  ////////////////////
  RooAbsPdf* combPdf = mc->GetPdf();
  
  int _printLevel = 1;

  stringstream muStr;
  muStr << setprecision(5);
  muStr << "_" << mu_val;
  if (mu_str) *mu_str = muStr.str();
  cout<<muStr.str()<<endl;

  stringstream muStrProf;

  RooRealVar* mu = (RooRealVar*)mc->GetParametersOfInterest()->first();//w->var("mu");
  mu->setVal(mu_val);

  RooArgSet mc_obs = *mc->GetObservables();
  RooArgSet mc_globs = *mc->GetGlobalObservables();
  RooArgSet mc_nuis = *mc->GetNuisanceParameters();

  //pair the nuisance parameter to the global observable
  RooArgSet mc_nuis_tmp = mc_nuis;
  RooArgList nui_list("ordered_nuis");
  RooArgList glob_list("ordered_globs");
  RooArgSet constraint_set_tmp(*combPdf->getAllConstraints(mc_obs, mc_nuis_tmp, false));
  RooArgSet constraint_set;
  int counter_tmp = 0;
  unfoldConstraints(constraint_set_tmp, constraint_set, mc_obs, mc_nuis_tmp, counter_tmp);

  TIterator* cIter = constraint_set.createIterator();
  RooAbsArg* arg;
  while ((arg = (RooAbsArg*)cIter->Next())){
    RooAbsPdf* pdf = (RooAbsPdf*)arg;
    if (!pdf) continue;
    TIterator* nIter = mc_nuis.createIterator();
    RooRealVar* thisNui = NULL;
    RooAbsArg* nui_arg;
    while ((nui_arg = (RooAbsArg*)nIter->Next())){
      if (pdf->dependsOn(*nui_arg)){
	thisNui = (RooRealVar*)nui_arg;
	break;
      }
    }
    delete nIter;
    

    //need this in case the observable isn't fundamental. 
    //in this case, see which variable is dependent on the nuisance parameter and use that.
    RooArgSet* components = pdf->getComponents();
    components->remove(*pdf);
    if (components->getSize()){
      TIterator* itr1 = components->createIterator();
      RooAbsArg* arg1;
      while ((arg1 = (RooAbsArg*)itr1->Next())){
	TIterator* itr2 = components->createIterator();
	RooAbsArg* arg2;
	while ((arg2 = (RooAbsArg*)itr2->Next())){
	  if (arg1 == arg2) continue;
	  if (arg2->dependsOn(*arg1)){
	    components->remove(*arg1);
	  }
	}
	delete itr2;
      }
      delete itr1;
    }
    if (components->getSize() > 1){
      cout << "ERROR::Couldn't isolate proper nuisance parameter" << endl;
      return NULL;
    }
    else if (components->getSize() == 1){
      thisNui = (RooRealVar*)components->first();
    }
    
    TIterator* gIter = mc_globs.createIterator();
    RooRealVar* thisGlob = NULL;
    RooAbsArg* glob_arg;
    while ((glob_arg = (RooAbsArg*)gIter->Next())){
      if (pdf->dependsOn(*glob_arg)){
	thisGlob = (RooRealVar*)glob_arg;
	break;
      }
    }
    delete gIter;

    if (!thisNui || !thisGlob){
      cout << "WARNING::Couldn't find nui or glob for constraint: " << pdf->GetName() << endl;
      continue;
    }

    if (_printLevel >= 1) cout << "Pairing nui: " << thisNui->GetName() << ", with glob: " << thisGlob->GetName() << ", from constraint: " << pdf->GetName() << endl;

    nui_list.add(*thisNui);
    glob_list.add(*thisGlob);

  }
  delete cIter;
  



  //save the snapshots of nominal parameters, but only if they're not already saved
  w->saveSnapshot("tmpGlobs",*mc->GetGlobalObservables());
  w->saveSnapshot("tmpNuis",*mc->GetNuisanceParameters());
  if (!w->loadSnapshot("nominalGlobs")){
    cout << "nominalGlobs doesn't exist. Saving snapshot." << endl;
    w->saveSnapshot("nominalGlobs",*mc->GetGlobalObservables());
  }
  else w->loadSnapshot("tmpGlobs");
  if (!w->loadSnapshot("nominalNuis")){
    cout << "nominalNuis doesn't exist. Saving snapshot." << endl;
    w->saveSnapshot("nominalNuis",*mc->GetNuisanceParameters());
  }
  else w->loadSnapshot("tmpNuis");
    
  mu->setConstant(0);
  mu->setVal(mu_val);



  //loop over the nui/glob list, grab the corresponding variable from the tmp ws, and set the glob to the value of the nui
  int nrNuis = nui_list.getSize();
  if (nrNuis != glob_list.getSize()){
    cout << "ERROR::nui_list.getSize() != glob_list.getSize()!" << endl;
    return NULL;
  }
  
  for (int i=0;i<nrNuis;i++){
    RooRealVar* nui = (RooRealVar*)nui_list.at(i);
    RooRealVar* glob = (RooRealVar*)glob_list.at(i);
    
    cout << "nui: " << nui << ", glob: " << glob << endl;
    cout << "Setting glob: " << glob->GetName() << ", which had previous val: " << glob->getVal() << ", to conditional val: " << nui->getVal() << endl;
    
    glob->setVal(nui->getVal());
  }
  
  w->loadSnapshot("nominalGlobs");
  w->loadSnapshot("nominalNuis");

  if (_printLevel >= 1) cout << "Making asimov mu=" <<mu_val<< endl;

  //make the asimov data (snipped from Kyle)
  mu->setVal(mu_val);

  int iFrame=0;

  const char* weightName="weightVar";
  RooArgSet obsAndWeight;
  obsAndWeight.add(*mc->GetObservables());

  RooRealVar* weightVar = NULL;
  if (!(weightVar = w->var(weightName))){
    w->import(*(new RooRealVar(weightName, weightName, 1,0,10000000)));
    weightVar = w->var(weightName);
  }
  obsAndWeight.add(*w->var(weightName));
  w->defineSet("obsAndWeight",obsAndWeight);


  //////////////////////////////////////////////////////
  // MAKE ASIMOV DATA FOR OBSERVABLES
  //////////////////////////////////////////////////////

  RooSimultaneous* simPdf = dynamic_cast<RooSimultaneous*>(mc->GetPdf());

  RooDataSet* asimovData;
  if (!simPdf)
  {
    // Get pdf associated with state from simpdf
    RooAbsPdf* pdftmp = mc->GetPdf();//simPdf->getPdf(channelCat->getLabel()) ;
	
    // Generate observables defined by the pdf associated with this state
    RooArgSet* obstmp = pdftmp->getObservables(*mc->GetObservables()) ;

    if (_printLevel >= 1) obstmp->Print();
    
    if( fluctuateData ){
      cout<<"Creating extended datasample"<<endl;
      asimovData = pdftmp->generate(RooArgSet(obsAndWeight),Extended(kTRUE));
    }else{
      asimovData = new RooDataSet(("asimovData"+muStr.str()).c_str(),("asimovData"+muStr.str()).c_str(),RooArgSet(obsAndWeight),WeightVar(*weightVar));
      
      RooRealVar* thisObs = ((RooRealVar*)obstmp->first());
      double expectedEvents = pdftmp->expectedEvents(*obstmp);
      double thisNorm = 0;
      for(int jj=0; jj<thisObs->numBins(); ++jj){
	thisObs->setBin(jj);
	
	thisNorm=pdftmp->getVal(obstmp)*thisObs->getBinWidth(jj);
	if (thisNorm*expectedEvents <= 0)
	  {
	    cout << "WARNING::Detected bin with zero expected events (" << thisNorm*expectedEvents << ") ! Please check your inputs. Obs = " << thisObs->GetName() << ", bin = " << jj << endl;
	  }
	if (thisNorm*expectedEvents > 0 && thisNorm*expectedEvents < pow(10.0, 18)) {
	  asimovData->add(*mc->GetObservables(), thisNorm*expectedEvents); 
	}
      }
    }
    if (_printLevel >= 1){
      asimovData->Print();
      cout <<"sum entries "<<asimovData->sumEntries()<<endl;
    }
    if(asimovData->sumEntries()!=asimovData->sumEntries()){
      cout << "sum entries is nan"<<endl;
      exit(1);
    }

    w->import(*asimovData);

    if (_printLevel >= 1){
      asimovData->Print();
      cout << endl;
    }
  }
  
  else{
    map<string, RooDataSet*> asimovDataMap;
    
    //try fix for sim pdf
    RooCategory* channelCat = (RooCategory*)&simPdf->indexCat();
    TIterator* iter = channelCat->typeIterator() ;
    RooCatType* tt = NULL;
    int nrIndices = 0;
    while((tt=(RooCatType*) iter->Next())) {
      nrIndices++;
    }
    
    for (int i=0;i<nrIndices;i++){
      channelCat->setIndex(i);
      iFrame++;
      // Get pdf associated with state from simpdf
      RooAbsPdf* pdftmp = simPdf->getPdf(channelCat->getLabel()) ;
	
      // Generate observables defined by the pdf associated with this state
      RooArgSet* obstmp = pdftmp->getObservables(*mc->GetObservables()) ;

      if (_printLevel >= 1){
	obstmp->Print();
	cout << "on type " << channelCat->getLabel() << " " << iFrame << endl;
      }

      RooDataSet* obsDataUnbinned = new RooDataSet(Form("combAsimovData%d",iFrame),Form("combAsimovData%d",iFrame),RooArgSet(obsAndWeight,*channelCat),WeightVar(*weightVar));
      RooRealVar* thisObs = ((RooRealVar*)obstmp->first());
      double expectedEvents = pdftmp->expectedEvents(*obstmp);
      double thisNorm = 0;

      if( fluctuateData ){
	cout<<"Creating extended datasample"<<endl;
	obsDataUnbinned = pdftmp->generate(RooArgSet(obsAndWeight),Extended(kTRUE));
	obsDataUnbinned = pdftmp->generate(RooArgSet(obsAndWeight),Extended(kTRUE));
      }
      else{
	for(int jj=0; jj<thisObs->numBins(); ++jj){
	  thisObs->setBin(jj);
	  
	  thisNorm=pdftmp->getVal(obstmp)*thisObs->getBinWidth(jj);
	  if (thisNorm*expectedEvents > 0 && thisNorm*expectedEvents < pow(10.0, 18)) obsDataUnbinned->add(*mc->GetObservables(), thisNorm*expectedEvents);
	}
      }
      if (_printLevel >= 1){
	obsDataUnbinned->Print();
	cout <<"sum entries "<<obsDataUnbinned->sumEntries()<<endl;
      }
      if(obsDataUnbinned->sumEntries()!=obsDataUnbinned->sumEntries()){
	cout << "sum entries is nan"<<endl;
	exit(1);
      }

      asimovDataMap[string(channelCat->getLabel())] = obsDataUnbinned;

      if (_printLevel >= 1){
	cout << "channel: " << channelCat->getLabel() << ", data: ";
	obsDataUnbinned->Print();
	cout << endl;
      }
    }
    
    asimovData = new RooDataSet(("asimovData"+muStr.str()).c_str(),
				("asimovData"+muStr.str()).c_str(),
				RooArgSet(obsAndWeight,*channelCat),
				Index(*channelCat),
				Import(asimovDataMap),
				WeightVar(*weightVar));
    w->import(*asimovData);
  }

  //bring us back to nominal for exporting
  w->loadSnapshot("nominalGlobs");

  return asimovData;
  }  

}


//============================================================
// ================= Executable function =====================
//============================================================


enum Algs { PlotHistosBeforeFit=0, PlotMorphingControlPlots, PlotHistosAfterFitEachSubChannel, PlotHistosAfterFitGlobal, PlotsNuisanceParametersVSmu, PlotsStatisticalTest };

void FitCrossCheckForLimits(const Algs algorithm         = PlotHistosBeforeFit,
                            float mu                    = 0,
                            float sigma                 = 1,
                            bool IsConditional          = false,
                            const char* infile          = "WorkspaceForTest1.root",
                            const char* outputdir       = "./results/",
                            const char* workspaceName   = "combined",
                            const char* modelConfigName = "ModelConfig",
                            const char* ObsDataName     = "obsData") {

  LimitCrossCheck::Initialize(infile, outputdir, workspaceName, modelConfigName, ObsDataName);

  switch(algorithm) {
    // -----------------------------------------------------------------------------------
    // - Plot nominal and +/- Nsigma (for each nuisance paramater) for Data, signal+bkg
    // -----------------------------------------------------------------------------------
    case PlotHistosBeforeFit:
      LimitCrossCheck::PlotHistosBeforeFit(sigma,mu); // (nSigma,mu)
    break;

    // -----------------------------------------------------------------------------------
    // - Control plots for morphing (ie, -1/0/+1 sigma --> continuous NP)
    // -----------------------------------------------------------------------------------    
    case PlotMorphingControlPlots:
      LimitCrossCheck::PlotMorphingControlPlots();
    break;

    // ----------------------------------------------------------------------------------
    // - Plot histograms after unconditional fit (theta and mu fitted at the same time)
    // - Or
    // - Plot the unconditionnal fitted nuisance paramters value (theta fitted while mu is fixed)
    // ----------------------------------------------------------------------------------    
    case PlotHistosAfterFitEachSubChannel:
      LimitCrossCheck::PlotHistosAfterFitEachSubChannel(IsConditional, mu);
    break;
    case PlotHistosAfterFitGlobal:
      LimitCrossCheck::PlotHistosAfterFitGlobal(IsConditional, mu);
    break;

    // -------------------------------------------
    // - Plot the nuisance parameters versus mu
    // -------------------------------------------
    case PlotsNuisanceParametersVSmu:
      LimitCrossCheck::PlotsNuisanceParametersVSmu();
    break;

    // -------------------------------------------
    // - Plot the pulls and stat test from toys
    // -------------------------------------------
    case PlotsStatisticalTest:
      // For this algorithm mu is the mu used for pseudo-data
      // sigma is the hypothetized mu for the statistical tests
      LimitCrossCheck::PlotsStatisticalTest(mu, sigma);
    break;
    default:
      cout << "FitCrossChecksForLimits:: ERROR: unknown Algorithm requested" << endl;
    break;
  }
  LimitCrossCheck::Finalize();
  return;

}


